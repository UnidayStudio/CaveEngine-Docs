{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Cave Engine's Documentation (Use the top menu to navigate in the categories) Cave Engine is a Simple 3D desktop Game Engine scriptable in Python. In this website you'll find the documentation you need to get started with the scripting in the engine and also some useful information such as the future roadmap and license. Download the Engine You can check the details and download the engine using this link: Download the Cave Engine Our Discord Server If you want to talk about the engine, leave some suggestions, comments or get some help from the community, feel free to join us: Discord - English Discord - Portuguese/Brazil Note that at the moment we have a portuguese and an english discord so you can feel free to join the one you're more confortable with.","title":"Home"},{"location":"#welcome-to-cave-engines-documentation","text":"(Use the top menu to navigate in the categories) Cave Engine is a Simple 3D desktop Game Engine scriptable in Python. In this website you'll find the documentation you need to get started with the scripting in the engine and also some useful information such as the future roadmap and license.","title":"Welcome to Cave Engine's Documentation"},{"location":"#download-the-engine","text":"You can check the details and download the engine using this link: Download the Cave Engine","title":"Download the Engine"},{"location":"#our-discord-server","text":"If you want to talk about the engine, leave some suggestions, comments or get some help from the community, feel free to join us: Discord - English Discord - Portuguese/Brazil Note that at the moment we have a portuguese and an english discord so you can feel free to join the one you're more confortable with.","title":"Our Discord Server"},{"location":"Docs/eula/","text":"In a Nutshell: Cave Engine consists in two parts : The Cave Engine Editor and everything it requires to run. The end-product \" Game \" generated by the editor. The Cave Engine Editor is an intellectual property of Uniday Studio and you have a personal, non-transferable, non-exclusive licence to use the Cave Engine Editor software on your devices. You're not allowed to share, modify or redistribute it in any forms other than the ones provided by Uniday Studio. The Game generated by the Cave Engine Editor can be redistributed (even commercially) uner the collowing term: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. Including the phrase: \"Made using Cave Engine - from Uniday Studio\" in the project and license, in a visible and easily foundable place is enough. Remember that the name Uniday Studio is a registered trademark and you are not allowed to use it to endorse your projects in any forms. End-User License Agreement (EULA) of Cave Engine This End-User License Agreement (\"EULA\") is a legal agreement between you and Uniday Studio . This EULA agreement governs your acquisition and use of our Cave Engine software (\"Software\") directly from Uniday Studio or indirectly through a Uniday Studio authorized reseller or distributor (a \"Reseller\"). Our Privacy Policy was created by the Privacy Policy Generator. Please read this EULA agreement carefully before completing the installation process and using the Cave Engine software. It provides a license to use the Cave Engine software and contains warranty information and liability disclaimers. If you register for a free trial of the Cave Engine software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Cave Engine software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Uniday Studio herewith regardless of whether other software is referred to or described herein. The terms also apply to any Uniday Studio updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply. License Grant Uniday Studio hereby grants you a personal, non-transferable, non-exclusive licence to use the Cave Engine software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Cave Engine software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Cave Engine software. Uniday Studios also hereby grants you the rights to redistribute the end-product \"Game\" generated by the editor, including for commercial purposes, under the following terms: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. The exported Game can not include a copy of the Cave Engine Editor . Not use a license that forces this software to be open source or change its license (such as GPL). Your project (game) can be source open but the Cave Engine Editor software can't be forced to. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose, except with the generated Game . Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Uniday Studio considers is a breach of this EULA agreement Intellectual Property and Ownership Uniday Studio shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Uniday Studio. Uniday Studio reserves the right to grant licences to use the Software to third parties. Termination This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Uniday Studio. It will also terminate immediately if you fail to comply with any term of this EULA agreement. Upon such termination, the licenses granted by this EULA agreement will immediately terminate and you agree to stop all access and use of the Software. The provisions that by their nature continue and survive will survive any termination of this EULA agreement. Governing Law This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of Brazil.","title":"License (EULA)"},{"location":"Docs/eula/#in-a-nutshell","text":"Cave Engine consists in two parts : The Cave Engine Editor and everything it requires to run. The end-product \" Game \" generated by the editor. The Cave Engine Editor is an intellectual property of Uniday Studio and you have a personal, non-transferable, non-exclusive licence to use the Cave Engine Editor software on your devices. You're not allowed to share, modify or redistribute it in any forms other than the ones provided by Uniday Studio. The Game generated by the Cave Engine Editor can be redistributed (even commercially) uner the collowing term: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. Including the phrase: \"Made using Cave Engine - from Uniday Studio\" in the project and license, in a visible and easily foundable place is enough. Remember that the name Uniday Studio is a registered trademark and you are not allowed to use it to endorse your projects in any forms.","title":"In a Nutshell:"},{"location":"Docs/eula/#end-user-license-agreement-eula-of-cave-engine","text":"This End-User License Agreement (\"EULA\") is a legal agreement between you and Uniday Studio . This EULA agreement governs your acquisition and use of our Cave Engine software (\"Software\") directly from Uniday Studio or indirectly through a Uniday Studio authorized reseller or distributor (a \"Reseller\"). Our Privacy Policy was created by the Privacy Policy Generator. Please read this EULA agreement carefully before completing the installation process and using the Cave Engine software. It provides a license to use the Cave Engine software and contains warranty information and liability disclaimers. If you register for a free trial of the Cave Engine software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Cave Engine software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Uniday Studio herewith regardless of whether other software is referred to or described herein. The terms also apply to any Uniday Studio updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply.","title":"End-User License Agreement (EULA) of Cave Engine"},{"location":"Docs/eula/#license-grant","text":"Uniday Studio hereby grants you a personal, non-transferable, non-exclusive licence to use the Cave Engine software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Cave Engine software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Cave Engine software. Uniday Studios also hereby grants you the rights to redistribute the end-product \"Game\" generated by the editor, including for commercial purposes, under the following terms: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. The exported Game can not include a copy of the Cave Engine Editor . Not use a license that forces this software to be open source or change its license (such as GPL). Your project (game) can be source open but the Cave Engine Editor software can't be forced to. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose, except with the generated Game . Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Uniday Studio considers is a breach of this EULA agreement","title":"License Grant"},{"location":"Docs/eula/#intellectual-property-and-ownership","text":"Uniday Studio shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Uniday Studio. Uniday Studio reserves the right to grant licences to use the Software to third parties.","title":"Intellectual Property and Ownership"},{"location":"Docs/eula/#termination","text":"This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Uniday Studio. It will also terminate immediately if you fail to comply with any term of this EULA agreement. Upon such termination, the licenses granted by this EULA agreement will immediately terminate and you agree to stop all access and use of the Software. The provisions that by their nature continue and survive will survive any termination of this EULA agreement.","title":"Termination"},{"location":"Docs/eula/#governing-law","text":"This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of Brazil.","title":"Governing Law"},{"location":"Docs/faq/","text":"Frequently Asked Questions (FAQ) What is the Point of Cave Engine? In a nutshell: Cave Engine is focusing 100% on the usability and your experience using it. Keep it as simple as possible so even someone with zero experience with game development will be able to use it, but at the same time, keep it powerful enough to support your biggest dreams . And how we are managing to do that? We are a company called Uniday Studio that develops and teaches game dev since many years ago. We had te opportunity to reach more than two million people across the world on YouTube, teaching game dev, and we have hundreds and hundreds of students in our courses. After so many years, students and answering literally dozens of thousands of questions about the topic, we realized that a lot of people don't make their games because they found too hard to get started or use the software. We reched a conclusion that, just like a joke, if a game engine needs an explanation on how to use it, then this engine may not be that good. And that's our main principle now. Of course, some things inside a game engine may need a few tips to figure out how to use, but hours and hours of tutorials only to get started? That's not an option for us. Cave Engine is focused in provide the smallest path between you and your dream games. Is Cave Engine free? Yes. Can I sell or Redistribute my Game made using Cave Engine? Yes! Under attribution to the Cave Engine - by Uniday Studio. That's it! Can I sell or Redistribute the Cave Engine Editor? No! The Cave Engine Editor is an intellectual property of Uniday Studio and you don't have permission to sell or redistribute it. If you want/need to share the engine with someone, please use the links provided by Uniday Studio. There are plans to support 2D games? No, there is no plans to add 2D game specific features. Cave Engine is 100% focused on 3D game development. But also note that nothing avoids you to use an ortographic camera and create a 2D game using it. How can I create my Logics using Cave Engine? You can do it using Python Scripts . And be aware: There are plans to include a Visual Programming alternative. Was the entire engine written in Python? Absolutely no! All the Engine and Editor was written in C/C++ and GLSL. We just provide Python Scripting as a front end for you to easily create the logic of your games. To which Platforms can I export my game? For now, you can export your games for Windows. There are plans to support Linux and Mac in the future, but it's low priority for now. Will be possible to export the game to other platforms such as Android in the future? It's too early to answer that question precisely. For now, the focus is to make the easiest and best engine for desktop development. Once we reach that goal, we think to start porting first to WebGL (to run in a Browser) and maybe Android. But it's not even in the roadmap yet.","title":"Frequently Asked Questions (FAQ)"},{"location":"Docs/faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"Docs/faq/#what-is-the-point-of-cave-engine","text":"In a nutshell: Cave Engine is focusing 100% on the usability and your experience using it. Keep it as simple as possible so even someone with zero experience with game development will be able to use it, but at the same time, keep it powerful enough to support your biggest dreams . And how we are managing to do that? We are a company called Uniday Studio that develops and teaches game dev since many years ago. We had te opportunity to reach more than two million people across the world on YouTube, teaching game dev, and we have hundreds and hundreds of students in our courses. After so many years, students and answering literally dozens of thousands of questions about the topic, we realized that a lot of people don't make their games because they found too hard to get started or use the software. We reched a conclusion that, just like a joke, if a game engine needs an explanation on how to use it, then this engine may not be that good. And that's our main principle now. Of course, some things inside a game engine may need a few tips to figure out how to use, but hours and hours of tutorials only to get started? That's not an option for us. Cave Engine is focused in provide the smallest path between you and your dream games.","title":"What is the Point of Cave Engine?"},{"location":"Docs/faq/#is-cave-engine-free","text":"Yes.","title":"Is Cave Engine free?"},{"location":"Docs/faq/#can-i-sell-or-redistribute-my-game-made-using-cave-engine","text":"Yes! Under attribution to the Cave Engine - by Uniday Studio. That's it!","title":"Can I sell or Redistribute my Game made using Cave Engine?"},{"location":"Docs/faq/#can-i-sell-or-redistribute-the-cave-engine-editor","text":"No! The Cave Engine Editor is an intellectual property of Uniday Studio and you don't have permission to sell or redistribute it. If you want/need to share the engine with someone, please use the links provided by Uniday Studio.","title":"Can I sell or Redistribute the Cave Engine Editor?"},{"location":"Docs/faq/#there-are-plans-to-support-2d-games","text":"No, there is no plans to add 2D game specific features. Cave Engine is 100% focused on 3D game development. But also note that nothing avoids you to use an ortographic camera and create a 2D game using it.","title":"There are plans to support 2D games?"},{"location":"Docs/faq/#how-can-i-create-my-logics-using-cave-engine","text":"You can do it using Python Scripts . And be aware: There are plans to include a Visual Programming alternative.","title":"How can I create my Logics using Cave Engine?"},{"location":"Docs/faq/#was-the-entire-engine-written-in-python","text":"Absolutely no! All the Engine and Editor was written in C/C++ and GLSL. We just provide Python Scripting as a front end for you to easily create the logic of your games.","title":"Was the entire engine written in Python?"},{"location":"Docs/faq/#to-which-platforms-can-i-export-my-game","text":"For now, you can export your games for Windows. There are plans to support Linux and Mac in the future, but it's low priority for now.","title":"To which Platforms can I export my game?"},{"location":"Docs/faq/#will-be-possible-to-export-the-game-to-other-platforms-such-as-android-in-the-future","text":"It's too early to answer that question precisely. For now, the focus is to make the easiest and best engine for desktop development. Once we reach that goal, we think to start porting first to WebGL (to run in a Browser) and maybe Android. But it's not even in the roadmap yet.","title":"Will be possible to export the game to other platforms such as Android in the future?"},{"location":"Docs/roadmap/","text":"Roadmap Cave Engine Alpha (Current) During this iteration the focus is to make Cave Engine as simple, usable, stable, solid and feature complete as possible. In other word, we need to make sure that everyone will be able to jump in and start making their games with the least amount of problems or difficults as possible. Here the focus will be on providing documentation, tutorials, bug fixes, build a community around it and also change and improve the UI and UX as much as we feel like it's necessary to make it as user friendly as possible. Again, from the ground up this engine needs to be friendly, easy to use and of course powerful enough to support your biggest dreams. So if something is missing to make that dream come true, here is the right time to add it! Cave Engine 1.0 Here the engine should be already stable enough and with a bunch of cool games made with it. Now it's time to keep cultivating so it can grow more and more! The attention to the usability and bug fixing still keeps the same (and this will never change), but now we have some cool new features in mind as wel.. Alpha Blending Particle System Viewport Gizmos and Tools Visual Scripting Cave Engine 2.0 Visual Shader Editing Timelines, a Cutscene Editor Terrain and Vegetation","title":"Roadmap"},{"location":"Docs/roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"Docs/roadmap/#cave-engine-alpha-current","text":"During this iteration the focus is to make Cave Engine as simple, usable, stable, solid and feature complete as possible. In other word, we need to make sure that everyone will be able to jump in and start making their games with the least amount of problems or difficults as possible. Here the focus will be on providing documentation, tutorials, bug fixes, build a community around it and also change and improve the UI and UX as much as we feel like it's necessary to make it as user friendly as possible. Again, from the ground up this engine needs to be friendly, easy to use and of course powerful enough to support your biggest dreams. So if something is missing to make that dream come true, here is the right time to add it!","title":"Cave Engine Alpha (Current)"},{"location":"Docs/roadmap/#cave-engine-10","text":"Here the engine should be already stable enough and with a bunch of cool games made with it. Now it's time to keep cultivating so it can grow more and more! The attention to the usability and bug fixing still keeps the same (and this will never change), but now we have some cool new features in mind as wel.. Alpha Blending Particle System Viewport Gizmos and Tools Visual Scripting","title":"Cave Engine 1.0"},{"location":"Docs/roadmap/#cave-engine-20","text":"Visual Shader Editing Timelines, a Cutscene Editor Terrain and Vegetation","title":"Cave Engine 2.0"},{"location":"Docs/Releases/v097/","text":"Development logs Welcome to the engine's development logs. If you want, also check the itch io page to see the release notes (under the Development log area): Cave Engine on itch io Cave Engine 0.9.7 (alpha) Release Notes! Say hello to the Cave Engine version 0.9.7 (alpha)! It took a while, but it's finally here. I'm very happy about how it turned out and that's thanks to you and the amazing on growth community being built around it. Talking about community, I do have some exciting news: We finally have The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here if you want to: Sweet Shelter on itch io . Of course, this one was made using the previous version (0.9.6), but Renato actually teamed up with two more people (Bruno and Murilo) and they made a second game, using a closed version of 0.9.7 (that I've released earlier to my Patrons ) and I'll probably do a video on it soon. Ralph is also doing some amazing work using the engine: Thank you everyone using the engine and involved somehow, the community is amazing! I'm excited and I really hope y'all like it as I do. So let's jump to the release notes! New Renderer! Let's start with the big features! The entire renderer was rewritten from scratch. Why? Because now it is much more PBR accurate, easy to use and adjust and the best part: more lightweight! But that's not everything... besides all that, there is a bunch of new exciting features on it: ALPHA BLENDING is here! If you've used the engine before, you know that there was zero alpha blend support (only alpha clip). Now you can prepare your .png files, because it is working like a charm! Even with particles... so say hello to your smoke. Added Mist! The good and old mist. I use to say with some friends that mist is that magical button you press to instantly make the game looks better and now you have it in Cave. Awesome! Added an Aperture variable to the camera Soon we'll have HDR, but for now, you can manually adjust the camera aperture to support higher color ranges in your scene. Old Renderer removed! Well, I'm pretty sure that with the new one, no one will gonna mist that, but it's worth mentioning. The last thing I want it to have a bunch of different and non compatible renderers in the engine at the same time (as some other GEs are doing) so I decided to remove the old one. But don't worry: it means that I'll have more time to work in the new renderer and make it even more exciting and feature complete! New Editor's Console I know, I know... the Editor already had a Console before. But now it is 100% of what it was intended to be: Python prints and errors are displayed in the Editor's Console System console is now hidden by default That means no awkward black console window floating around when you're using the engine. Everything you need will be displayed in the editor's console. But if you're really that kind of person who likes random windows floating around your monitors, you can still enable back the console in the top menu. Just keep in mind that it will probably remain empty. Animations Animations are way cooler now. Let's start by the fact that I've fixed THIS (it took me a while, but it's working!). And... Now it's possible to blend two different animations when changing the current one. Animations now have independent frames and always starts from the beginning (cheerz!) Improved the Animation Importer: Previously it was not considering more than 4 bone weights. Well, it still doesn't, but now it sorts the weights in order to get the higher influences and also renormalizes it to avoid glitches. Audio YES! Audio finally received some love. Now there is 3D sound support and you can access the audio instance being executed and do a lot of fun stuff with it: class AddSoundTest(cave.Component): def start(self, scene): # kw arguments = volume=1, fadeIn=0, loop=0 self.sound = cave.playSound(\"testSound\", fadeIn=2.0) self.timer = cave.Timer() def update(self): self.sound.volume = math.sin(self.timer.get()) * 0.5 + 0.5 events = cave.getEvents() if events.pressed(\"W\"): self.sound.pause() elif events.pressed(\"S\"): self.sound.resume() def end(self, scene): pass Including 3D audio. But if you're not into code, you can use the native new Audio Component as well! Entity Templates: Working like a charm! Entity Templates are something very special and important in the game engine. Let's say that you are making a platform game with multiple levels and a lot of enemies spread across the maps. How would you make the same player have an instance on every level? Or even more: How to use the same enemy, without a bunch of duplicates (that makes you project hard to maintain) all across the map? That's why we have entity templates: You can create a new template by right clicking in the asset browser and then assign a selected object (in the 3D view) to it. It will store the entity structure and make it available to you to use anywhere you want to. So it will be just a matter of adding an empty where you want to spawn the template and select it in the entity's Settings menu. Previously it was not working as intended but now it is! Expect ( a lot ) more on it later. Editor Tools Previously I've said that I was planning to improve the Tooling support. And I did it! I've added default Editor Tools and you can make your own if you want to! Let me explain: Now it's possible to paste python scripts inside the Editor/Tools/ folder to automatically register them into the editor. So every time you open the engine, the custom made tools will be there, ready to use. Well, which tools? Various, including the community tools! But someone had to be the first one to write a tool for it, right? Right. So I decided to start this: The world's first official Cave tool is a built in Python API! And why that's good? I'm glad you asked. The tool uses the cave module itself to retrieve the data, so it will be always up to date to your current version. So if you want to check if there is a bleeding edge but yet not documented feature in the api, this is your place! This tool if far from complete yet, but the good news is that it's source open and everyone can go to \"Editor/Tools/\" and edit it. Enjoy! Python API If you want to create some advanced logic for you game, you can use Python scripts for it (visual scripting is coming). So it's very important to provide a smooth and easy experience for you to make everything you want. That's why version 0.9.7 is full of new exciting python features! Let's start with some usability improvements: You often want to access other custom made components inside your code. Previously, there was no garantee that all the python components in your entity where initialized when running the start method, so that could lead to self.entity.get(\"YourComponent\") returning None . Now all the components are initialized first and then the start method is called. So if you have Foo and Bar attached to your entity, you can always access each other: class Foo(cave.Component): def start(self, scene): cmp = self.entity.get(\"Bar\") print(\"Bar = \", cmp) def end(self, scene): pass class Bar(cave.Component): def start(self, scene): cmp = self.entity.get(\"Foo\") print(\"Foo = \", cmp) def end(self, scene): pass But that could be not enough. Sometimes you actually want to wait until certain component initialize properly before accessing it. That's why we now have the optional method firstUpdate() . As the name suggest, it will be called once after all start(s) method run and before the regular update() . class Bar(cave.Component): def start(self, scene): print(\"Start method...\") def firstUpdate(self): print(\"FirstUpdate method...\") def update(self): # Called every frame! print(\"Update method...\") def end(self, scene): print(\"End method...\") To be honest, I can talk FOREVER about the python api improvements. Now you can grab the Mesh Component , get, set or modify its current mesh, material, animation and more! You can select the mesh, copy it to make it unique to a specific object and change as you want to. cmp = self.entity.get(\"Mesh\") # MeshComponent mesh = cmp.getMesh() mesh = mesh.getCopy() cmp.setMesh(mesh) # Do whatever you want with the mesh here! for vertex in mesh.vertices: mesh.position += cave.Vector(0, random.random(), 0) for index in mesh.indices: # For every 3 indices, we have a triangle print(index) mesh.reload() For instance, the code bellow will duplicate the material from the MeshComponent (to make it unique to that specific object) and make it pulse a random glow value, in realtime. Watch the Showcase Video : import cave import random import math class Emissive(cave.Component): def start(self, scene): self.timer = cave.Timer(random.random()*6) cmp = self.entity.get(\"Mesh\") self.mat = cmp.getMaterial() self.mat = self.mat.getCopy() cmp.setMaterial(self.mat) def update(self): c = (math.sin(self.timer.get()) + 1) / 2 self.mat.emission.set(c, c, c) def end(self, scene): pass And there is much more! Transform: lerp, untransform, unrotate Now it's possible to get python made components from python cmp = self.entity.get(\"YourOwnComponent\") . Exposed a transform.[get/set]WorldPosition() method to the Python API Exposed the CharacterComponent fields to the Python API Added a RigidBodyComponent.applyImpulse(...) method Added a MeshComponent.getAnimationLoops() method Added the MeshComponent.getAnimationProgress() method Exposed the DecalComponent to python Mouselook Component This one deserves his own section: Now there is a new default component called \"Mouselook\". It allows you to use the mouse movement to apply some specific rotation to an object. You can use it to, well, do a mouselook, but for a lot more, such as that badass \"item preview\" from Skyrim, that rotates with the mouse. Documentation The engine's documentation is still not 100% up to date (at least not by the time I'm writting this release notes), but I did a lot of improvements on it. By the way, check the previous \"Tooling\" category to see why you should not be worried about the Python API documentation anymore! Anyways, here is some changed I've made: Renamed \"engine\" to \"cave\" New homepage + theme Added Tooling examples Added a Showcase tab New Entity UI + tag UI Now the entity tab (properties) are more organized, divided into sub tabs: Components, Settings and Tags. Tag UI was redesigned as well. New \"Quit Editor\" popup menu The \"quit editor\" window was redesigned to use the engine's UI instead of the OS message dialogues and now displays a \"Cancel\" button. Git control When people started working with Cave for real, they sent me some messages regarding the \"git friendless\". In other words, it was necessary to make the engine work with git so multiple people could work in the same project at the same time. So I've made some changed to allow this: Option to expose the scripts externally, in a Scripts/ folder Exposed the Asset names in the Project Files (previously it was just the unique ID, aka a weird and huge number) I'm planning to do more things related to that, but it was a great start! Usability (UI/UX): Want to see a lot of miscellaneous improvements regarding the engine usability? Here you go! UI Text Renderer rewritten from scratch The previous UI Text was very sketchy and was not working at all in a lot of cases. Now it was completely rewritted and it's working like a charm. Highlight active asset in the Asset Browser Added a debug grid to the viewport Changed the color of the selected text (it was not visible before) Reduced the color of the tab arrow (text editor) Mesh Entity are now added with a rigid body component by default Do not change the window focus while simulating the game! Addressing the report: \"The Shift + Space makes the screen in Full mode. The problem is that when I run+jump with the character controller it keeps scaling up/down\" Removed the Delete and Duplicate icon from the Scene Graph items: The user could easily accidentally click on them. I've added a dropdown menu instead. Those options are still available using the keyboard shortcuts. Added bulk actions for the Animation Asset Increased the Sun bias range in the editor Project Manager improvements Project manager is the first window you see when you open the engine. Keep in mind that there is a bunch of other things I'm planning to make on it. Soon! Show a message when there is no projects Improve the \"new project\" layout Export Game: I did a bunch of things related to the game exporting: Fix: The engine was not copying the the folders inside the \"Lib/\" directory, causing the game to not run as a standalone (exported version). Renamed the executable to the project name (previously it was always \"Game.exe\") Removed the Python STDOUT from the runtime + hide terminal Don't allow the user to export the game without a default scene selected! I've also improved the Settings UI by adding tabs to organize the content on it. Fixes: Something very important happened recently: We started to have actual Games being made using Cave Engine . And because of that, I had to make sure that the engine was stable enough and \"bug free\". So that's why we have so many bug fixes. Good news: it's working very well now! Fix: Crash when trying to display a nullptr image (ui) Fix: Light Gizmo was not world space (when parented) Fix: Camera with 0 scale was resulting in NaN values Fix: Overlapping text when hovering some dropdowns Fix: Editor Icons + use a custom file extension Fix: Camera view not working most of the times: The camera view was a bit sketchy, most of the times, it would simply not work at all and keep using the free camera of the viewport. Specially in the runtime. Now it works just fine. Fix: Deleting an Entity Tag was crashing the engine Fix: Tools getting invalid when you stop the game Fix: glDrawElements access violation (crash) Fix: Problem when displaying multiple ColorSampler UIs in the editor Fix a typo in the PropRange UI element Fix: ColorSampler loading issue Fix: Crash when adding physics to a Folder: Personal Developer note: Yes, someone had to try to add rigid body physics to.. wel... A FOLDER! You guys are amazing finding all sorts of corner cases and I LOVE IT! Cheerz. lol Fix: View Gizmo was being activated when moving a tab around (over it): Two actions at the same time when You're moving tab + You forgot to not move cursor over 3D View Cube at the same time... Thank you Ralph for the report. Fix: Character sliding Fix: It was not possible to set a character's position Fix: Some python components where not showing in the UI Fix: It was not possible to edit two PyComponents at the same time Fix: Making it possible to always have multiple components of the same type in an entity Fix: Dropdown filter was not working Fix: Crash when you run a python script with no start method Fix: I've Hidden the Jump Height because it is not used by bullet at all: There was a character physics option called \"Jump Height\". But after a close inspection in the bullet's source code, I relized that the jump Height was not used at all... lol (that's not my fault). Bullet code - for the Nerds Fix: PythonComponent was not being properly copied when duplicated Fix: Animation issues: This one is huge... remember This Video I made sometime ago? Well... it turns out that it was my fault as well (thanks to quaternions not being normalized). But now it's fixed! No more weird rotation behaviours. Fix: Activating the RigidBody when you set something Fix: Removed the shader error exception throw Fix: Some EntityTemplate crashes Fix: Crash when iterating the childrens Fix: Entity mem leaks and mem violations Fix: Shadows disappearing when the camera is far away from the world's center Fix: It was not possible to add components in realtime (python) Fix: Ensure that the Python Components are all constructed when calling the start Fix: Crash when modifying the entity component list (during iteration) Fix: Unicode characters was not working in the game UI: For the brazilian people out there (and maybe the russians and others): Say hello to special characters in your games! Words like \"A\u00c7\u00c3O!\" and \"PA\u00c7OCA\" will be displayed properly in the game UI. Internal stuff: I've omitted all the fixes and improvements that are internal (only noticeable inside the engine's codebase), but it's worth mentioning that... well, I've removed A BUNCH of unnecessary core, redundant stuff and fixed a lot of things. Huge refactors behind this big set of updates. I really liked the way it turned out.","title":"Cave 0.9.7"},{"location":"Docs/Releases/v097/#development-logs","text":"Welcome to the engine's development logs. If you want, also check the itch io page to see the release notes (under the Development log area): Cave Engine on itch io","title":"Development logs"},{"location":"Docs/Releases/v097/#cave-engine-097-alpha-release-notes","text":"Say hello to the Cave Engine version 0.9.7 (alpha)! It took a while, but it's finally here. I'm very happy about how it turned out and that's thanks to you and the amazing on growth community being built around it. Talking about community, I do have some exciting news: We finally have The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here if you want to: Sweet Shelter on itch io . Of course, this one was made using the previous version (0.9.6), but Renato actually teamed up with two more people (Bruno and Murilo) and they made a second game, using a closed version of 0.9.7 (that I've released earlier to my Patrons ) and I'll probably do a video on it soon. Ralph is also doing some amazing work using the engine: Thank you everyone using the engine and involved somehow, the community is amazing! I'm excited and I really hope y'all like it as I do. So let's jump to the release notes!","title":"Cave Engine 0.9.7 (alpha) Release Notes!"},{"location":"Docs/Releases/v097/#new-renderer","text":"Let's start with the big features! The entire renderer was rewritten from scratch. Why? Because now it is much more PBR accurate, easy to use and adjust and the best part: more lightweight! But that's not everything... besides all that, there is a bunch of new exciting features on it: ALPHA BLENDING is here! If you've used the engine before, you know that there was zero alpha blend support (only alpha clip). Now you can prepare your .png files, because it is working like a charm! Even with particles... so say hello to your smoke. Added Mist! The good and old mist. I use to say with some friends that mist is that magical button you press to instantly make the game looks better and now you have it in Cave. Awesome! Added an Aperture variable to the camera Soon we'll have HDR, but for now, you can manually adjust the camera aperture to support higher color ranges in your scene. Old Renderer removed! Well, I'm pretty sure that with the new one, no one will gonna mist that, but it's worth mentioning. The last thing I want it to have a bunch of different and non compatible renderers in the engine at the same time (as some other GEs are doing) so I decided to remove the old one. But don't worry: it means that I'll have more time to work in the new renderer and make it even more exciting and feature complete!","title":"New Renderer!"},{"location":"Docs/Releases/v097/#new-editors-console","text":"I know, I know... the Editor already had a Console before. But now it is 100% of what it was intended to be: Python prints and errors are displayed in the Editor's Console System console is now hidden by default That means no awkward black console window floating around when you're using the engine. Everything you need will be displayed in the editor's console. But if you're really that kind of person who likes random windows floating around your monitors, you can still enable back the console in the top menu. Just keep in mind that it will probably remain empty.","title":"New Editor's Console"},{"location":"Docs/Releases/v097/#animations","text":"Animations are way cooler now. Let's start by the fact that I've fixed THIS (it took me a while, but it's working!). And... Now it's possible to blend two different animations when changing the current one. Animations now have independent frames and always starts from the beginning (cheerz!) Improved the Animation Importer: Previously it was not considering more than 4 bone weights. Well, it still doesn't, but now it sorts the weights in order to get the higher influences and also renormalizes it to avoid glitches.","title":"Animations"},{"location":"Docs/Releases/v097/#audio","text":"YES! Audio finally received some love. Now there is 3D sound support and you can access the audio instance being executed and do a lot of fun stuff with it: class AddSoundTest(cave.Component): def start(self, scene): # kw arguments = volume=1, fadeIn=0, loop=0 self.sound = cave.playSound(\"testSound\", fadeIn=2.0) self.timer = cave.Timer() def update(self): self.sound.volume = math.sin(self.timer.get()) * 0.5 + 0.5 events = cave.getEvents() if events.pressed(\"W\"): self.sound.pause() elif events.pressed(\"S\"): self.sound.resume() def end(self, scene): pass Including 3D audio. But if you're not into code, you can use the native new Audio Component as well!","title":"Audio"},{"location":"Docs/Releases/v097/#entity-templates-working-like-a-charm","text":"Entity Templates are something very special and important in the game engine. Let's say that you are making a platform game with multiple levels and a lot of enemies spread across the maps. How would you make the same player have an instance on every level? Or even more: How to use the same enemy, without a bunch of duplicates (that makes you project hard to maintain) all across the map? That's why we have entity templates: You can create a new template by right clicking in the asset browser and then assign a selected object (in the 3D view) to it. It will store the entity structure and make it available to you to use anywhere you want to. So it will be just a matter of adding an empty where you want to spawn the template and select it in the entity's Settings menu. Previously it was not working as intended but now it is! Expect ( a lot ) more on it later.","title":"Entity Templates: Working like a charm!"},{"location":"Docs/Releases/v097/#editor-tools","text":"Previously I've said that I was planning to improve the Tooling support. And I did it! I've added default Editor Tools and you can make your own if you want to! Let me explain: Now it's possible to paste python scripts inside the Editor/Tools/ folder to automatically register them into the editor. So every time you open the engine, the custom made tools will be there, ready to use. Well, which tools? Various, including the community tools! But someone had to be the first one to write a tool for it, right? Right. So I decided to start this: The world's first official Cave tool is a built in Python API! And why that's good? I'm glad you asked. The tool uses the cave module itself to retrieve the data, so it will be always up to date to your current version. So if you want to check if there is a bleeding edge but yet not documented feature in the api, this is your place! This tool if far from complete yet, but the good news is that it's source open and everyone can go to \"Editor/Tools/\" and edit it. Enjoy!","title":"Editor Tools"},{"location":"Docs/Releases/v097/#python-api","text":"If you want to create some advanced logic for you game, you can use Python scripts for it (visual scripting is coming). So it's very important to provide a smooth and easy experience for you to make everything you want. That's why version 0.9.7 is full of new exciting python features! Let's start with some usability improvements: You often want to access other custom made components inside your code. Previously, there was no garantee that all the python components in your entity where initialized when running the start method, so that could lead to self.entity.get(\"YourComponent\") returning None . Now all the components are initialized first and then the start method is called. So if you have Foo and Bar attached to your entity, you can always access each other: class Foo(cave.Component): def start(self, scene): cmp = self.entity.get(\"Bar\") print(\"Bar = \", cmp) def end(self, scene): pass class Bar(cave.Component): def start(self, scene): cmp = self.entity.get(\"Foo\") print(\"Foo = \", cmp) def end(self, scene): pass But that could be not enough. Sometimes you actually want to wait until certain component initialize properly before accessing it. That's why we now have the optional method firstUpdate() . As the name suggest, it will be called once after all start(s) method run and before the regular update() . class Bar(cave.Component): def start(self, scene): print(\"Start method...\") def firstUpdate(self): print(\"FirstUpdate method...\") def update(self): # Called every frame! print(\"Update method...\") def end(self, scene): print(\"End method...\") To be honest, I can talk FOREVER about the python api improvements. Now you can grab the Mesh Component , get, set or modify its current mesh, material, animation and more! You can select the mesh, copy it to make it unique to a specific object and change as you want to. cmp = self.entity.get(\"Mesh\") # MeshComponent mesh = cmp.getMesh() mesh = mesh.getCopy() cmp.setMesh(mesh) # Do whatever you want with the mesh here! for vertex in mesh.vertices: mesh.position += cave.Vector(0, random.random(), 0) for index in mesh.indices: # For every 3 indices, we have a triangle print(index) mesh.reload() For instance, the code bellow will duplicate the material from the MeshComponent (to make it unique to that specific object) and make it pulse a random glow value, in realtime. Watch the Showcase Video : import cave import random import math class Emissive(cave.Component): def start(self, scene): self.timer = cave.Timer(random.random()*6) cmp = self.entity.get(\"Mesh\") self.mat = cmp.getMaterial() self.mat = self.mat.getCopy() cmp.setMaterial(self.mat) def update(self): c = (math.sin(self.timer.get()) + 1) / 2 self.mat.emission.set(c, c, c) def end(self, scene): pass And there is much more! Transform: lerp, untransform, unrotate Now it's possible to get python made components from python cmp = self.entity.get(\"YourOwnComponent\") . Exposed a transform.[get/set]WorldPosition() method to the Python API Exposed the CharacterComponent fields to the Python API Added a RigidBodyComponent.applyImpulse(...) method Added a MeshComponent.getAnimationLoops() method Added the MeshComponent.getAnimationProgress() method Exposed the DecalComponent to python","title":"Python API"},{"location":"Docs/Releases/v097/#mouselook-component","text":"This one deserves his own section: Now there is a new default component called \"Mouselook\". It allows you to use the mouse movement to apply some specific rotation to an object. You can use it to, well, do a mouselook, but for a lot more, such as that badass \"item preview\" from Skyrim, that rotates with the mouse.","title":"Mouselook Component"},{"location":"Docs/Releases/v097/#documentation","text":"The engine's documentation is still not 100% up to date (at least not by the time I'm writting this release notes), but I did a lot of improvements on it. By the way, check the previous \"Tooling\" category to see why you should not be worried about the Python API documentation anymore! Anyways, here is some changed I've made: Renamed \"engine\" to \"cave\" New homepage + theme Added Tooling examples Added a Showcase tab","title":"Documentation"},{"location":"Docs/Releases/v097/#new-entity-ui-tag-ui","text":"Now the entity tab (properties) are more organized, divided into sub tabs: Components, Settings and Tags. Tag UI was redesigned as well.","title":"New Entity UI + tag UI"},{"location":"Docs/Releases/v097/#new-quit-editor-popup-menu","text":"The \"quit editor\" window was redesigned to use the engine's UI instead of the OS message dialogues and now displays a \"Cancel\" button.","title":"New \"Quit Editor\" popup menu"},{"location":"Docs/Releases/v097/#git-control","text":"When people started working with Cave for real, they sent me some messages regarding the \"git friendless\". In other words, it was necessary to make the engine work with git so multiple people could work in the same project at the same time. So I've made some changed to allow this: Option to expose the scripts externally, in a Scripts/ folder Exposed the Asset names in the Project Files (previously it was just the unique ID, aka a weird and huge number) I'm planning to do more things related to that, but it was a great start!","title":"Git control"},{"location":"Docs/Releases/v097/#usability-uiux","text":"Want to see a lot of miscellaneous improvements regarding the engine usability? Here you go! UI Text Renderer rewritten from scratch The previous UI Text was very sketchy and was not working at all in a lot of cases. Now it was completely rewritted and it's working like a charm. Highlight active asset in the Asset Browser Added a debug grid to the viewport Changed the color of the selected text (it was not visible before) Reduced the color of the tab arrow (text editor) Mesh Entity are now added with a rigid body component by default Do not change the window focus while simulating the game! Addressing the report: \"The Shift + Space makes the screen in Full mode. The problem is that when I run+jump with the character controller it keeps scaling up/down\" Removed the Delete and Duplicate icon from the Scene Graph items: The user could easily accidentally click on them. I've added a dropdown menu instead. Those options are still available using the keyboard shortcuts. Added bulk actions for the Animation Asset Increased the Sun bias range in the editor","title":"Usability (UI/UX):"},{"location":"Docs/Releases/v097/#project-manager-improvements","text":"Project manager is the first window you see when you open the engine. Keep in mind that there is a bunch of other things I'm planning to make on it. Soon! Show a message when there is no projects Improve the \"new project\" layout","title":"Project Manager improvements"},{"location":"Docs/Releases/v097/#export-game","text":"I did a bunch of things related to the game exporting: Fix: The engine was not copying the the folders inside the \"Lib/\" directory, causing the game to not run as a standalone (exported version). Renamed the executable to the project name (previously it was always \"Game.exe\") Removed the Python STDOUT from the runtime + hide terminal Don't allow the user to export the game without a default scene selected! I've also improved the Settings UI by adding tabs to organize the content on it.","title":"Export Game:"},{"location":"Docs/Releases/v097/#fixes","text":"Something very important happened recently: We started to have actual Games being made using Cave Engine . And because of that, I had to make sure that the engine was stable enough and \"bug free\". So that's why we have so many bug fixes. Good news: it's working very well now! Fix: Crash when trying to display a nullptr image (ui) Fix: Light Gizmo was not world space (when parented) Fix: Camera with 0 scale was resulting in NaN values Fix: Overlapping text when hovering some dropdowns Fix: Editor Icons + use a custom file extension Fix: Camera view not working most of the times: The camera view was a bit sketchy, most of the times, it would simply not work at all and keep using the free camera of the viewport. Specially in the runtime. Now it works just fine. Fix: Deleting an Entity Tag was crashing the engine Fix: Tools getting invalid when you stop the game Fix: glDrawElements access violation (crash) Fix: Problem when displaying multiple ColorSampler UIs in the editor Fix a typo in the PropRange UI element Fix: ColorSampler loading issue Fix: Crash when adding physics to a Folder: Personal Developer note: Yes, someone had to try to add rigid body physics to.. wel... A FOLDER! You guys are amazing finding all sorts of corner cases and I LOVE IT! Cheerz. lol Fix: View Gizmo was being activated when moving a tab around (over it): Two actions at the same time when You're moving tab + You forgot to not move cursor over 3D View Cube at the same time... Thank you Ralph for the report. Fix: Character sliding Fix: It was not possible to set a character's position Fix: Some python components where not showing in the UI Fix: It was not possible to edit two PyComponents at the same time Fix: Making it possible to always have multiple components of the same type in an entity Fix: Dropdown filter was not working Fix: Crash when you run a python script with no start method Fix: I've Hidden the Jump Height because it is not used by bullet at all: There was a character physics option called \"Jump Height\". But after a close inspection in the bullet's source code, I relized that the jump Height was not used at all... lol (that's not my fault). Bullet code - for the Nerds Fix: PythonComponent was not being properly copied when duplicated Fix: Animation issues: This one is huge... remember This Video I made sometime ago? Well... it turns out that it was my fault as well (thanks to quaternions not being normalized). But now it's fixed! No more weird rotation behaviours. Fix: Activating the RigidBody when you set something Fix: Removed the shader error exception throw Fix: Some EntityTemplate crashes Fix: Crash when iterating the childrens Fix: Entity mem leaks and mem violations Fix: Shadows disappearing when the camera is far away from the world's center Fix: It was not possible to add components in realtime (python) Fix: Ensure that the Python Components are all constructed when calling the start Fix: Crash when modifying the entity component list (during iteration) Fix: Unicode characters was not working in the game UI: For the brazilian people out there (and maybe the russians and others): Say hello to special characters in your games! Words like \"A\u00c7\u00c3O!\" and \"PA\u00c7OCA\" will be displayed properly in the game UI.","title":"Fixes:"},{"location":"Docs/Releases/v097/#internal-stuff","text":"I've omitted all the fixes and improvements that are internal (only noticeable inside the engine's codebase), but it's worth mentioning that... well, I've removed A BUNCH of unnecessary core, redundant stuff and fixed a lot of things. Huge refactors behind this big set of updates. I really liked the way it turned out.","title":"Internal stuff:"},{"location":"Docs/Releases/v098/","text":"Important Note: Cave Engine 0.9.8 is not yet released publicly (it's Patreon only at the moment), but it will in the next couple of days. Please check our discord server for updates. Cave Engine 0.9.8 Release Notes! Welcome to the biggest Cave release yet! In order to cheer this big release, let's start the notes by talking about the first official Uniday Studio game made using Cave: . The Looper's Bug is a game made in 72 hours for the Game Jam Ludum Dare 50 where you control Looper, a robot that loses his energy (in a shape of energy orbs) as you walk. When it runs out of energy, it explodes! The good news is that looper does have clones to help you walk throught the levels and their clones will recover energy from your past lost orbs. It's a puzzle game available for you to Play on Itch io . After this game, Cave Engine finally got past a stage that I'd like to call \"The battlefield test\" . In other words, it was used in production to an actual released game (that's not just a test project without a start and an end), testes \"in battle\" with lots of people playing it everywhere. So there is no doubts that the engine is now perfectly capable (and stable enough) to make a full game using it. It's also worth mentioning that this was not the first complete game made using cave. Back in the 0.9.6 release, @renatoaruffo made the game Sweet Shelter . A Personal note from the Dev Hi, it's Guilherme and thank you a lot for being here. It's been almost an year since the last engine's release (aug 17, 2021) and in the meanwhile, a lot of things happened! I got a Senior job in the Game Industry, as a Game Engine Dev, working with huge in house game engines (way bigger than Cave or anything I've worked before) and porting giant commercial games to consoles (such as Xbox One). I got hundreds of new students into my paid courses, made some new games and last, but not least, worked A TON in Cave! It was a great time. I had an opportunity to meet many cool devs across the world and learn a lot in such a small period of time. Having this senior game engine dev role in the industry really made a lot of difference as well. During this past year I've also realized how I love to make game and tools (such as engines) and help people to get started in game development. I'm very excited about this new release. As you saw, it's the first time ever I've used the engine to make a complete and released game. As a result, the engine received a lot of polish and fixed, which is awesome! To be honest, it would be a new dream becoming reality if I was able to work full time on Cave Engine some day. And with your help, that could be possible! The engine is currently free and it is my Gift for you to help you making your amazing games! But if you want to give something back by supporting Cave and future projects, I've setup a Patreon for you to help me get going with the project. I've setup 3 tier levels: starting at $3, you can be a general supporter. At $10, you'll have early access to future releases of Cave Engine and Dynami Engine, when they come out. Meaning that you'll not have to wait much to start using all the new features. Last, but not least, at $20 you'll get access to Cave PRO when it comes out (that's basically Cave, but with steroids). So don't forget to check the page and see if it is for you. In any case, thank you a lot for the support and for the presence here. You're awesome! Now that's enough introduction. Let's jump to all the release notes! New Project Manager UI Remember that ugly Project Manager that the engine used to have? Well, I don't, because here is how it looks like now: The new Project Manager now have Project thumbnails that you can mouse over to see details (such as last write date, engine version and project location), right click (to duplicate, reveal in explorer, open or simply delete the project) and, of course, open it. I've also added an \"About\" tab with a bunch of useful debug hints and informations. The Project Manager now have a splash screen! The goal is to feature some amazing games made using Cave. Meaning that your game can also be highlighted over there, for the entire world to see! New way to Edit Entity Templates! Entity Template is something very important for game development using Cave: it is the official way for you to create a \"base object\" that can be used all across your game. For example, if you'd like to create a player, enemies and collectable items that can be used several times across different levels, you'll do them by creating entity templates. Creating a Template is simple: Just right click in the Asset Browser, new asset, entity template. And now things gets interesting: you can now double click an EntityTemplate in the Asset Browser and it will open a special scene for you to edit it as you want. Changes gets applied to all entities using that template as soon as you leave its editing scene. Some other smaller updates within this commit: Added a thumbnail for the Templates Thumbnails can now have a colored footer (like UE) to help recognize the asset type. For now, Templates are green, scenes are Blue and meshes are grey. Added a green moldure in the Entity Template's Editor viewport Note: You can't start the game while editing a template. Rendering Features: The Cave Engine rendered received a lot of love in this version as well. Here is the main highlights: Exposed the Alpha threshold variable for opaque materials. Reduced the default texture format size to increase performance Added a post processing pass : It does not do much at the moment, but it will be essential in future releases to allow you to easily tweak the visuals of your game. Setting the proper OpenGL Context + forcing the offboard GPU to be used: Previously, for some unknown reason, the engine was not using the offboard GPU in some computers, meaning that, in some cases (just as an example) if you had an intel CPU and an RTX 3090 installed, it will attempt to use Intel Graphics instead. Now fixed. Improved the Shadow Bias and Peter Panning: Cascade shadow mapping is still planned for future releases. But for now, at least the shadows are way better then before! Fixed the previously Sketchy font rendering (in game)...(now it works) Mesh Component Tint Now every mesh component have a \"Tint\" variable that allows you to tint the material color as you want. The default color is white but you can use it to do a lot of cool stuff, such as a red color animation when a character takes damage, for example. It also allows the particle system to have a custom tint over life. Particle System Added an \"Use Parenting\" option: If enabled, the particles will move with the Entity. Improved the Particle Component's UI Particle life tint (as a curve!) Logic and Python API Writting your game logic using Cave ws never so easy and versatile as it is right now! Check all the new features and improvements made to this: Added a python properties dict to the Scenes: You can now store anything you want at a scene level by using the scene.properties python dictionary. Entity now have a \"properties\" field (python dict) as well (just like the scenes) CharacterComponent can now dettect collision You can use the methods getCollisions and collidedWith in order to get collisions from the CharacterComponent. Entity's children options added to the API Now you can find the following classmethods in the Entity: entity.add(...) entity.get(...) # Returns a given component entity.getScene(...) entity.getAll(...) # Returns a list of all components entity.getParent(...) entity.getChild(...) entity.getChildren(...) entity.getChildrenRecursive(...) entity.getTransform(...) Added an \"isAlive()\" method to the Entities After you attempt to kill an entity ( entity.kill() ), while it is still there, the method isAlive() will no longer return true. Remember that when calling kill() , the action will only be performed by the engine by the end of the frame. That's why the isAlive() is useful. Added some Smooth PlayerComponent Movement options Now you can Schedule to Kill an Entity . Awesome! If you want to add an entity to the scene (or any given entity) and kill them after some time, you can do it so by typing: entity.scheduleKill(5) # The entity will be killed within 5 seconds. Improved the Scene::AddFromTemplate(...) API When creating a new entity from a template ( scene.addFromTemplate(\"TemplateName\") ), you can now pass three optional parameters: position , rotation and scale . New Transform's LookAtSmooth method + fixed the LookAt UIElement: quadAlpha added to the Python API Character::IsFalling + more Python APIs The Character Component received even more love with all those new methods: isMoving() , isFalling() and onGround() . The Mesh Component also received: getArmature() and getAnimation() . Cave.ui backends refactored Previously it was caveui and now it's cave.ui . Meaning that: # This: import caveui as ui # Is now this: import cave.ui as ui The math functions also received an upgrade, with its own cave submodule as well: cave.math . Added mouselook limits to the Mouselook Component Added some new math utility functions Some math functions are really useful when creating games. Such as: # Lerp a to b, it works with floats, vectors and quaternions: out = cave.math.lerp(a, b, value) # We also now have an slerp variant, for quaternions only: out = cave.math.slerp(a, b, value) # Clamping floats: out = cave.math.clamp(x, 1.0, 3.0) # Mapping ranges, from [0,1] to [35,60], in this example: out = cave.math.mapRange(value, 0.0, 1.0, 35.0, 60.0) # It's worth mentioning that it also works if the range is backwards, such as: out = cave.math.mapRange(value, 0.0, 1.0, 60.0, 35.0) The New Python Code Component Some times you want to write some Python code, but it's not as important or big to justify creating an entire new Python Component... Well, now that's no longer a concern: you can simply create a Python Code Component an inline all that code directly into the component's UI. It's a very handy feature to make small python procedures. UI/UX: I'll not gonna lie: the engine is looking good now. Check this screenshot: And that also reflects to the usability! I've made a lot of quality of life improvements on it: Better Search bars to the engine! Now the search bars are no longer case sensitive (so if you're looking for an asset called \"TestingAsset\" and type \"test\", it will appear in the results). Lots of smaller tweaks were made as well. Improved the Asset Browser Thumbnails Increased the Editor's font resolution New Asset Picking (by clicking in the Viewport) Now it uses a pixel perfect approach, so it's no longer annoying to point and click to select an asset. Selected entity highlight in the Viewport: Now it's also easier to see the selected entities, since they'll be highlighted. Drag and Drop to Viewport: EntityTemplates, Textures and Materials are now possible! If you drop a template, it will automatically build it into the world for you. For the materials, you can drop it to a mesh to instantly apply. Last but not least, if you drop a texture directly to a mesh, it will automatically create a material for you (and apply to that mesh). Awesome! Material UI Refactored New \"Curve\" editor property type Asset Browser: added an \"Empty Folder\" text when, well, there is nothing in the folder (lol) Refactored the New Entity's names and settings If you drop a template to the viewport, the entity created will have the template name. I've also fixed the new \"Rigid Body Mesh\" option that was not making any sense... Entity's tree nodes are now open by default (in the scene graph) Better Scene thumbnail generator Previously the scene's thumbnails in the editor were mostly all the time blank or wrong. Now fixed. Editor: Allow TAB Key on multiline UI text Improved the Entity's UI a bit more Asset Importer UI: Option to batch [de]select assets to import Changed the drag and drop message to a more informative one. MeshComponent: Option to build a RigidBody based on the mesh used Previously it was annoying to create a blank rigid body and then selecting the same mesh as the one in the mesh component from a dropdown. Now there is a ... icon in the MeshComponent that allows you to automatically build the rigid body from it. Changed some RenderGraph UI icons Scene Graph: new Entity Right Click Menu! Now you have a lot of useful options when right clicking an entity in the Scene Graph. Awesome! Main Menu Bar improved + Play/Stop Button Removed that ugly \"Add\" Button (bottom right of entity's UI) There was a button in the entity menu and project browser that was supposed to serve as a way to add new components/projects. But it never worked as good as expected so I've removed it. The Editor's thumbnail system received a complete rewrite as well to allow all those cool new features. Viewport UI and Editing Enhancements Hold CTRL to toggle snapping Hold ALT before moving an Entity to duplicate it Controls gets disabled when you play the game. You can toggle them on/off using F3 (during the play mode) Shortcut: Alt+W/E/R to reset pos, rot, scl Now it Displays the current Scene's name in the Viewport (bottom left) Improved the CameraCmp Gizmo (Viewport) Now it also indicated the \"up\" direction of the camera view, making it easier to not place the cameras upside down. General Features: Animation: There is not a lot \"visible\" in terms of new features, but the Animation (skeletal) system received a lot of internal work, including fixes and improvements. I'm making it versatile enough to support multiple types of custom animations in the future, such as blend spaces and automatic character controllers. Physics: Rigid Bodies can how be in \"Ghost mode\" More Draw Debug Physics Backends Exported Game (Standalone): Option to use the Desktop Resolution on Standalone Created the Stats For Nerds Tab! Now the engine saves the time you spent on your projects + some other cool information about it. It's so cool! :) Added a Loading Screen: Now both the editor and the standalone game does have a pulsing loading screen before it starts up, while all the game resources are being loaded. It also means that the window will not appear as \"not responding\". Fixes: Fix: Python Script being edited was being closed when you quit game Fix: Broken Material Editor UI Fix: Text Editor Zoom was not working Fix: RigidBodyComponent was crashing with no shape Fix: Project Sorting by date in the Project Manager was wrong Fix: Crash when closing the Editor/Game Fix: Crash when creating an empty mesh + disabled grid in thumbnail Fix: First rendered mesh outline (when selected) was wrong Fix: Alpha not working after drawing texts in the UI Fix: Particle was not working when selecting the Entity Fix: Crash when creating a new project Fix: Ghost point lamp This one was almost a classic bug in Cave by now. If you notice, until v0.9.7, there was always a ghost point lamp casting light into the world. Now gone (sorry, ghost!). Fix: Inactive PlayerComponent was not resetting the walk Fix: Viewport was not drawing gizmos Fix: Crash when Killing the same Entity multiple times Fix: Crash Closing the engine with no Scene Opened Fix: UIButton was working while disabled (that was not supposed to happen) Fix: disabled Button wrongly receiving input Fix: Transform::lookAt method was doing some weird stuff in some corner cases Fix: UIElement layer was not being copied Fix: GetCollisions(obj) was returning ALL collisions No way I let that pass for so many time... but, well, now it's fixed. :) Fix: It was possible to select invisible UI elements Fix: Particle reload was incorrect in the Editor Fix: Py setAnimation was not working Fix: Sketchy font rendering... Fix: AudioTrackInst was not stopping on stop() Fix: FaceCulling not working in standalone I'll tell you a small story on how I figure out this bug... As you may know, I've made a game in 72 hours using cave for the Ludum Dare 50 . In the final hour before submitting the game, I exported it as runtime and tested... And I was only able to see a black screen. I freaked out thinking that I messed up the engine really bad during the jam (I've changed a lot or things during it). It ended up being an one line fix. :P Fix: Wrong RenderToTexture Aspect Fix: Scene Thumbnails was sometimes Empty Fix: deleting some assets was not working 100% It was removing the asset from the Asset Browser, but not deleting it from the project itself. That bug was happening with inherinted assets (such as ImageTexture, that inherits from Texture). Now fixed. Fix: Misaligned UI Icons (all of them) Fix Proj Manager thumbnail sizes Fix: Dropping stuff in the viewport was not working Fix: Possible template duplication issue Fix: Crash when loading a Project Still Work in Progress I was also working in some exciting new features that unfortunately didn't make to the 0.9.8 release. Initial Network layer (not available yet) In the future, Cave will have native methods to make online games. Logic Bricks: Visual Scripting (not available yet) It already allows me to create new nodes, logic bricks, attach them to a component, run and so on. Serialization is also 100% working as well. What's left is to write the front end (the node UIs) so the use will be able to create their own logic bricks trees as they want to. I'm almost there! :) Animation System (not available yet) As I said, I'm working on a versatile animation system for the engine to make your life way easier. I'm still not sure how it will be released, since I'm also working on Cave Engine PRO (paid, for the ones who want to support the engine and also use some extra features). Here is the plan so far: Animation inherits (from IAnimation): The animation types can use the Entity's properties to gather the necessary variables Character animation: With slots for: idle walk run jump (up, idle, landing) die (dying, dead idle) 4-directional animation (plus idle in the middle) 8-directional anumation (plus idle in the middle) Animation Blender (to blend anims): Allows you to have a base IAnimation and multiple layers on top. For each layer: An IAnimation + blend weight A list will all the bones to select/unselect the ones you want to influence The way I'm writting this system will also allow you to nest animations. For example, you can use a Character Animation for your player, but instead of a simple walk animation, you can use a 4 or 8-directional animation.","title":"Cave 0.9.8 (latest)"},{"location":"Docs/Releases/v098/#cave-engine-098-release-notes","text":"Welcome to the biggest Cave release yet! In order to cheer this big release, let's start the notes by talking about the first official Uniday Studio game made using Cave: . The Looper's Bug is a game made in 72 hours for the Game Jam Ludum Dare 50 where you control Looper, a robot that loses his energy (in a shape of energy orbs) as you walk. When it runs out of energy, it explodes! The good news is that looper does have clones to help you walk throught the levels and their clones will recover energy from your past lost orbs. It's a puzzle game available for you to Play on Itch io . After this game, Cave Engine finally got past a stage that I'd like to call \"The battlefield test\" . In other words, it was used in production to an actual released game (that's not just a test project without a start and an end), testes \"in battle\" with lots of people playing it everywhere. So there is no doubts that the engine is now perfectly capable (and stable enough) to make a full game using it. It's also worth mentioning that this was not the first complete game made using cave. Back in the 0.9.6 release, @renatoaruffo made the game Sweet Shelter .","title":"Cave Engine 0.9.8 Release Notes!"},{"location":"Docs/Releases/v098/#a-personal-note-from-the-dev","text":"Hi, it's Guilherme and thank you a lot for being here. It's been almost an year since the last engine's release (aug 17, 2021) and in the meanwhile, a lot of things happened! I got a Senior job in the Game Industry, as a Game Engine Dev, working with huge in house game engines (way bigger than Cave or anything I've worked before) and porting giant commercial games to consoles (such as Xbox One). I got hundreds of new students into my paid courses, made some new games and last, but not least, worked A TON in Cave! It was a great time. I had an opportunity to meet many cool devs across the world and learn a lot in such a small period of time. Having this senior game engine dev role in the industry really made a lot of difference as well. During this past year I've also realized how I love to make game and tools (such as engines) and help people to get started in game development. I'm very excited about this new release. As you saw, it's the first time ever I've used the engine to make a complete and released game. As a result, the engine received a lot of polish and fixed, which is awesome! To be honest, it would be a new dream becoming reality if I was able to work full time on Cave Engine some day. And with your help, that could be possible! The engine is currently free and it is my Gift for you to help you making your amazing games! But if you want to give something back by supporting Cave and future projects, I've setup a Patreon for you to help me get going with the project. I've setup 3 tier levels: starting at $3, you can be a general supporter. At $10, you'll have early access to future releases of Cave Engine and Dynami Engine, when they come out. Meaning that you'll not have to wait much to start using all the new features. Last, but not least, at $20 you'll get access to Cave PRO when it comes out (that's basically Cave, but with steroids). So don't forget to check the page and see if it is for you. In any case, thank you a lot for the support and for the presence here. You're awesome! Now that's enough introduction. Let's jump to all the release notes!","title":"A Personal note from the Dev"},{"location":"Docs/Releases/v098/#new-project-manager-ui","text":"Remember that ugly Project Manager that the engine used to have? Well, I don't, because here is how it looks like now: The new Project Manager now have Project thumbnails that you can mouse over to see details (such as last write date, engine version and project location), right click (to duplicate, reveal in explorer, open or simply delete the project) and, of course, open it. I've also added an \"About\" tab with a bunch of useful debug hints and informations. The Project Manager now have a splash screen! The goal is to feature some amazing games made using Cave. Meaning that your game can also be highlighted over there, for the entire world to see!","title":"New Project Manager UI"},{"location":"Docs/Releases/v098/#new-way-to-edit-entity-templates","text":"Entity Template is something very important for game development using Cave: it is the official way for you to create a \"base object\" that can be used all across your game. For example, if you'd like to create a player, enemies and collectable items that can be used several times across different levels, you'll do them by creating entity templates. Creating a Template is simple: Just right click in the Asset Browser, new asset, entity template. And now things gets interesting: you can now double click an EntityTemplate in the Asset Browser and it will open a special scene for you to edit it as you want. Changes gets applied to all entities using that template as soon as you leave its editing scene. Some other smaller updates within this commit: Added a thumbnail for the Templates Thumbnails can now have a colored footer (like UE) to help recognize the asset type. For now, Templates are green, scenes are Blue and meshes are grey. Added a green moldure in the Entity Template's Editor viewport Note: You can't start the game while editing a template.","title":"New way to Edit Entity Templates!"},{"location":"Docs/Releases/v098/#rendering-features","text":"The Cave Engine rendered received a lot of love in this version as well. Here is the main highlights: Exposed the Alpha threshold variable for opaque materials. Reduced the default texture format size to increase performance Added a post processing pass : It does not do much at the moment, but it will be essential in future releases to allow you to easily tweak the visuals of your game. Setting the proper OpenGL Context + forcing the offboard GPU to be used: Previously, for some unknown reason, the engine was not using the offboard GPU in some computers, meaning that, in some cases (just as an example) if you had an intel CPU and an RTX 3090 installed, it will attempt to use Intel Graphics instead. Now fixed. Improved the Shadow Bias and Peter Panning: Cascade shadow mapping is still planned for future releases. But for now, at least the shadows are way better then before! Fixed the previously Sketchy font rendering (in game)...(now it works)","title":"Rendering Features:"},{"location":"Docs/Releases/v098/#mesh-component-tint","text":"Now every mesh component have a \"Tint\" variable that allows you to tint the material color as you want. The default color is white but you can use it to do a lot of cool stuff, such as a red color animation when a character takes damage, for example. It also allows the particle system to have a custom tint over life.","title":"Mesh Component Tint"},{"location":"Docs/Releases/v098/#particle-system","text":"Added an \"Use Parenting\" option: If enabled, the particles will move with the Entity. Improved the Particle Component's UI Particle life tint (as a curve!)","title":"Particle System"},{"location":"Docs/Releases/v098/#logic-and-python-api","text":"Writting your game logic using Cave ws never so easy and versatile as it is right now! Check all the new features and improvements made to this: Added a python properties dict to the Scenes: You can now store anything you want at a scene level by using the scene.properties python dictionary. Entity now have a \"properties\" field (python dict) as well (just like the scenes) CharacterComponent can now dettect collision You can use the methods getCollisions and collidedWith in order to get collisions from the CharacterComponent. Entity's children options added to the API Now you can find the following classmethods in the Entity: entity.add(...) entity.get(...) # Returns a given component entity.getScene(...) entity.getAll(...) # Returns a list of all components entity.getParent(...) entity.getChild(...) entity.getChildren(...) entity.getChildrenRecursive(...) entity.getTransform(...) Added an \"isAlive()\" method to the Entities After you attempt to kill an entity ( entity.kill() ), while it is still there, the method isAlive() will no longer return true. Remember that when calling kill() , the action will only be performed by the engine by the end of the frame. That's why the isAlive() is useful. Added some Smooth PlayerComponent Movement options Now you can Schedule to Kill an Entity . Awesome! If you want to add an entity to the scene (or any given entity) and kill them after some time, you can do it so by typing: entity.scheduleKill(5) # The entity will be killed within 5 seconds. Improved the Scene::AddFromTemplate(...) API When creating a new entity from a template ( scene.addFromTemplate(\"TemplateName\") ), you can now pass three optional parameters: position , rotation and scale . New Transform's LookAtSmooth method + fixed the LookAt UIElement: quadAlpha added to the Python API Character::IsFalling + more Python APIs The Character Component received even more love with all those new methods: isMoving() , isFalling() and onGround() . The Mesh Component also received: getArmature() and getAnimation() . Cave.ui backends refactored Previously it was caveui and now it's cave.ui . Meaning that: # This: import caveui as ui # Is now this: import cave.ui as ui The math functions also received an upgrade, with its own cave submodule as well: cave.math . Added mouselook limits to the Mouselook Component Added some new math utility functions Some math functions are really useful when creating games. Such as: # Lerp a to b, it works with floats, vectors and quaternions: out = cave.math.lerp(a, b, value) # We also now have an slerp variant, for quaternions only: out = cave.math.slerp(a, b, value) # Clamping floats: out = cave.math.clamp(x, 1.0, 3.0) # Mapping ranges, from [0,1] to [35,60], in this example: out = cave.math.mapRange(value, 0.0, 1.0, 35.0, 60.0) # It's worth mentioning that it also works if the range is backwards, such as: out = cave.math.mapRange(value, 0.0, 1.0, 60.0, 35.0)","title":"Logic and Python API"},{"location":"Docs/Releases/v098/#the-new-python-code-component","text":"Some times you want to write some Python code, but it's not as important or big to justify creating an entire new Python Component... Well, now that's no longer a concern: you can simply create a Python Code Component an inline all that code directly into the component's UI. It's a very handy feature to make small python procedures.","title":"The New Python Code Component"},{"location":"Docs/Releases/v098/#uiux","text":"I'll not gonna lie: the engine is looking good now. Check this screenshot: And that also reflects to the usability! I've made a lot of quality of life improvements on it: Better Search bars to the engine! Now the search bars are no longer case sensitive (so if you're looking for an asset called \"TestingAsset\" and type \"test\", it will appear in the results). Lots of smaller tweaks were made as well. Improved the Asset Browser Thumbnails Increased the Editor's font resolution New Asset Picking (by clicking in the Viewport) Now it uses a pixel perfect approach, so it's no longer annoying to point and click to select an asset. Selected entity highlight in the Viewport: Now it's also easier to see the selected entities, since they'll be highlighted. Drag and Drop to Viewport: EntityTemplates, Textures and Materials are now possible! If you drop a template, it will automatically build it into the world for you. For the materials, you can drop it to a mesh to instantly apply. Last but not least, if you drop a texture directly to a mesh, it will automatically create a material for you (and apply to that mesh). Awesome! Material UI Refactored New \"Curve\" editor property type Asset Browser: added an \"Empty Folder\" text when, well, there is nothing in the folder (lol) Refactored the New Entity's names and settings If you drop a template to the viewport, the entity created will have the template name. I've also fixed the new \"Rigid Body Mesh\" option that was not making any sense... Entity's tree nodes are now open by default (in the scene graph) Better Scene thumbnail generator Previously the scene's thumbnails in the editor were mostly all the time blank or wrong. Now fixed. Editor: Allow TAB Key on multiline UI text Improved the Entity's UI a bit more Asset Importer UI: Option to batch [de]select assets to import Changed the drag and drop message to a more informative one. MeshComponent: Option to build a RigidBody based on the mesh used Previously it was annoying to create a blank rigid body and then selecting the same mesh as the one in the mesh component from a dropdown. Now there is a ... icon in the MeshComponent that allows you to automatically build the rigid body from it. Changed some RenderGraph UI icons Scene Graph: new Entity Right Click Menu! Now you have a lot of useful options when right clicking an entity in the Scene Graph. Awesome! Main Menu Bar improved + Play/Stop Button Removed that ugly \"Add\" Button (bottom right of entity's UI) There was a button in the entity menu and project browser that was supposed to serve as a way to add new components/projects. But it never worked as good as expected so I've removed it. The Editor's thumbnail system received a complete rewrite as well to allow all those cool new features.","title":"UI/UX:"},{"location":"Docs/Releases/v098/#viewport-ui-and-editing-enhancements","text":"Hold CTRL to toggle snapping Hold ALT before moving an Entity to duplicate it Controls gets disabled when you play the game. You can toggle them on/off using F3 (during the play mode) Shortcut: Alt+W/E/R to reset pos, rot, scl Now it Displays the current Scene's name in the Viewport (bottom left) Improved the CameraCmp Gizmo (Viewport) Now it also indicated the \"up\" direction of the camera view, making it easier to not place the cameras upside down.","title":"Viewport UI and Editing Enhancements"},{"location":"Docs/Releases/v098/#general-features","text":"","title":"General Features:"},{"location":"Docs/Releases/v098/#animation","text":"There is not a lot \"visible\" in terms of new features, but the Animation (skeletal) system received a lot of internal work, including fixes and improvements. I'm making it versatile enough to support multiple types of custom animations in the future, such as blend spaces and automatic character controllers.","title":"Animation:"},{"location":"Docs/Releases/v098/#physics","text":"Rigid Bodies can how be in \"Ghost mode\" More Draw Debug Physics Backends","title":"Physics:"},{"location":"Docs/Releases/v098/#exported-game-standalone","text":"Option to use the Desktop Resolution on Standalone","title":"Exported Game (Standalone):"},{"location":"Docs/Releases/v098/#created-the-stats-for-nerds-tab","text":"Now the engine saves the time you spent on your projects + some other cool information about it. It's so cool! :)","title":"Created the Stats For Nerds Tab!"},{"location":"Docs/Releases/v098/#added-a-loading-screen","text":"Now both the editor and the standalone game does have a pulsing loading screen before it starts up, while all the game resources are being loaded. It also means that the window will not appear as \"not responding\".","title":"Added a Loading Screen:"},{"location":"Docs/Releases/v098/#fixes","text":"Fix: Python Script being edited was being closed when you quit game Fix: Broken Material Editor UI Fix: Text Editor Zoom was not working Fix: RigidBodyComponent was crashing with no shape Fix: Project Sorting by date in the Project Manager was wrong Fix: Crash when closing the Editor/Game Fix: Crash when creating an empty mesh + disabled grid in thumbnail Fix: First rendered mesh outline (when selected) was wrong Fix: Alpha not working after drawing texts in the UI Fix: Particle was not working when selecting the Entity Fix: Crash when creating a new project Fix: Ghost point lamp This one was almost a classic bug in Cave by now. If you notice, until v0.9.7, there was always a ghost point lamp casting light into the world. Now gone (sorry, ghost!). Fix: Inactive PlayerComponent was not resetting the walk Fix: Viewport was not drawing gizmos Fix: Crash when Killing the same Entity multiple times Fix: Crash Closing the engine with no Scene Opened Fix: UIButton was working while disabled (that was not supposed to happen) Fix: disabled Button wrongly receiving input Fix: Transform::lookAt method was doing some weird stuff in some corner cases Fix: UIElement layer was not being copied Fix: GetCollisions(obj) was returning ALL collisions No way I let that pass for so many time... but, well, now it's fixed. :) Fix: It was possible to select invisible UI elements Fix: Particle reload was incorrect in the Editor Fix: Py setAnimation was not working Fix: Sketchy font rendering... Fix: AudioTrackInst was not stopping on stop() Fix: FaceCulling not working in standalone I'll tell you a small story on how I figure out this bug... As you may know, I've made a game in 72 hours using cave for the Ludum Dare 50 . In the final hour before submitting the game, I exported it as runtime and tested... And I was only able to see a black screen. I freaked out thinking that I messed up the engine really bad during the jam (I've changed a lot or things during it). It ended up being an one line fix. :P Fix: Wrong RenderToTexture Aspect Fix: Scene Thumbnails was sometimes Empty Fix: deleting some assets was not working 100% It was removing the asset from the Asset Browser, but not deleting it from the project itself. That bug was happening with inherinted assets (such as ImageTexture, that inherits from Texture). Now fixed. Fix: Misaligned UI Icons (all of them) Fix Proj Manager thumbnail sizes Fix: Dropping stuff in the viewport was not working Fix: Possible template duplication issue Fix: Crash when loading a Project","title":"Fixes:"},{"location":"Docs/Releases/v098/#still-work-in-progress","text":"I was also working in some exciting new features that unfortunately didn't make to the 0.9.8 release.","title":"Still Work in Progress"},{"location":"Docs/Releases/v098/#initial-network-layer-not-available-yet","text":"In the future, Cave will have native methods to make online games.","title":"Initial Network layer (not available yet)"},{"location":"Docs/Releases/v098/#logic-bricks-visual-scripting-not-available-yet","text":"It already allows me to create new nodes, logic bricks, attach them to a component, run and so on. Serialization is also 100% working as well. What's left is to write the front end (the node UIs) so the use will be able to create their own logic bricks trees as they want to. I'm almost there! :)","title":"Logic Bricks: Visual Scripting (not available yet)"},{"location":"Docs/Releases/v098/#animation-system-not-available-yet","text":"As I said, I'm working on a versatile animation system for the engine to make your life way easier. I'm still not sure how it will be released, since I'm also working on Cave Engine PRO (paid, for the ones who want to support the engine and also use some extra features). Here is the plan so far: Animation inherits (from IAnimation): The animation types can use the Entity's properties to gather the necessary variables Character animation: With slots for: idle walk run jump (up, idle, landing) die (dying, dead idle) 4-directional animation (plus idle in the middle) 8-directional anumation (plus idle in the middle) Animation Blender (to blend anims): Allows you to have a base IAnimation and multiple layers on top. For each layer: An IAnimation + blend weight A list will all the bones to select/unselect the ones you want to influence The way I'm writting this system will also allow you to nest animations. For example, you can use a Character Animation for your player, but instead of a simple walk animation, you can use a 4 or 8-directional animation.","title":"Animation System (not available yet)"},{"location":"Examples/python/","text":"Python Examples Ray Cast # Just getting the entity, transform and scene entity = self.getEntity() transform = entity.getTransform() scene = entity.getScene() # Ray Cast needs two parameters: origin and target. # It's basically where the ray starts and where it ends. # For this example, let's make the ray start at the player # position and go to its forward direction by 10 meters origin = transform.getPosition() target = origin + transform.getForwardVector() * 10 # The actual ray cast. Will return an cave.RayCastOut instance # that contains 4 variables: hit (bool), position (Vector3), # normal (Vector3), entity (cave.Entity or None) rOut = scene.rayCast(origin, target) if rOut.hit: hitEntity = rOut.entity print(\"Raycast hit with = \", hitEntity.name) point = rOut.position print(\"At this point = \", point.x, point.y, point.z) normal = rOut.normal print(\"Facing this Direction = \", normal.x, normal.y, normal.z) Mouselook Add this script to a Camera. It's recommended that you parent the camera to an object to represent the player. import cave class Mouselook(cave.Component): def __init__(self): self.mLastPos = None self.sensibility = 0.005 def start(self, scene): pass def mouselook(self): mPos = cave.getMousePosition(False) center = cave.getWindowSize() * 0.5 center = cave.Vector2(int(center.x), int(center.y)) if self.mLastPos: disp = center - mPos disp *= self.sensibility transform = self.entity.getTransform() transform.rotateOnPitch(disp.y) parent = self.entity.getParent() if parent: parentTransform = parent.getTransform() parentTransform.rotateOnRoll(disp.x) else: transform.rotateOnRoll(disp.x) cave.setMousePosition(int(center.x), int(center.y)) self.mLastPos = cave.Vector2(mPos.x, mPos.y) def update(self): events = cave.getEvents() if events.pressed(\"ESCAPE\"): cave.quitGame() self.mouselook() def end(self, scene): pass","title":"Python Scripting"},{"location":"Examples/python/#python-examples","text":"","title":"Python Examples"},{"location":"Examples/python/#ray-cast","text":"# Just getting the entity, transform and scene entity = self.getEntity() transform = entity.getTransform() scene = entity.getScene() # Ray Cast needs two parameters: origin and target. # It's basically where the ray starts and where it ends. # For this example, let's make the ray start at the player # position and go to its forward direction by 10 meters origin = transform.getPosition() target = origin + transform.getForwardVector() * 10 # The actual ray cast. Will return an cave.RayCastOut instance # that contains 4 variables: hit (bool), position (Vector3), # normal (Vector3), entity (cave.Entity or None) rOut = scene.rayCast(origin, target) if rOut.hit: hitEntity = rOut.entity print(\"Raycast hit with = \", hitEntity.name) point = rOut.position print(\"At this point = \", point.x, point.y, point.z) normal = rOut.normal print(\"Facing this Direction = \", normal.x, normal.y, normal.z)","title":"Ray Cast"},{"location":"Examples/python/#mouselook","text":"Add this script to a Camera. It's recommended that you parent the camera to an object to represent the player. import cave class Mouselook(cave.Component): def __init__(self): self.mLastPos = None self.sensibility = 0.005 def start(self, scene): pass def mouselook(self): mPos = cave.getMousePosition(False) center = cave.getWindowSize() * 0.5 center = cave.Vector2(int(center.x), int(center.y)) if self.mLastPos: disp = center - mPos disp *= self.sensibility transform = self.entity.getTransform() transform.rotateOnPitch(disp.y) parent = self.entity.getParent() if parent: parentTransform = parent.getTransform() parentTransform.rotateOnRoll(disp.x) else: transform.rotateOnRoll(disp.x) cave.setMousePosition(int(center.x), int(center.y)) self.mLastPos = cave.Vector2(mPos.x, mPos.y) def update(self): events = cave.getEvents() if events.pressed(\"ESCAPE\"): cave.quitGame() self.mouselook() def end(self, scene): pass","title":"Mouselook"},{"location":"Examples/tooling/","text":"Writting your own Tools In the Cave Engine you can write your own tools using python. They can be as simple as just executing a text to do something for you or more complex and well made tools, with a proper interface that contains buttons, sliders and whatever you want in a Tab format, that you can dock to the Editor's ui. To start writting your tools, create a new Python Script in the asset browser, open it in the text editor (double click) and delete the current startup code. Run your first Tool Let's start with a simple tool that just sets some Sun light settings: import cave # You can write the code you want to using the cave API: scene = cave.getCurrentScene() sun = scene.getSun() sun.hour = 6.15 sun.intensity = 5.0 sun.color = cave.Vector3(1.0, 0.8, 0.8) In order to run this code, simply go to \"Editor Tools..\" and then \"Run Script\": It will run and change the sun settings, as expected. Note that you can use print(...) here to debug your stuff as well. Have fun! Create a Tab and Interface for your Tool Now that you already know how to run simple scripts like that, it's time to understand how to do some a bit more advanced ones. So let's start talking about a tool with its own Tab docked in the editor, with a proper interface with buttons, sliders and so on. Here is a screenshot showing that in action. The code in the left generated the tab highlighted in red: Here is a simple code that produces a similar result and can be used as a starting point for your own tools: import cave import caveui as ui class Example(ui.DebugTab): def __init__(self): super().__init__() self.counter = 0 def draw(self): ui.text(\"Hello, world!\") ui.separator() self.counter = ui.prop(\"Counter\", self.counter) if ui.button(\"Increase counter (+1)\"): self.counter += 1 In order to run that and register the Tab to the ui, go to the \"Editor Tools...\" option and open the \"Register Tab...\" sub menu. It will automatically identify all the classes in the code that inherits from the base class caveui.DebugTab and show there. Simply click in the one you want to in order to register it.","title":"Writting your own Tools"},{"location":"Examples/tooling/#writting-your-own-tools","text":"In the Cave Engine you can write your own tools using python. They can be as simple as just executing a text to do something for you or more complex and well made tools, with a proper interface that contains buttons, sliders and whatever you want in a Tab format, that you can dock to the Editor's ui. To start writting your tools, create a new Python Script in the asset browser, open it in the text editor (double click) and delete the current startup code.","title":"Writting your own Tools"},{"location":"Examples/tooling/#run-your-first-tool","text":"Let's start with a simple tool that just sets some Sun light settings: import cave # You can write the code you want to using the cave API: scene = cave.getCurrentScene() sun = scene.getSun() sun.hour = 6.15 sun.intensity = 5.0 sun.color = cave.Vector3(1.0, 0.8, 0.8) In order to run this code, simply go to \"Editor Tools..\" and then \"Run Script\": It will run and change the sun settings, as expected. Note that you can use print(...) here to debug your stuff as well. Have fun!","title":"Run your first Tool"},{"location":"Examples/tooling/#create-a-tab-and-interface-for-your-tool","text":"Now that you already know how to run simple scripts like that, it's time to understand how to do some a bit more advanced ones. So let's start talking about a tool with its own Tab docked in the editor, with a proper interface with buttons, sliders and so on. Here is a screenshot showing that in action. The code in the left generated the tab highlighted in red: Here is a simple code that produces a similar result and can be used as a starting point for your own tools: import cave import caveui as ui class Example(ui.DebugTab): def __init__(self): super().__init__() self.counter = 0 def draw(self): ui.text(\"Hello, world!\") ui.separator() self.counter = ui.prop(\"Counter\", self.counter) if ui.button(\"Increase counter (+1)\"): self.counter += 1 In order to run that and register the Tab to the ui, go to the \"Editor Tools...\" option and open the \"Register Tab...\" sub menu. It will automatically identify all the classes in the code that inherits from the base class caveui.DebugTab and show there. Simply click in the one you want to in order to register it.","title":"Create a Tab and Interface for your Tool"},{"location":"PythonAPI/cave_module/","text":"Cave Module General Functions General game engine related functions and global variables. cave.getEvents() -> cave.Events cave.getDeltaTime() -> float You can use the deltaTime to multiply your variables before moving or rotating an entity, so the action will be consistent independently of the current FPS the game is running on. cave.getMousePosition() -> cave.Vector2 cave.setMousePosition(int x, int y) cave.getWindowSize() -> cave.Vector2 cave.quitGame() -> None cave.getCurrentScene() -> cave.Scene cave.setScene(sceneName : str) -> None cave.restartCurrentScene() -> None cave.Events How to use this class: events = cave.getEvents() if events.pressed(\"W\"): print(\"The user pressed the key W!\") if events.released(\"MOUSE_LEFT\"): print(\"The user released the left mouse button!\") Note: Do not instantiate a new instance of this class, you should always use the one provided by the cave.getEvents() function. Methods pressed(event : str) -> bool Returns True if the user just pressed the event key or False if not. active(event : str) -> bool Always returns True while the user is pressing the event key or False if not. released(event : str) -> bool Returns True if the user just released the event key or False if not. cave.Entity Variables name : str Methods kill() hasTag(tag : str) -> bool add(component : cave.Component) get(component : str) -> cave.Component getAll(component : str) -> list(cave.Component) getScene() -> cave.Scene getParent() -> cave.Entity getChildren() -> list(cave.Entity) getTransform() -> cave.TransformComponent getID() -> int cave.RayCastOut Variables hit : bool position : cave.Vector3 normal : cave.Vector3 entity : cave.Entity cave.Scene Methods newEntity() -> cave.Entity add(entity : cave.Entity) -> cave.Entity addFromTemplate(templateName : str, overrideTransform=True) -> cave.Entity The scene.add(entity) method is used to add an entity you manually build by yourself in the code. Most of the times it's not exactly what you want. That's why there is a scene.addFromTemplate(name) alternative: Given an Entity Template name, the engine will construct a new entity for you followying that template. Both methods returns the added entity for convenience. remove(entity : cave.Entity) rayCast(origin : cave.Vector3, target : cave.Vector3) -> cave.RayCastOut getSun() -> cave.Sun getEntity(id : int) -> cave.Entity getEntity(name : str) -> cave.Entity Note: Time complexity of getting an Entity by name (string) is O(n) and by ID is O(1) . In other words: get by name is way slower than by ID so it's recommended to store the entity ID and use it as much as you can. Also, when you have multiple entities with the same name in the scene, it will always return the first entity found (and this result may be non deterministic - in other words the result may vary). cave.Sun Variables hour : float # 0.0 to 24.0 angle : float # 0.0 to 360.0 color : cave.Vector3 intensity : float cave.Timer Methods get() -> float set(value : float) reset() cave.Component Variables entity : cave.Entity Methods start(scene : cave.Scene) update() end(scene : cave.Scene) reload() The reload() method will end() the component and then start() it again. It's useful because some components like the Mesh and the Light, for optimization purposes, pre cache the data and only changes it during the start.","title":"Cave Module"},{"location":"PythonAPI/cave_module/#cave-module","text":"","title":"Cave Module"},{"location":"PythonAPI/cave_module/#general-functions","text":"General game engine related functions and global variables. cave.getEvents() -> cave.Events cave.getDeltaTime() -> float You can use the deltaTime to multiply your variables before moving or rotating an entity, so the action will be consistent independently of the current FPS the game is running on. cave.getMousePosition() -> cave.Vector2 cave.setMousePosition(int x, int y) cave.getWindowSize() -> cave.Vector2 cave.quitGame() -> None cave.getCurrentScene() -> cave.Scene cave.setScene(sceneName : str) -> None cave.restartCurrentScene() -> None","title":"General Functions"},{"location":"PythonAPI/cave_module/#caveevents","text":"How to use this class: events = cave.getEvents() if events.pressed(\"W\"): print(\"The user pressed the key W!\") if events.released(\"MOUSE_LEFT\"): print(\"The user released the left mouse button!\") Note: Do not instantiate a new instance of this class, you should always use the one provided by the cave.getEvents() function.","title":"cave.Events"},{"location":"PythonAPI/cave_module/#methods","text":"pressed(event : str) -> bool Returns True if the user just pressed the event key or False if not. active(event : str) -> bool Always returns True while the user is pressing the event key or False if not. released(event : str) -> bool Returns True if the user just released the event key or False if not.","title":"Methods"},{"location":"PythonAPI/cave_module/#caveentity","text":"","title":"cave.Entity"},{"location":"PythonAPI/cave_module/#variables","text":"name : str","title":"Variables"},{"location":"PythonAPI/cave_module/#methods_1","text":"kill() hasTag(tag : str) -> bool add(component : cave.Component) get(component : str) -> cave.Component getAll(component : str) -> list(cave.Component) getScene() -> cave.Scene getParent() -> cave.Entity getChildren() -> list(cave.Entity) getTransform() -> cave.TransformComponent getID() -> int","title":"Methods"},{"location":"PythonAPI/cave_module/#caveraycastout","text":"","title":"cave.RayCastOut"},{"location":"PythonAPI/cave_module/#variables_1","text":"hit : bool position : cave.Vector3 normal : cave.Vector3 entity : cave.Entity","title":"Variables"},{"location":"PythonAPI/cave_module/#cavescene","text":"","title":"cave.Scene"},{"location":"PythonAPI/cave_module/#methods_2","text":"newEntity() -> cave.Entity add(entity : cave.Entity) -> cave.Entity addFromTemplate(templateName : str, overrideTransform=True) -> cave.Entity The scene.add(entity) method is used to add an entity you manually build by yourself in the code. Most of the times it's not exactly what you want. That's why there is a scene.addFromTemplate(name) alternative: Given an Entity Template name, the engine will construct a new entity for you followying that template. Both methods returns the added entity for convenience. remove(entity : cave.Entity) rayCast(origin : cave.Vector3, target : cave.Vector3) -> cave.RayCastOut getSun() -> cave.Sun getEntity(id : int) -> cave.Entity getEntity(name : str) -> cave.Entity Note: Time complexity of getting an Entity by name (string) is O(n) and by ID is O(1) . In other words: get by name is way slower than by ID so it's recommended to store the entity ID and use it as much as you can. Also, when you have multiple entities with the same name in the scene, it will always return the first entity found (and this result may be non deterministic - in other words the result may vary).","title":"Methods"},{"location":"PythonAPI/cave_module/#cavesun","text":"","title":"cave.Sun"},{"location":"PythonAPI/cave_module/#variables_2","text":"hour : float # 0.0 to 24.0 angle : float # 0.0 to 360.0 color : cave.Vector3 intensity : float","title":"Variables"},{"location":"PythonAPI/cave_module/#cavetimer","text":"","title":"cave.Timer"},{"location":"PythonAPI/cave_module/#methods_3","text":"get() -> float set(value : float) reset()","title":"Methods"},{"location":"PythonAPI/cave_module/#cavecomponent","text":"","title":"cave.Component"},{"location":"PythonAPI/cave_module/#variables_3","text":"entity : cave.Entity","title":"Variables"},{"location":"PythonAPI/cave_module/#methods_4","text":"start(scene : cave.Scene) update() end(scene : cave.Scene) reload() The reload() method will end() the component and then start() it again. It's useful because some components like the Mesh and the Light, for optimization purposes, pre cache the data and only changes it during the start.","title":"Methods"},{"location":"PythonAPI/components/","text":"Components cave.TransformComponent Variables position : cave.Vector3 scale : cave.Vector3 Note that you can't get/set the rotation using regular variables as you can with the position and scale . That's due to the way the engine works internally. So use the getters and setters for euler angles or quaternions to rotate as you need to. You can see the details bellow. Sample code (as it would be in the update method of a Component): [...] def update(self): transform = self.entity.getTransform() # Modifying the current euler angles by adding 0.1 on the Y axis: euler = transform.getEuler() euler.y += 0.1 transform.setEuler(euler) # or you can use this to ROTATE the object: # (will produce the same result as the approach above) transform.rotate(0, 0.1, 0) [...] # Last but no least, you can also do this to SET the euler: # (note that this approach will not produce the same result # as the two others presented above. This one wil SET the # rotation to [0, 0, 0]) transform.setEuler(0, 0, 0) Methods getEuler() -> cave.Vector3 setEuler(euler : cave.Vector3) setEuler(x : float, y : float, z : float) getQuaternion() -> cave.Quaternion setQuaternion(quaternion : cave.Quaternion) setQuaternion(x : float, y : float, z : float, w: float) getMatrix() -> cave.Matrix4 setMatrix(mat : cave.Matrix4) rotate(x : float, y : float, z : float) move(x : float, y : float, z : float, local = True) rotateOnAxis(angle : float, axis : cave.Vector3) rotateOnPitch(angle : float) rotateOnYaw(angle : float) rotateOnRoll(angle : float) applyLocalMovement(x : float, y : float, z : float) getPitch() -> float getYaw() -> float getRoll() -> float getForwardVector() -> cave.Vector3 getRightVector() -> cave.Vector3 getUpVector() -> cave.Vector3 lookAt(direction : cave.Vector3, up = cave.Vector3(0, 1, 0)) rotateVector(vec : cave.Vector3) -> cave.Vector3 transformVector(vec : cave.Vector3) -> cave.Vector3 cave.MeshComponent Methods setAnimation(animation : string) cave.LightComponent You can adjust various light parameters. Here is a sample code that makes the light color pulse using some timers and the python native math.sin() function: import cave import math import random class PulsingLight(cave.Component): def start(self, scene): self.speed = 2.0 # Creating some timers with a random value to sample from self.colorX = cave.Timer(random.random()) self.colorY = cave.Timer(random.random()) self.colorZ = cave.Timer(random.random()) def compute(self, value): # Maps the timer into a sin curve ranged [0 - 1] return (math.sin(value * self.speed) + 1) / 2 def update(self): light = self.entity.get(\"Light Component\") light.color.x = self.compute(self.colorX.get()) light.color.y = self.compute(self.colorY.get()) light.color.z = self.compute(self.colorZ.get()) print(light.color.x, light.color.y, light.color.z) # Don't forget to reload the light, otherwise it will not be updated: light.reload() def end(self, scene): pass Variables NOTE: Lights are pre cached so the changes you made in the following parameters will not be effective (applied to the light) until you call the reload() method. color : cave.Vector3 radius : float intensity : float cave.UIElementComponent Variables text : str position : cave.UIVector scale : cave.UIVector text : str Methods isHovered() -> bool cave.RigidBodyComponent Variables alwaysActive : bool linearVelocity : cave.Vector3 angularVelocity : cave.Vector3 angularFactor : cave.Vector3 Methods getCollisions() -> list(cave.Entity) collidedWith(tag : string) -> bool applyTorque(x : float, y : float, z : float) applyForce(x : float, y : float, z : float, location : cave.Vector3) isDynamic() -> bool setMass(value : float)","title":"Components"},{"location":"PythonAPI/components/#components","text":"","title":"Components"},{"location":"PythonAPI/components/#cavetransformcomponent","text":"","title":"cave.TransformComponent"},{"location":"PythonAPI/components/#variables","text":"position : cave.Vector3 scale : cave.Vector3 Note that you can't get/set the rotation using regular variables as you can with the position and scale . That's due to the way the engine works internally. So use the getters and setters for euler angles or quaternions to rotate as you need to. You can see the details bellow. Sample code (as it would be in the update method of a Component): [...] def update(self): transform = self.entity.getTransform() # Modifying the current euler angles by adding 0.1 on the Y axis: euler = transform.getEuler() euler.y += 0.1 transform.setEuler(euler) # or you can use this to ROTATE the object: # (will produce the same result as the approach above) transform.rotate(0, 0.1, 0) [...] # Last but no least, you can also do this to SET the euler: # (note that this approach will not produce the same result # as the two others presented above. This one wil SET the # rotation to [0, 0, 0]) transform.setEuler(0, 0, 0)","title":"Variables"},{"location":"PythonAPI/components/#methods","text":"getEuler() -> cave.Vector3 setEuler(euler : cave.Vector3) setEuler(x : float, y : float, z : float) getQuaternion() -> cave.Quaternion setQuaternion(quaternion : cave.Quaternion) setQuaternion(x : float, y : float, z : float, w: float) getMatrix() -> cave.Matrix4 setMatrix(mat : cave.Matrix4) rotate(x : float, y : float, z : float) move(x : float, y : float, z : float, local = True) rotateOnAxis(angle : float, axis : cave.Vector3) rotateOnPitch(angle : float) rotateOnYaw(angle : float) rotateOnRoll(angle : float) applyLocalMovement(x : float, y : float, z : float) getPitch() -> float getYaw() -> float getRoll() -> float getForwardVector() -> cave.Vector3 getRightVector() -> cave.Vector3 getUpVector() -> cave.Vector3 lookAt(direction : cave.Vector3, up = cave.Vector3(0, 1, 0)) rotateVector(vec : cave.Vector3) -> cave.Vector3 transformVector(vec : cave.Vector3) -> cave.Vector3","title":"Methods"},{"location":"PythonAPI/components/#cavemeshcomponent","text":"","title":"cave.MeshComponent"},{"location":"PythonAPI/components/#methods_1","text":"setAnimation(animation : string)","title":"Methods"},{"location":"PythonAPI/components/#cavelightcomponent","text":"You can adjust various light parameters. Here is a sample code that makes the light color pulse using some timers and the python native math.sin() function: import cave import math import random class PulsingLight(cave.Component): def start(self, scene): self.speed = 2.0 # Creating some timers with a random value to sample from self.colorX = cave.Timer(random.random()) self.colorY = cave.Timer(random.random()) self.colorZ = cave.Timer(random.random()) def compute(self, value): # Maps the timer into a sin curve ranged [0 - 1] return (math.sin(value * self.speed) + 1) / 2 def update(self): light = self.entity.get(\"Light Component\") light.color.x = self.compute(self.colorX.get()) light.color.y = self.compute(self.colorY.get()) light.color.z = self.compute(self.colorZ.get()) print(light.color.x, light.color.y, light.color.z) # Don't forget to reload the light, otherwise it will not be updated: light.reload() def end(self, scene): pass","title":"cave.LightComponent"},{"location":"PythonAPI/components/#variables_1","text":"NOTE: Lights are pre cached so the changes you made in the following parameters will not be effective (applied to the light) until you call the reload() method. color : cave.Vector3 radius : float intensity : float","title":"Variables"},{"location":"PythonAPI/components/#caveuielementcomponent","text":"","title":"cave.UIElementComponent"},{"location":"PythonAPI/components/#variables_2","text":"text : str position : cave.UIVector scale : cave.UIVector text : str","title":"Variables"},{"location":"PythonAPI/components/#methods_2","text":"isHovered() -> bool","title":"Methods"},{"location":"PythonAPI/components/#caverigidbodycomponent","text":"","title":"cave.RigidBodyComponent"},{"location":"PythonAPI/components/#variables_3","text":"alwaysActive : bool linearVelocity : cave.Vector3 angularVelocity : cave.Vector3 angularFactor : cave.Vector3","title":"Variables"},{"location":"PythonAPI/components/#methods_3","text":"getCollisions() -> list(cave.Entity) collidedWith(tag : string) -> bool applyTorque(x : float, y : float, z : float) applyForce(x : float, y : float, z : float, location : cave.Vector3) isDynamic() -> bool setMass(value : float)","title":"Methods"},{"location":"PythonAPI/eventNames/","text":"Event Names See cave.Events for more details. Event Name Key \"0\" 0 \"1\" 1 \"2\" 2 \"3\" 3 \"4\" 4 \"5\" 5 \"6\" 6 \"7\" 7 \"8\" 8 \"9\" 9 \"A\" A \"AC_BACK\" Ac Back \"AC_BOOKMARKS\" Ac Bookmarks \"AC_FORWARD\" Ac Forward \"AC_HOME\" Ac Home \"AC_REFRESH\" Ac Refresh \"AC_SEARCH\" Ac Search \"AC_STOP\" Ac Stop \"AGAIN\" Again \"ALTERASE\" Alterase \"AMPERSAND\" Ampersand \"APPLICATION\" Application \"ASTERISK\" Asterisk \"AT\" At \"AUDIOMUTE\" Audiomute \"AUDIONEXT\" Audionext \"AUDIOPLAY\" Audioplay \"AUDIOPREV\" Audioprev \"AUDIOSTOP\" Audiostop \"B\" B \"BACKQUOTE\" Backquote \"BACKSLASH\" Backslash \"BACKSPACE\" Backspace \"BRIGHTNESSDOWN\" Brightnessdown \"BRIGHTNESSUP\" Brightnessup \"C\" C \"CALCULATOR\" Calculator \"CANCEL\" Cancel \"CAPSLOCK\" Capslock \"CARET\" Caret \"CLEAR\" Clear \"CLEARAGAIN\" Clearagain \"COLON\" Colon \"COMMA\" Comma \"COMPUTER\" Computer \"COPY\" Copy \"CRSEL\" Crsel \"CURRENCYSUBUNIT\" Currencysubunit \"CURRENCYUNIT\" Currencyunit \"CUT\" Cut \"D\" D \"DECIMALSEPARATOR\" Decimalseparator \"DELETE\" Delete \"DISPLAYSWITCH\" Displayswitch \"DOLLAR\" Dollar \"DOWN\" Down \"E\" E \"EJECT\" Eject \"END\" End \"EQUALS\" Equals \"ESCAPE\" Escape \"EXCLAIM\" Exclaim \"EXECUTE_\" Execute \"EXSEL\" Exsel \"F\" F \"F1\" F1 \"F10\" F10 \"F11\" F11 \"F12\" F12 \"F13\" F13 \"F14\" F14 \"F15\" F15 \"F16\" F16 \"F17\" F17 \"F18\" F18 \"F19\" F19 \"F2\" F2 \"F20\" F20 \"F21\" F21 \"F22\" F22 \"F23\" F23 \"F24\" F24 \"F3\" F3 \"F4\" F4 \"F5\" F5 \"F6\" F6 \"F7\" F7 \"F8\" F8 \"F9\" F9 \"FIND\" Find \"G\" G \"GREATER\" Greater \"H\" H \"HASH\" Hash \"HELP\" Help \"HOME\" Home \"I\" I \"INSERT\" Insert \"J\" J \"K\" K \"KBDILLUMDOWN\" Kbdillumdown \"KBDILLUMTOGGLE\" Kbdillumtoggle \"KBDILLUMUP\" Kbdillumup \"KP_0\" Kp 0 \"KP_00\" Kp 00 \"KP_000\" Kp 000 \"KP_1\" Kp 1 \"KP_2\" Kp 2 \"KP_3\" Kp 3 \"KP_4\" Kp 4 \"KP_5\" Kp 5 \"KP_6\" Kp 6 \"KP_7\" Kp 7 \"KP_8\" Kp 8 \"KP_9\" Kp 9 \"KP_A\" Kp A \"KP_AMPERSAND\" Kp Ampersand \"KP_AT\" Kp At \"KP_B\" Kp B \"KP_BACKSPACE\" Kp Backspace \"KP_BINARY\" Kp Binary \"KP_C\" Kp C \"KP_CLEAR\" Kp Clear \"KP_CLEARENTRY\" Kp Clearentry \"KP_COLON\" Kp Colon \"KP_COMMA\" Kp Comma \"KP_D\" Kp D \"KP_DBLAMPERSAND\" Kp Dblampersand \"KP_DBLVERTICALBAR\" Kp Dblverticalbar \"KP_DECIMAL\" Kp Decimal \"KP_DIVIDE\" Kp Divide \"KP_E\" Kp E \"KP_ENTER\" Kp Enter \"KP_EQUALS\" Kp Equals \"KP_EQUALSAS400\" Kp Equalsas400 \"KP_EXCLAM\" Kp Exclam \"KP_F\" Kp F \"KP_GREATER\" Kp Greater \"KP_HASH\" Kp Hash \"KP_HEXADECIMAL\" Kp Hexadecimal \"KP_LEFTBRACE\" Kp Leftbrace \"KP_LEFTPAREN\" Kp Leftparen \"KP_LESS\" Kp Less \"KP_MEMADD\" Kp Memadd \"KP_MEMCLEAR\" Kp Memclear \"KP_MEMDIVIDE\" Kp Memdivide \"KP_MEMMULTIPLY\" Kp Memmultiply \"KP_MEMRECALL\" Kp Memrecall \"KP_MEMSTORE\" Kp Memstore \"KP_MEMSUBTRACT\" Kp Memsubtract \"KP_MINUS\" Kp Minus \"KP_MULTIPLY\" Kp Multiply \"KP_OCTAL\" Kp Octal \"KP_PERCENT\" Kp Percent \"KP_PERIOD\" Kp Period \"KP_PLUS\" Kp Plus \"KP_PLUSMINUS\" Kp Plusminus \"KP_POWER\" Kp Power \"KP_RIGHTBRACE\" Kp Rightbrace \"KP_RIGHTPAREN\" Kp Rightparen \"KP_SPACE\" Kp Space \"KP_TAB\" Kp Tab \"KP_VERTICALBAR\" Kp Verticalbar \"KP_XOR\" Kp Xor \"L\" L \"LALT\" Lalt \"LCTRL\" Lctrl \"LEFT\" Left \"LEFTBRACKET\" Leftbracket \"LEFTPAREN\" Leftparen \"LESS\" Less \"LGUI\" Lgui \"LSHIFT\" Lshift \"M\" M \"MAIL\" Mail \"MEDIASELECT\" Mediaselect \"MENU\" Menu \"MINUS\" Minus \"MODE\" Mode \"MOUSE_LEFT\" Mouse Left \"MOUSE_MIDDLE\" Mouse Middle \"MOUSE_RIGHT\" Mouse Right \"MUTE\" Mute \"N\" N \"NUMLOCKCLEAR\" Numlockclear \"O\" O \"OPER\" Oper \"OUT\" Out \"P\" P \"PAGEDOWN\" Pagedown \"PAGEUP\" Pageup \"PASTE\" Paste \"PAUSE\" Pause \"PERCENT\" Percent \"PERIOD\" Period \"PLUS\" Plus \"POWER\" Power \"PRINTSCREEN\" Printscreen \"PRIOR\" Prior \"Q\" Q \"QUESTION\" Question \"QUOTE\" Quote \"QUOTEDBL\" Quotedbl \"R\" R \"RALT\" Ralt \"RCTRL\" Rctrl \"RETURN\" Return \"RETURN2\" Return2 \"RGUI\" Rgui \"RIGHT\" Right \"RIGHTBRACKET\" Rightbracket \"RIGHTPAREN\" Rightparen \"RSHIFT\" Rshift \"S\" S \"SCROLLLOCK\" Scrolllock \"SELECT\" Select \"SEMICOLON\" Semicolon \"SEPARATOR\" Separator \"SIZE\" Size \"SLASH\" Slash \"SLEEP\" Sleep \"SPACE\" Space \"STOP\" Stop \"SYSREQ\" Sysreq \"T\" T \"TAB\" Tab \"THOUSANDSSEPARATOR\" Thousandsseparator \"U\" U \"UNDO\" Undo \"UNKNOWN\" Unknown \"UP\" Up \"V\" V \"VOLUMEDOWN\" Volumedown \"VOLUMEUP\" Volumeup \"W\" W \"WWW\" Www \"X\" X \"Y\" Y \"Z\" Z","title":"Event Names"},{"location":"PythonAPI/eventNames/#event-names","text":"See cave.Events for more details. Event Name Key \"0\" 0 \"1\" 1 \"2\" 2 \"3\" 3 \"4\" 4 \"5\" 5 \"6\" 6 \"7\" 7 \"8\" 8 \"9\" 9 \"A\" A \"AC_BACK\" Ac Back \"AC_BOOKMARKS\" Ac Bookmarks \"AC_FORWARD\" Ac Forward \"AC_HOME\" Ac Home \"AC_REFRESH\" Ac Refresh \"AC_SEARCH\" Ac Search \"AC_STOP\" Ac Stop \"AGAIN\" Again \"ALTERASE\" Alterase \"AMPERSAND\" Ampersand \"APPLICATION\" Application \"ASTERISK\" Asterisk \"AT\" At \"AUDIOMUTE\" Audiomute \"AUDIONEXT\" Audionext \"AUDIOPLAY\" Audioplay \"AUDIOPREV\" Audioprev \"AUDIOSTOP\" Audiostop \"B\" B \"BACKQUOTE\" Backquote \"BACKSLASH\" Backslash \"BACKSPACE\" Backspace \"BRIGHTNESSDOWN\" Brightnessdown \"BRIGHTNESSUP\" Brightnessup \"C\" C \"CALCULATOR\" Calculator \"CANCEL\" Cancel \"CAPSLOCK\" Capslock \"CARET\" Caret \"CLEAR\" Clear \"CLEARAGAIN\" Clearagain \"COLON\" Colon \"COMMA\" Comma \"COMPUTER\" Computer \"COPY\" Copy \"CRSEL\" Crsel \"CURRENCYSUBUNIT\" Currencysubunit \"CURRENCYUNIT\" Currencyunit \"CUT\" Cut \"D\" D \"DECIMALSEPARATOR\" Decimalseparator \"DELETE\" Delete \"DISPLAYSWITCH\" Displayswitch \"DOLLAR\" Dollar \"DOWN\" Down \"E\" E \"EJECT\" Eject \"END\" End \"EQUALS\" Equals \"ESCAPE\" Escape \"EXCLAIM\" Exclaim \"EXECUTE_\" Execute \"EXSEL\" Exsel \"F\" F \"F1\" F1 \"F10\" F10 \"F11\" F11 \"F12\" F12 \"F13\" F13 \"F14\" F14 \"F15\" F15 \"F16\" F16 \"F17\" F17 \"F18\" F18 \"F19\" F19 \"F2\" F2 \"F20\" F20 \"F21\" F21 \"F22\" F22 \"F23\" F23 \"F24\" F24 \"F3\" F3 \"F4\" F4 \"F5\" F5 \"F6\" F6 \"F7\" F7 \"F8\" F8 \"F9\" F9 \"FIND\" Find \"G\" G \"GREATER\" Greater \"H\" H \"HASH\" Hash \"HELP\" Help \"HOME\" Home \"I\" I \"INSERT\" Insert \"J\" J \"K\" K \"KBDILLUMDOWN\" Kbdillumdown \"KBDILLUMTOGGLE\" Kbdillumtoggle \"KBDILLUMUP\" Kbdillumup \"KP_0\" Kp 0 \"KP_00\" Kp 00 \"KP_000\" Kp 000 \"KP_1\" Kp 1 \"KP_2\" Kp 2 \"KP_3\" Kp 3 \"KP_4\" Kp 4 \"KP_5\" Kp 5 \"KP_6\" Kp 6 \"KP_7\" Kp 7 \"KP_8\" Kp 8 \"KP_9\" Kp 9 \"KP_A\" Kp A \"KP_AMPERSAND\" Kp Ampersand \"KP_AT\" Kp At \"KP_B\" Kp B \"KP_BACKSPACE\" Kp Backspace \"KP_BINARY\" Kp Binary \"KP_C\" Kp C \"KP_CLEAR\" Kp Clear \"KP_CLEARENTRY\" Kp Clearentry \"KP_COLON\" Kp Colon \"KP_COMMA\" Kp Comma \"KP_D\" Kp D \"KP_DBLAMPERSAND\" Kp Dblampersand \"KP_DBLVERTICALBAR\" Kp Dblverticalbar \"KP_DECIMAL\" Kp Decimal \"KP_DIVIDE\" Kp Divide \"KP_E\" Kp E \"KP_ENTER\" Kp Enter \"KP_EQUALS\" Kp Equals \"KP_EQUALSAS400\" Kp Equalsas400 \"KP_EXCLAM\" Kp Exclam \"KP_F\" Kp F \"KP_GREATER\" Kp Greater \"KP_HASH\" Kp Hash \"KP_HEXADECIMAL\" Kp Hexadecimal \"KP_LEFTBRACE\" Kp Leftbrace \"KP_LEFTPAREN\" Kp Leftparen \"KP_LESS\" Kp Less \"KP_MEMADD\" Kp Memadd \"KP_MEMCLEAR\" Kp Memclear \"KP_MEMDIVIDE\" Kp Memdivide \"KP_MEMMULTIPLY\" Kp Memmultiply \"KP_MEMRECALL\" Kp Memrecall \"KP_MEMSTORE\" Kp Memstore \"KP_MEMSUBTRACT\" Kp Memsubtract \"KP_MINUS\" Kp Minus \"KP_MULTIPLY\" Kp Multiply \"KP_OCTAL\" Kp Octal \"KP_PERCENT\" Kp Percent \"KP_PERIOD\" Kp Period \"KP_PLUS\" Kp Plus \"KP_PLUSMINUS\" Kp Plusminus \"KP_POWER\" Kp Power \"KP_RIGHTBRACE\" Kp Rightbrace \"KP_RIGHTPAREN\" Kp Rightparen \"KP_SPACE\" Kp Space \"KP_TAB\" Kp Tab \"KP_VERTICALBAR\" Kp Verticalbar \"KP_XOR\" Kp Xor \"L\" L \"LALT\" Lalt \"LCTRL\" Lctrl \"LEFT\" Left \"LEFTBRACKET\" Leftbracket \"LEFTPAREN\" Leftparen \"LESS\" Less \"LGUI\" Lgui \"LSHIFT\" Lshift \"M\" M \"MAIL\" Mail \"MEDIASELECT\" Mediaselect \"MENU\" Menu \"MINUS\" Minus \"MODE\" Mode \"MOUSE_LEFT\" Mouse Left \"MOUSE_MIDDLE\" Mouse Middle \"MOUSE_RIGHT\" Mouse Right \"MUTE\" Mute \"N\" N \"NUMLOCKCLEAR\" Numlockclear \"O\" O \"OPER\" Oper \"OUT\" Out \"P\" P \"PAGEDOWN\" Pagedown \"PAGEUP\" Pageup \"PASTE\" Paste \"PAUSE\" Pause \"PERCENT\" Percent \"PERIOD\" Period \"PLUS\" Plus \"POWER\" Power \"PRINTSCREEN\" Printscreen \"PRIOR\" Prior \"Q\" Q \"QUESTION\" Question \"QUOTE\" Quote \"QUOTEDBL\" Quotedbl \"R\" R \"RALT\" Ralt \"RCTRL\" Rctrl \"RETURN\" Return \"RETURN2\" Return2 \"RGUI\" Rgui \"RIGHT\" Right \"RIGHTBRACKET\" Rightbracket \"RIGHTPAREN\" Rightparen \"RSHIFT\" Rshift \"S\" S \"SCROLLLOCK\" Scrolllock \"SELECT\" Select \"SEMICOLON\" Semicolon \"SEPARATOR\" Separator \"SIZE\" Size \"SLASH\" Slash \"SLEEP\" Sleep \"SPACE\" Space \"STOP\" Stop \"SYSREQ\" Sysreq \"T\" T \"TAB\" Tab \"THOUSANDSSEPARATOR\" Thousandsseparator \"U\" U \"UNDO\" Undo \"UNKNOWN\" Unknown \"UP\" Up \"V\" V \"VOLUMEDOWN\" Volumedown \"VOLUMEUP\" Volumeup \"W\" W \"WWW\" Www \"X\" X \"Y\" Y \"Z\" Z","title":"Event Names"},{"location":"PythonAPI/math/","text":"Math cave Functions normalized(vec : cave.Vector3) -> cave.Vector3 length(vec : cave.Vector3) -> float Vector Classes Cave Engine provides wrappers to low level C++ vector classes and operations. Initialization Example Here is an initialization example to get started: # Default constructor: vec = cave.Vector() # Intialize the vector with (0, 0): myVec1 = cave.Vector2(0) # Regular (x, y) constructor for the 2D Vector: myVec2 = cave.Vector2(0, 1) # Copy the vector: myVec3 = cave.Vector3(myVec2) Supported Vector Operations You can do all sorts of operations using vectors: Operation Usage == if vecA == vecB: ... + vec = vecA + vecB += vec += vecB - vec = vecA - vecB -= vec -= vecB * vec = vecB * 50.0 * vec = 50.0 * vecB *= vec *= 100.0 Including operations between a cave.Vector3 and an cave.Quaternion : Operation Usage * vec = vec * quaterion * vec = quaterion * vecB *= vec *= quaterion cave.Vector2 Variables x : float y : float Note: You can also access the x, y parameters by using s, t or u, v . cave.Vector3 Variables x : float y : float z : float Note: You can also access the x, y, z parameters by using r, g, b as an acronym for the color channels Red , Green and Blue . cave.Vector4 Variables x : float y : float z : float w : float Note: You can also access the x, y, z, w parameters by using r, g, b, a as an acronym for the color channels Red , Green , Blue and Alpha . cave.Quaternion Quaternions, just like the vectors, are low level implementations that supports all sorts of operations ( ==, +, +=, -, -=, *, *= ). Variables x : float y : float z : float w : float cave.UIVector The cave.UIVector is a different vector, used specifically for the in Game User Interface (Game UI). It needs to be a different type of vector because it also takes into account the anchoring and if the element is relative (or not) to it's parent. If the vector is relative, the X, Y values will be represented with a [0-1] ranged float number (percentage). If not, it will be represented by two ints for the pixels. Variables anchoringX : int anchoringY : int The supported anchoring values are: -1, 0, 1 . Methods isRelativeX() -> bool isRelativeY() -> bool getX(parentScale = 1.0) -> float getY(parentScale = 1.0) -> float setPixelX(value : int) setPixelY(value : int) setPixel(x : int, y : int) setRelativeX(value : float) setRelativeY(value : float) setRelative(x : float, y : float)","title":"Math"},{"location":"PythonAPI/math/#math","text":"","title":"Math"},{"location":"PythonAPI/math/#cave","text":"","title":"cave"},{"location":"PythonAPI/math/#functions","text":"normalized(vec : cave.Vector3) -> cave.Vector3 length(vec : cave.Vector3) -> float","title":"Functions"},{"location":"PythonAPI/math/#vector-classes","text":"Cave Engine provides wrappers to low level C++ vector classes and operations.","title":"Vector Classes"},{"location":"PythonAPI/math/#initialization-example","text":"Here is an initialization example to get started: # Default constructor: vec = cave.Vector() # Intialize the vector with (0, 0): myVec1 = cave.Vector2(0) # Regular (x, y) constructor for the 2D Vector: myVec2 = cave.Vector2(0, 1) # Copy the vector: myVec3 = cave.Vector3(myVec2)","title":"Initialization Example"},{"location":"PythonAPI/math/#supported-vector-operations","text":"You can do all sorts of operations using vectors: Operation Usage == if vecA == vecB: ... + vec = vecA + vecB += vec += vecB - vec = vecA - vecB -= vec -= vecB * vec = vecB * 50.0 * vec = 50.0 * vecB *= vec *= 100.0 Including operations between a cave.Vector3 and an cave.Quaternion : Operation Usage * vec = vec * quaterion * vec = quaterion * vecB *= vec *= quaterion","title":"Supported Vector Operations"},{"location":"PythonAPI/math/#cavevector2","text":"","title":"cave.Vector2"},{"location":"PythonAPI/math/#variables","text":"x : float y : float Note: You can also access the x, y parameters by using s, t or u, v .","title":"Variables"},{"location":"PythonAPI/math/#cavevector3","text":"","title":"cave.Vector3"},{"location":"PythonAPI/math/#variables_1","text":"x : float y : float z : float Note: You can also access the x, y, z parameters by using r, g, b as an acronym for the color channels Red , Green and Blue .","title":"Variables"},{"location":"PythonAPI/math/#cavevector4","text":"","title":"cave.Vector4"},{"location":"PythonAPI/math/#variables_2","text":"x : float y : float z : float w : float Note: You can also access the x, y, z, w parameters by using r, g, b, a as an acronym for the color channels Red , Green , Blue and Alpha .","title":"Variables"},{"location":"PythonAPI/math/#cavequaternion","text":"Quaternions, just like the vectors, are low level implementations that supports all sorts of operations ( ==, +, +=, -, -=, *, *= ).","title":"cave.Quaternion"},{"location":"PythonAPI/math/#variables_3","text":"x : float y : float z : float w : float","title":"Variables"},{"location":"PythonAPI/math/#caveuivector","text":"The cave.UIVector is a different vector, used specifically for the in Game User Interface (Game UI). It needs to be a different type of vector because it also takes into account the anchoring and if the element is relative (or not) to it's parent. If the vector is relative, the X, Y values will be represented with a [0-1] ranged float number (percentage). If not, it will be represented by two ints for the pixels.","title":"cave.UIVector"},{"location":"PythonAPI/math/#variables_4","text":"anchoringX : int anchoringY : int The supported anchoring values are: -1, 0, 1 .","title":"Variables"},{"location":"PythonAPI/math/#methods","text":"isRelativeX() -> bool isRelativeY() -> bool getX(parentScale = 1.0) -> float getY(parentScale = 1.0) -> float setPixelX(value : int) setPixelY(value : int) setPixel(x : int, y : int) setRelativeX(value : float) setRelativeY(value : float) setRelative(x : float, y : float)","title":"Methods"},{"location":"Showcase/games/","text":"Games Powered by Cave In this section you'll find good examples of what is possible to do using Cave Engine . The Looper's Path This is the first Uniday Studio game made using Cave! And it was made in 72 hours for the game jam Ludum Dare 50 . It was created using Cave Engine version 0.9.8. In this game you control Looper, a robot that loses his energy (in a shape of energy orbs) as you walk. When it runs out of energy, it explodes! The good news is that looper does have clones to help you walk throught the levels and their clones will recover energy from your past lost orbs. It's a puzzle game available for you to Play on Itch io . Sweet Shelter The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here: Sweet Shelter on itch io Ralph! Ralph is also doing some amazing work using the engine: He was one of the first active Cave Engine user, way before it was even named cave. Thank you!","title":"Games Made with Cave"},{"location":"Showcase/games/#games-powered-by-cave","text":"In this section you'll find good examples of what is possible to do using Cave Engine .","title":"Games Powered by Cave"},{"location":"Showcase/games/#the-loopers-path","text":"This is the first Uniday Studio game made using Cave! And it was made in 72 hours for the game jam Ludum Dare 50 . It was created using Cave Engine version 0.9.8. In this game you control Looper, a robot that loses his energy (in a shape of energy orbs) as you walk. When it runs out of energy, it explodes! The good news is that looper does have clones to help you walk throught the levels and their clones will recover energy from your past lost orbs. It's a puzzle game available for you to Play on Itch io .","title":"The Looper's Path"},{"location":"Showcase/games/#sweet-shelter","text":"The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here: Sweet Shelter on itch io","title":"Sweet Shelter"},{"location":"Showcase/games/#ralph","text":"Ralph is also doing some amazing work using the engine: He was one of the first active Cave Engine user, way before it was even named cave. Thank you!","title":"Ralph!"}]}