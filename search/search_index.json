{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Cave Engine's Documentation (Use the top menu to navigate in the categories) Cave Engine is a Simple 3D desktop Game Engine scriptable in Python. In this website you'll find the documentation you need to get started with the scripting in the engine and also some useful information such as the future roadmap and license. Download the Engine You can check the details and download the engine using this link: Download the Cave Engine Our Discord Server If you want to talk about the engine, leave some suggestions, comments or get some help from the community, feel free to join us: Discord - English Discord - Portuguese/Brazil Note that at the moment we have a portuguese and an english discord so you can feel free to join the one you're more confortable with.","title":"Home"},{"location":"#welcome-to-cave-engines-documentation","text":"(Use the top menu to navigate in the categories) Cave Engine is a Simple 3D desktop Game Engine scriptable in Python. In this website you'll find the documentation you need to get started with the scripting in the engine and also some useful information such as the future roadmap and license.","title":"Welcome to Cave Engine's Documentation"},{"location":"#download-the-engine","text":"You can check the details and download the engine using this link: Download the Cave Engine","title":"Download the Engine"},{"location":"#our-discord-server","text":"If you want to talk about the engine, leave some suggestions, comments or get some help from the community, feel free to join us: Discord - English Discord - Portuguese/Brazil Note that at the moment we have a portuguese and an english discord so you can feel free to join the one you're more confortable with.","title":"Our Discord Server"},{"location":"Docs/eula/","text":"In a Nutshell: Cave Engine consists in two parts : The Cave Engine Editor and everything it requires to run. The end-product \" Game \" generated by the editor. The Cave Engine Editor is an intellectual property of Uniday Studio and you have a personal, non-transferable, non-exclusive licence to use the Cave Engine Editor software on your devices. You're not allowed to share, modify or redistribute it in any forms other than the ones provided by Uniday Studio. The Game generated by the Cave Engine Editor can be redistributed (even commercially) uner the collowing term: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. Including the phrase: \"Made using Cave Engine - from Uniday Studio\" in the project and license, in a visible and easily foundable place is enough. Remember that the name Uniday Studio is a registered trademark and you are not allowed to use it to endorse your projects in any forms. End-User License Agreement (EULA) of Cave Engine This End-User License Agreement (\"EULA\") is a legal agreement between you and Uniday Studio . This EULA agreement governs your acquisition and use of our Cave Engine software (\"Software\") directly from Uniday Studio or indirectly through a Uniday Studio authorized reseller or distributor (a \"Reseller\"). Our Privacy Policy was created by the Privacy Policy Generator. Please read this EULA agreement carefully before completing the installation process and using the Cave Engine software. It provides a license to use the Cave Engine software and contains warranty information and liability disclaimers. If you register for a free trial of the Cave Engine software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Cave Engine software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Uniday Studio herewith regardless of whether other software is referred to or described herein. The terms also apply to any Uniday Studio updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply. License Grant Uniday Studio hereby grants you a personal, non-transferable, non-exclusive licence to use the Cave Engine software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Cave Engine software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Cave Engine software. Uniday Studios also hereby grants you the rights to redistribute the end-product \"Game\" generated by the editor, including for commercial purposes, under the following terms: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. The exported Game can not include a copy of the Cave Engine Editor . Not use a license that forces this software to be open source or change its license (such as GPL). Your project (game) can be source open but the Cave Engine Editor software can't be forced to. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose, except with the generated Game . Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Uniday Studio considers is a breach of this EULA agreement Intellectual Property and Ownership Uniday Studio shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Uniday Studio. Uniday Studio reserves the right to grant licences to use the Software to third parties. Termination This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Uniday Studio. It will also terminate immediately if you fail to comply with any term of this EULA agreement. Upon such termination, the licenses granted by this EULA agreement will immediately terminate and you agree to stop all access and use of the Software. The provisions that by their nature continue and survive will survive any termination of this EULA agreement. Governing Law This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of Brazil.","title":"License (EULA)"},{"location":"Docs/eula/#in-a-nutshell","text":"Cave Engine consists in two parts : The Cave Engine Editor and everything it requires to run. The end-product \" Game \" generated by the editor. The Cave Engine Editor is an intellectual property of Uniday Studio and you have a personal, non-transferable, non-exclusive licence to use the Cave Engine Editor software on your devices. You're not allowed to share, modify or redistribute it in any forms other than the ones provided by Uniday Studio. The Game generated by the Cave Engine Editor can be redistributed (even commercially) uner the collowing term: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. Including the phrase: \"Made using Cave Engine - from Uniday Studio\" in the project and license, in a visible and easily foundable place is enough. Remember that the name Uniday Studio is a registered trademark and you are not allowed to use it to endorse your projects in any forms.","title":"In a Nutshell:"},{"location":"Docs/eula/#end-user-license-agreement-eula-of-cave-engine","text":"This End-User License Agreement (\"EULA\") is a legal agreement between you and Uniday Studio . This EULA agreement governs your acquisition and use of our Cave Engine software (\"Software\") directly from Uniday Studio or indirectly through a Uniday Studio authorized reseller or distributor (a \"Reseller\"). Our Privacy Policy was created by the Privacy Policy Generator. Please read this EULA agreement carefully before completing the installation process and using the Cave Engine software. It provides a license to use the Cave Engine software and contains warranty information and liability disclaimers. If you register for a free trial of the Cave Engine software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Cave Engine software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Uniday Studio herewith regardless of whether other software is referred to or described herein. The terms also apply to any Uniday Studio updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply.","title":"End-User License Agreement (EULA) of Cave Engine"},{"location":"Docs/eula/#license-grant","text":"Uniday Studio hereby grants you a personal, non-transferable, non-exclusive licence to use the Cave Engine software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Cave Engine software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Cave Engine software. Uniday Studios also hereby grants you the rights to redistribute the end-product \"Game\" generated by the editor, including for commercial purposes, under the following terms: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. The exported Game can not include a copy of the Cave Engine Editor . Not use a license that forces this software to be open source or change its license (such as GPL). Your project (game) can be source open but the Cave Engine Editor software can't be forced to. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose, except with the generated Game . Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Uniday Studio considers is a breach of this EULA agreement","title":"License Grant"},{"location":"Docs/eula/#intellectual-property-and-ownership","text":"Uniday Studio shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Uniday Studio. Uniday Studio reserves the right to grant licences to use the Software to third parties.","title":"Intellectual Property and Ownership"},{"location":"Docs/eula/#termination","text":"This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Uniday Studio. It will also terminate immediately if you fail to comply with any term of this EULA agreement. Upon such termination, the licenses granted by this EULA agreement will immediately terminate and you agree to stop all access and use of the Software. The provisions that by their nature continue and survive will survive any termination of this EULA agreement.","title":"Termination"},{"location":"Docs/eula/#governing-law","text":"This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of Brazil.","title":"Governing Law"},{"location":"Docs/faq/","text":"Frequently Asked Questions (FAQ) What is the Point of Cave Engine? In a nutshell: Cave Engine is focusing 100% on the usability and your experience using it. Keep it as simple as possible so even someone with zero experience with game development will be able to use it, but at the same time, keep it powerful enough to support your biggest dreams . And how we are managing to do that? We are a company called Uniday Studio that develops and teaches game dev since many years ago. We had te opportunity to reach more than two million people across the world on YouTube, teaching game dev, and we have hundreds and hundreds of students in our courses. After so many years, students and answering literally dozens of thousands of questions about the topic, we realized that a lot of people don't make their games because they found too hard to get started or use the software. We reched a conclusion that, just like a joke, if a game engine needs an explanation on how to use it, then this engine may not be that good. And that's our main principle now. Of course, some things inside a game engine may need a few tips to figure out how to use, but hours and hours of tutorials only to get started? That's not an option for us. Cave Engine is focused in provide the smallest path between you and your dream games. Is Cave Engine free? Yes. Can I sell or Redistribute my Game made using Cave Engine? Yes! Under attribution to the Cave Engine - by Uniday Studio. That's it! Can I sell or Redistribute the Cave Engine Editor? No! The Cave Engine Editor is an intellectual property of Uniday Studio and you don't have permission to sell or redistribute it. If you want/need to share the engine with someone, please use the links provided by Uniday Studio. There are plans to support 2D games? No, there is no plans to add 2D game specific features. Cave Engine is 100% focused on 3D game development. But also note that nothing avoids you to use an ortographic camera and create a 2D game using it. How can I create my Logics using Cave Engine? You can do it using Python Scripts . And be aware: There are plans to include a Visual Programming alternative. Was the entire engine written in Python? Absolutely no! All the Engine and Editor was written in C/C++ and GLSL. We just provide Python Scripting as a front end for you to easily create the logic of your games. To which Platforms can I export my game? For now, you can export your games for Windows. There are plans to support Linux and Mac in the future, but it's low priority for now. Will be possible to export the game to other platforms such as Android in the future? It's too early to answer that question precisely. For now, the focus is to make the easiest and best engine for desktop development. Once we reach that goal, we think to start porting first to WebGL (to run in a Browser) and maybe Android. But it's not even in the roadmap yet.","title":"Frequently Asked Questions (FAQ)"},{"location":"Docs/faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"Docs/faq/#what-is-the-point-of-cave-engine","text":"In a nutshell: Cave Engine is focusing 100% on the usability and your experience using it. Keep it as simple as possible so even someone with zero experience with game development will be able to use it, but at the same time, keep it powerful enough to support your biggest dreams . And how we are managing to do that? We are a company called Uniday Studio that develops and teaches game dev since many years ago. We had te opportunity to reach more than two million people across the world on YouTube, teaching game dev, and we have hundreds and hundreds of students in our courses. After so many years, students and answering literally dozens of thousands of questions about the topic, we realized that a lot of people don't make their games because they found too hard to get started or use the software. We reched a conclusion that, just like a joke, if a game engine needs an explanation on how to use it, then this engine may not be that good. And that's our main principle now. Of course, some things inside a game engine may need a few tips to figure out how to use, but hours and hours of tutorials only to get started? That's not an option for us. Cave Engine is focused in provide the smallest path between you and your dream games.","title":"What is the Point of Cave Engine?"},{"location":"Docs/faq/#is-cave-engine-free","text":"Yes.","title":"Is Cave Engine free?"},{"location":"Docs/faq/#can-i-sell-or-redistribute-my-game-made-using-cave-engine","text":"Yes! Under attribution to the Cave Engine - by Uniday Studio. That's it!","title":"Can I sell or Redistribute my Game made using Cave Engine?"},{"location":"Docs/faq/#can-i-sell-or-redistribute-the-cave-engine-editor","text":"No! The Cave Engine Editor is an intellectual property of Uniday Studio and you don't have permission to sell or redistribute it. If you want/need to share the engine with someone, please use the links provided by Uniday Studio.","title":"Can I sell or Redistribute the Cave Engine Editor?"},{"location":"Docs/faq/#there-are-plans-to-support-2d-games","text":"No, there is no plans to add 2D game specific features. Cave Engine is 100% focused on 3D game development. But also note that nothing avoids you to use an ortographic camera and create a 2D game using it.","title":"There are plans to support 2D games?"},{"location":"Docs/faq/#how-can-i-create-my-logics-using-cave-engine","text":"You can do it using Python Scripts . And be aware: There are plans to include a Visual Programming alternative.","title":"How can I create my Logics using Cave Engine?"},{"location":"Docs/faq/#was-the-entire-engine-written-in-python","text":"Absolutely no! All the Engine and Editor was written in C/C++ and GLSL. We just provide Python Scripting as a front end for you to easily create the logic of your games.","title":"Was the entire engine written in Python?"},{"location":"Docs/faq/#to-which-platforms-can-i-export-my-game","text":"For now, you can export your games for Windows. There are plans to support Linux and Mac in the future, but it's low priority for now.","title":"To which Platforms can I export my game?"},{"location":"Docs/faq/#will-be-possible-to-export-the-game-to-other-platforms-such-as-android-in-the-future","text":"It's too early to answer that question precisely. For now, the focus is to make the easiest and best engine for desktop development. Once we reach that goal, we think to start porting first to WebGL (to run in a Browser) and maybe Android. But it's not even in the roadmap yet.","title":"Will be possible to export the game to other platforms such as Android in the future?"},{"location":"Docs/releases/","text":"Development logs Welcome to the engine's development logs. If you want, also check the itch io page to see the release notes (under the Development log area): Cave Engine on itch io Cave Engine 0.9.7 (alpha) Release Notes! Say hello to the Cave Engine version 0.9.7 (alpha)! It took a while, but it's finally here. I'm very happy about how it turned out and that's thanks to you and the amazing on growth community being built around it. Talking about community, I do have some exciting news: We finally have The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here if you want to: Sweet Shelter on itch io . Of course, this one was made using the previous version (0.9.6), but Renato actually teamed up with two more people (Bruno and Murilo) and they made a second game, using a closed version of 0.9.7 (that I've released earlier to my Patrons ) and I'll probably do a video on it soon. Ralph is also doing some amazing work using the engine: Thank you everyone using the engine and involved somehow, the community is amazing! I'm excited and I really hope y'all like it as I do. So let's jump to the release notes! New Renderer! Let's start with the big features! The entire renderer was rewritten from scratch. Why? Because now it is much more PBR accurate, easy to use and adjust and the best part: more lightweight! But that's not everything... besides all that, there is a bunch of new exciting features on it: ALPHA BLENDING is here! If you've used the engine before, you know that there was zero alpha blend support (only alpha clip). Now you can prepare your .png files, because it is working like a charm! Even with particles... so say hello to your smoke. Added Mist! The good and old mist. I use to say with some friends that mist is that magical button you press to instantly make the game looks better and now you have it in Cave. Awesome! Added an Aperture variable to the camera Soon we'll have HDR, but for now, you can manually adjust the camera aperture to support higher color ranges in your scene. Old Renderer removed! Well, I'm pretty sure that with the new one, no one will gonna mist that, but it's worth mentioning. The last thing I want it to have a bunch of different and non compatible renderers in the engine at the same time (as some other GEs are doing) so I decided to remove the old one. But don't worry: it means that I'll have more time to work in the new renderer and make it even more exciting and feature complete! New Editor's Console I know, I know... the Editor already had a Console before. But now it is 100% of what it was intended to be: Python prints and errors are displayed in the Editor's Console System console is now hidden by default That means no awkward black console window floating around when you're using the engine. Everything you need will be displayed in the editor's console. But if you're really that kind of person who likes random windows floating around your monitors, you can still enable back the console in the top menu. Just keep in mind that it will probably remain empty. Animations Animations are way cooler now. Let's start by the fact that I've fixed THIS (it took me a while, but it's working!). And... Now it's possible to blend two different animations when changing the current one. Animations now have independent frames and always starts from the beginning (cheerz!) Improved the Animation Importer: Previously it was not considering more than 4 bone weights. Well, it still doesn't, but now it sorts the weights in order to get the higher influences and also renormalizes it to avoid glitches. Audio YES! Audio finally received some love. Now there is 3D sound support and you can access the audio instance being executed and do a lot of fun stuff with it: class AddSoundTest(cave.Component): def start(self, scene): # kw arguments = volume=1, fadeIn=0, loop=0 self.sound = cave.playSound(\"testSound\", fadeIn=2.0) self.timer = cave.Timer() def update(self): self.sound.volume = math.sin(self.timer.get()) * 0.5 + 0.5 events = cave.getEvents() if events.pressed(\"W\"): self.sound.pause() elif events.pressed(\"S\"): self.sound.resume() def end(self, scene): pass Including 3D audio. But if you're not into code, you can use the native new Audio Component as well! Entity Templates: Working like a charm! Entity Templates are something very special and important in the game engine. Let's say that you are making a platform game with multiple levels and a lot of enemies spread across the maps. How would you make the same player have an instance on every level? Or even more: How to use the same enemy, without a bunch of duplicates (that makes you project hard to maintain) all across the map? That's why we have entity templates: You can create a new template by right clicking in the asset browser and then assign a selected object (in the 3D view) to it. It will store the entity structure and make it available to you to use anywhere you want to. So it will be just a matter of adding an empty where you want to spawn the template and select it in the entity's Settings menu. Previously it was not working as intended but now it is! Expect ( a lot ) more on it later. Editor Tools Previously I've said that I was planning to improve the Tooling support. And I did it! I've added default Editor Tools and you can make your own if you want to! Let me explain: Now it's possible to paste python scripts inside the Editor/Tools/ folder to automatically register them into the editor. So every time you open the engine, the custom made tools will be there, ready to use. Well, which tools? Various, including the community tools! But someone had to be the first one to write a tool for it, right? Right. So I decided to start this: The world's first official Cave tool is a built in Python API! And why that's good? I'm glad you asked. The tool uses the cave module itself to retrieve the data, so it will be always up to date to your current version. So if you want to check if there is a bleeding edge but yet not documented feature in the api, this is your place! This tool if far from complete yet, but the good news is that it's source open and everyone can go to \"Editor/Tools/\" and edit it. Enjoy! Python API If you want to create some advanced logic for you game, you can use Python scripts for it (visual scripting is coming). So it's very important to provide a smooth and easy experience for you to make everything you want. That's why version 0.9.7 is full of new exciting python features! Let's start with some usability improvements: You often want to access other custom made components inside your code. Previously, there was no garantee that all the python components in your entity where initialized when running the start method, so that could lead to self.entity.get(\"YourComponent\") returning None . Now all the components are initialized first and then the start method is called. So if you have Foo and Bar attached to your entity, you can always access each other: class Foo(cave.Component): def start(self, scene): cmp = self.entity.get(\"Bar\") print(\"Bar = \", cmp) def end(self, scene): pass class Bar(cave.Component): def start(self, scene): cmp = self.entity.get(\"Foo\") print(\"Foo = \", cmp) def end(self, scene): pass But that could be not enough. Sometimes you actually want to wait until certain component initialize properly before accessing it. That's why we now have the optional method firstUpdate() . As the name suggest, it will be called once after all start(s) method run and before the regular update() . class Bar(cave.Component): def start(self, scene): print(\"Start method...\") def firstUpdate(self): print(\"FirstUpdate method...\") def update(self): # Called every frame! print(\"Update method...\") def end(self, scene): print(\"End method...\") To be honest, I can talk FOREVER about the python api improvements. Now you can grab the Mesh Component , get, set or modify its current mesh, material, animation and more! You can select the mesh, copy it to make it unique to a specific object and change as you want to. cmp = self.entity.get(\"Mesh\") # MeshComponent mesh = cmp.getMesh() mesh = mesh.getCopy() cmp.setMesh(mesh) # Do whatever you want with the mesh here! for vertex in mesh.vertices: mesh.position += cave.Vector(0, random.random(), 0) for index in mesh.indices: # For every 3 indices, we have a triangle print(index) mesh.reload() For instance, the code bellow will duplicate the material from the MeshComponent (to make it unique to that specific object) and make it pulse a random glow value, in realtime. Watch the Showcase Video : import cave import random import math class Emissive(cave.Component): def start(self, scene): self.timer = cave.Timer(random.random()*6) cmp = self.entity.get(\"Mesh\") self.mat = cmp.getMaterial() self.mat = self.mat.getCopy() cmp.setMaterial(self.mat) def update(self): c = (math.sin(self.timer.get()) + 1) / 2 self.mat.emission.set(c, c, c) def end(self, scene): pass And there is much more! Transform: lerp, untransform, unrotate Now it's possible to get python made components from python cmp = self.entity.get(\"YourOwnComponent\") . Exposed a transform.[get/set]WorldPosition() method to the Python API Exposed the CharacterComponent fields to the Python API Added a RigidBodyComponent.applyImpulse(...) method Added a MeshComponent.getAnimationLoops() method Added the MeshComponent.getAnimationProgress() method Exposed the DecalComponent to python Mouselook Component This one deserves his own section: Now there is a new default component called \"Mouselook\". It allows you to use the mouse movement to apply some specific rotation to an object. You can use it to, well, do a mouselook, but for a lot more, such as that badass \"item preview\" from Skyrim, that rotates with the mouse. Documentation The engine's documentation is still not 100% up to date (at least not by the time I'm writting this release notes), but I did a lot of improvements on it. By the way, check the previous \"Tooling\" category to see why you should not be worried about the Python API documentation anymore! Anyways, here is some changed I've made: Renamed \"engine\" to \"cave\" New homepage + theme Added Tooling examples Added a Showcase tab New Entity UI + tag UI Now the entity tab (properties) are more organized, divided into sub tabs: Components, Settings and Tags. Tag UI was redesigned as well. New \"Quit Editor\" popup menu The \"quit editor\" window was redesigned to use the engine's UI instead of the OS message dialogues and now displays a \"Cancel\" button. Git control When people started working with Cave for real, they sent me some messages regarding the \"git friendless\". In other words, it was necessary to make the engine work with git so multiple people could work in the same project at the same time. So I've made some changed to allow this: Option to expose the scripts externally, in a Scripts/ folder Exposed the Asset names in the Project Files (previously it was just the unique ID, aka a weird and huge number) I'm planning to do more things related to that, but it was a great start! Usability (UI/UX): Want to see a lot of miscellaneous improvements regarding the engine usability? Here you go! UI Text Renderer rewritten from scratch The previous UI Text was very sketchy and was not working at all in a lot of cases. Now it was completely rewritted and it's working like a charm. Highlight active asset in the Asset Browser Added a debug grid to the viewport Changed the color of the selected text (it was not visible before) Reduced the color of the tab arrow (text editor) Mesh Entity are now added with a rigid body component by default Do not change the window focus while simulating the game! Addressing the report: \"The Shift + Space makes the screen in Full mode. The problem is that when I run+jump with the character controller it keeps scaling up/down\" Removed the Delete and Duplicate icon from the Scene Graph items: The user could easily accidentally click on them. I've added a dropdown menu instead. Those options are still available using the keyboard shortcuts. Added bulk actions for the Animation Asset Increased the Sun bias range in the editor Project Manager improvements Project manager is the first window you see when you open the engine. Keep in mind that there is a bunch of other things I'm planning to make on it. Soon! Show a message when there is no projects Improve the \"new project\" layout Export Game: I did a bunch of things related to the game exporting: Fix: The engine was not copying the the folders inside the \"Lib/\" directory, causing the game to not run as a standalone (exported version). Renamed the executable to the project name (previously it was always \"Game.exe\") Removed the Python STDOUT from the runtime + hide terminal Don't allow the user to export the game without a default scene selected! I've also improved the Settings UI by adding tabs to organize the content on it. Fixes: Something very important happened recently: We started to have actual Games being made using Cave Engine . And because of that, I had to make sure that the engine was stable enough and \"bug free\". So that's why we have so many bug fixes. Good news: it's working very well now! Fix: Crash when trying to display a nullptr image (ui) Fix: Light Gizmo was not world space (when parented) Fix: Camera with 0 scale was resulting in NaN values Fix: Overlapping text when hovering some dropdowns Fix: Editor Icons + use a custom file extension Fix: Camera view not working most of the times: The camera view was a bit sketchy, most of the times, it would simply not work at all and keep using the free camera of the viewport. Specially in the runtime. Now it works just fine. Fix: Deleting an Entity Tag was crashing the engine Fix: Tools getting invalid when you stop the game Fix: glDrawElements access violation (crash) Fix: Problem when displaying multiple ColorSampler UIs in the editor Fix a typo in the PropRange UI element Fix: ColorSampler loading issue Fix: Crash when adding physics to a Folder: Personal Developer note: Yes, someone had to try to add rigid body physics to.. wel... A FOLDER! You guys are amazing finding all sorts of corner cases and I LOVE IT! Cheerz. lol Fix: View Gizmo was being activated when moving a tab around (over it): Two actions at the same time when You're moving tab + You forgot to not move cursor over 3D View Cube at the same time... Thank you Ralph for the report. Fix: Character sliding Fix: It was not possible to set a character's position Fix: Some python components where not showing in the UI Fix: It was not possible to edit two PyComponents at the same time Fix: Making it possible to always have multiple components of the same type in an entity Fix: Dropdown filter was not working Fix: Crash when you run a python script with no start method Fix: I've Hidden the Jump Height because it is not used by bullet at all: There was a character physics option called \"Jump Height\". But after a close inspection in the bullet's source code, I relized that the jump Height was not used at all... lol (that's not my fault). Bullet code - for the Nerds Fix: PythonComponent was not being properly copied when duplicated Fix: Animation issues: This one is huge... remember This Video I made sometime ago? Well... it turns out that it was my fault as well (thanks to quaternions not being normalized). But now it's fixed! No more weird rotation behaviours. Fix: Activating the RigidBody when you set something Fix: Removed the shader error exception throw Fix: Some EntityTemplate crashes Fix: Crash when iterating the childrens Fix: Entity mem leaks and mem violations Fix: Shadows disappearing when the camera is far away from the world's center Fix: It was not possible to add components in realtime (python) Fix: Ensure that the Python Components are all constructed when calling the start Fix: Crash when modifying the entity component list (during iteration) Fix: Unicode characters was not working in the game UI: For the brazilian people out there (and maybe the russians and others): Say hello to special characters in your games! Words like \"A\u00c7\u00c3O!\" and \"PA\u00c7OCA\" will be displayed properly in the game UI. Internal stuff: I've omitted all the fixes and improvements that are internal (only noticeable inside the engine's codebase), but it's worth mentioning that... well, I've removed A BUNCH of unnecessary core, redundant stuff and fixed a lot of things. Huge refactors behind this big set of updates. I really liked the way it turned out.","title":"Release Notes"},{"location":"Docs/releases/#development-logs","text":"Welcome to the engine's development logs. If you want, also check the itch io page to see the release notes (under the Development log area): Cave Engine on itch io","title":"Development logs"},{"location":"Docs/releases/#cave-engine-097-alpha-release-notes","text":"Say hello to the Cave Engine version 0.9.7 (alpha)! It took a while, but it's finally here. I'm very happy about how it turned out and that's thanks to you and the amazing on growth community being built around it. Talking about community, I do have some exciting news: We finally have The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here if you want to: Sweet Shelter on itch io . Of course, this one was made using the previous version (0.9.6), but Renato actually teamed up with two more people (Bruno and Murilo) and they made a second game, using a closed version of 0.9.7 (that I've released earlier to my Patrons ) and I'll probably do a video on it soon. Ralph is also doing some amazing work using the engine: Thank you everyone using the engine and involved somehow, the community is amazing! I'm excited and I really hope y'all like it as I do. So let's jump to the release notes!","title":"Cave Engine 0.9.7 (alpha) Release Notes!"},{"location":"Docs/releases/#new-renderer","text":"Let's start with the big features! The entire renderer was rewritten from scratch. Why? Because now it is much more PBR accurate, easy to use and adjust and the best part: more lightweight! But that's not everything... besides all that, there is a bunch of new exciting features on it: ALPHA BLENDING is here! If you've used the engine before, you know that there was zero alpha blend support (only alpha clip). Now you can prepare your .png files, because it is working like a charm! Even with particles... so say hello to your smoke. Added Mist! The good and old mist. I use to say with some friends that mist is that magical button you press to instantly make the game looks better and now you have it in Cave. Awesome! Added an Aperture variable to the camera Soon we'll have HDR, but for now, you can manually adjust the camera aperture to support higher color ranges in your scene. Old Renderer removed! Well, I'm pretty sure that with the new one, no one will gonna mist that, but it's worth mentioning. The last thing I want it to have a bunch of different and non compatible renderers in the engine at the same time (as some other GEs are doing) so I decided to remove the old one. But don't worry: it means that I'll have more time to work in the new renderer and make it even more exciting and feature complete!","title":"New Renderer!"},{"location":"Docs/releases/#new-editors-console","text":"I know, I know... the Editor already had a Console before. But now it is 100% of what it was intended to be: Python prints and errors are displayed in the Editor's Console System console is now hidden by default That means no awkward black console window floating around when you're using the engine. Everything you need will be displayed in the editor's console. But if you're really that kind of person who likes random windows floating around your monitors, you can still enable back the console in the top menu. Just keep in mind that it will probably remain empty.","title":"New Editor's Console"},{"location":"Docs/releases/#animations","text":"Animations are way cooler now. Let's start by the fact that I've fixed THIS (it took me a while, but it's working!). And... Now it's possible to blend two different animations when changing the current one. Animations now have independent frames and always starts from the beginning (cheerz!) Improved the Animation Importer: Previously it was not considering more than 4 bone weights. Well, it still doesn't, but now it sorts the weights in order to get the higher influences and also renormalizes it to avoid glitches.","title":"Animations"},{"location":"Docs/releases/#audio","text":"YES! Audio finally received some love. Now there is 3D sound support and you can access the audio instance being executed and do a lot of fun stuff with it: class AddSoundTest(cave.Component): def start(self, scene): # kw arguments = volume=1, fadeIn=0, loop=0 self.sound = cave.playSound(\"testSound\", fadeIn=2.0) self.timer = cave.Timer() def update(self): self.sound.volume = math.sin(self.timer.get()) * 0.5 + 0.5 events = cave.getEvents() if events.pressed(\"W\"): self.sound.pause() elif events.pressed(\"S\"): self.sound.resume() def end(self, scene): pass Including 3D audio. But if you're not into code, you can use the native new Audio Component as well!","title":"Audio"},{"location":"Docs/releases/#entity-templates-working-like-a-charm","text":"Entity Templates are something very special and important in the game engine. Let's say that you are making a platform game with multiple levels and a lot of enemies spread across the maps. How would you make the same player have an instance on every level? Or even more: How to use the same enemy, without a bunch of duplicates (that makes you project hard to maintain) all across the map? That's why we have entity templates: You can create a new template by right clicking in the asset browser and then assign a selected object (in the 3D view) to it. It will store the entity structure and make it available to you to use anywhere you want to. So it will be just a matter of adding an empty where you want to spawn the template and select it in the entity's Settings menu. Previously it was not working as intended but now it is! Expect ( a lot ) more on it later.","title":"Entity Templates: Working like a charm!"},{"location":"Docs/releases/#editor-tools","text":"Previously I've said that I was planning to improve the Tooling support. And I did it! I've added default Editor Tools and you can make your own if you want to! Let me explain: Now it's possible to paste python scripts inside the Editor/Tools/ folder to automatically register them into the editor. So every time you open the engine, the custom made tools will be there, ready to use. Well, which tools? Various, including the community tools! But someone had to be the first one to write a tool for it, right? Right. So I decided to start this: The world's first official Cave tool is a built in Python API! And why that's good? I'm glad you asked. The tool uses the cave module itself to retrieve the data, so it will be always up to date to your current version. So if you want to check if there is a bleeding edge but yet not documented feature in the api, this is your place! This tool if far from complete yet, but the good news is that it's source open and everyone can go to \"Editor/Tools/\" and edit it. Enjoy!","title":"Editor Tools"},{"location":"Docs/releases/#python-api","text":"If you want to create some advanced logic for you game, you can use Python scripts for it (visual scripting is coming). So it's very important to provide a smooth and easy experience for you to make everything you want. That's why version 0.9.7 is full of new exciting python features! Let's start with some usability improvements: You often want to access other custom made components inside your code. Previously, there was no garantee that all the python components in your entity where initialized when running the start method, so that could lead to self.entity.get(\"YourComponent\") returning None . Now all the components are initialized first and then the start method is called. So if you have Foo and Bar attached to your entity, you can always access each other: class Foo(cave.Component): def start(self, scene): cmp = self.entity.get(\"Bar\") print(\"Bar = \", cmp) def end(self, scene): pass class Bar(cave.Component): def start(self, scene): cmp = self.entity.get(\"Foo\") print(\"Foo = \", cmp) def end(self, scene): pass But that could be not enough. Sometimes you actually want to wait until certain component initialize properly before accessing it. That's why we now have the optional method firstUpdate() . As the name suggest, it will be called once after all start(s) method run and before the regular update() . class Bar(cave.Component): def start(self, scene): print(\"Start method...\") def firstUpdate(self): print(\"FirstUpdate method...\") def update(self): # Called every frame! print(\"Update method...\") def end(self, scene): print(\"End method...\") To be honest, I can talk FOREVER about the python api improvements. Now you can grab the Mesh Component , get, set or modify its current mesh, material, animation and more! You can select the mesh, copy it to make it unique to a specific object and change as you want to. cmp = self.entity.get(\"Mesh\") # MeshComponent mesh = cmp.getMesh() mesh = mesh.getCopy() cmp.setMesh(mesh) # Do whatever you want with the mesh here! for vertex in mesh.vertices: mesh.position += cave.Vector(0, random.random(), 0) for index in mesh.indices: # For every 3 indices, we have a triangle print(index) mesh.reload() For instance, the code bellow will duplicate the material from the MeshComponent (to make it unique to that specific object) and make it pulse a random glow value, in realtime. Watch the Showcase Video : import cave import random import math class Emissive(cave.Component): def start(self, scene): self.timer = cave.Timer(random.random()*6) cmp = self.entity.get(\"Mesh\") self.mat = cmp.getMaterial() self.mat = self.mat.getCopy() cmp.setMaterial(self.mat) def update(self): c = (math.sin(self.timer.get()) + 1) / 2 self.mat.emission.set(c, c, c) def end(self, scene): pass And there is much more! Transform: lerp, untransform, unrotate Now it's possible to get python made components from python cmp = self.entity.get(\"YourOwnComponent\") . Exposed a transform.[get/set]WorldPosition() method to the Python API Exposed the CharacterComponent fields to the Python API Added a RigidBodyComponent.applyImpulse(...) method Added a MeshComponent.getAnimationLoops() method Added the MeshComponent.getAnimationProgress() method Exposed the DecalComponent to python","title":"Python API"},{"location":"Docs/releases/#mouselook-component","text":"This one deserves his own section: Now there is a new default component called \"Mouselook\". It allows you to use the mouse movement to apply some specific rotation to an object. You can use it to, well, do a mouselook, but for a lot more, such as that badass \"item preview\" from Skyrim, that rotates with the mouse.","title":"Mouselook Component"},{"location":"Docs/releases/#documentation","text":"The engine's documentation is still not 100% up to date (at least not by the time I'm writting this release notes), but I did a lot of improvements on it. By the way, check the previous \"Tooling\" category to see why you should not be worried about the Python API documentation anymore! Anyways, here is some changed I've made: Renamed \"engine\" to \"cave\" New homepage + theme Added Tooling examples Added a Showcase tab","title":"Documentation"},{"location":"Docs/releases/#new-entity-ui-tag-ui","text":"Now the entity tab (properties) are more organized, divided into sub tabs: Components, Settings and Tags. Tag UI was redesigned as well.","title":"New Entity UI + tag UI"},{"location":"Docs/releases/#new-quit-editor-popup-menu","text":"The \"quit editor\" window was redesigned to use the engine's UI instead of the OS message dialogues and now displays a \"Cancel\" button.","title":"New \"Quit Editor\" popup menu"},{"location":"Docs/releases/#git-control","text":"When people started working with Cave for real, they sent me some messages regarding the \"git friendless\". In other words, it was necessary to make the engine work with git so multiple people could work in the same project at the same time. So I've made some changed to allow this: Option to expose the scripts externally, in a Scripts/ folder Exposed the Asset names in the Project Files (previously it was just the unique ID, aka a weird and huge number) I'm planning to do more things related to that, but it was a great start!","title":"Git control"},{"location":"Docs/releases/#usability-uiux","text":"Want to see a lot of miscellaneous improvements regarding the engine usability? Here you go! UI Text Renderer rewritten from scratch The previous UI Text was very sketchy and was not working at all in a lot of cases. Now it was completely rewritted and it's working like a charm. Highlight active asset in the Asset Browser Added a debug grid to the viewport Changed the color of the selected text (it was not visible before) Reduced the color of the tab arrow (text editor) Mesh Entity are now added with a rigid body component by default Do not change the window focus while simulating the game! Addressing the report: \"The Shift + Space makes the screen in Full mode. The problem is that when I run+jump with the character controller it keeps scaling up/down\" Removed the Delete and Duplicate icon from the Scene Graph items: The user could easily accidentally click on them. I've added a dropdown menu instead. Those options are still available using the keyboard shortcuts. Added bulk actions for the Animation Asset Increased the Sun bias range in the editor","title":"Usability (UI/UX):"},{"location":"Docs/releases/#project-manager-improvements","text":"Project manager is the first window you see when you open the engine. Keep in mind that there is a bunch of other things I'm planning to make on it. Soon! Show a message when there is no projects Improve the \"new project\" layout","title":"Project Manager improvements"},{"location":"Docs/releases/#export-game","text":"I did a bunch of things related to the game exporting: Fix: The engine was not copying the the folders inside the \"Lib/\" directory, causing the game to not run as a standalone (exported version). Renamed the executable to the project name (previously it was always \"Game.exe\") Removed the Python STDOUT from the runtime + hide terminal Don't allow the user to export the game without a default scene selected! I've also improved the Settings UI by adding tabs to organize the content on it.","title":"Export Game:"},{"location":"Docs/releases/#fixes","text":"Something very important happened recently: We started to have actual Games being made using Cave Engine . And because of that, I had to make sure that the engine was stable enough and \"bug free\". So that's why we have so many bug fixes. Good news: it's working very well now! Fix: Crash when trying to display a nullptr image (ui) Fix: Light Gizmo was not world space (when parented) Fix: Camera with 0 scale was resulting in NaN values Fix: Overlapping text when hovering some dropdowns Fix: Editor Icons + use a custom file extension Fix: Camera view not working most of the times: The camera view was a bit sketchy, most of the times, it would simply not work at all and keep using the free camera of the viewport. Specially in the runtime. Now it works just fine. Fix: Deleting an Entity Tag was crashing the engine Fix: Tools getting invalid when you stop the game Fix: glDrawElements access violation (crash) Fix: Problem when displaying multiple ColorSampler UIs in the editor Fix a typo in the PropRange UI element Fix: ColorSampler loading issue Fix: Crash when adding physics to a Folder: Personal Developer note: Yes, someone had to try to add rigid body physics to.. wel... A FOLDER! You guys are amazing finding all sorts of corner cases and I LOVE IT! Cheerz. lol Fix: View Gizmo was being activated when moving a tab around (over it): Two actions at the same time when You're moving tab + You forgot to not move cursor over 3D View Cube at the same time... Thank you Ralph for the report. Fix: Character sliding Fix: It was not possible to set a character's position Fix: Some python components where not showing in the UI Fix: It was not possible to edit two PyComponents at the same time Fix: Making it possible to always have multiple components of the same type in an entity Fix: Dropdown filter was not working Fix: Crash when you run a python script with no start method Fix: I've Hidden the Jump Height because it is not used by bullet at all: There was a character physics option called \"Jump Height\". But after a close inspection in the bullet's source code, I relized that the jump Height was not used at all... lol (that's not my fault). Bullet code - for the Nerds Fix: PythonComponent was not being properly copied when duplicated Fix: Animation issues: This one is huge... remember This Video I made sometime ago? Well... it turns out that it was my fault as well (thanks to quaternions not being normalized). But now it's fixed! No more weird rotation behaviours. Fix: Activating the RigidBody when you set something Fix: Removed the shader error exception throw Fix: Some EntityTemplate crashes Fix: Crash when iterating the childrens Fix: Entity mem leaks and mem violations Fix: Shadows disappearing when the camera is far away from the world's center Fix: It was not possible to add components in realtime (python) Fix: Ensure that the Python Components are all constructed when calling the start Fix: Crash when modifying the entity component list (during iteration) Fix: Unicode characters was not working in the game UI: For the brazilian people out there (and maybe the russians and others): Say hello to special characters in your games! Words like \"A\u00c7\u00c3O!\" and \"PA\u00c7OCA\" will be displayed properly in the game UI.","title":"Fixes:"},{"location":"Docs/releases/#internal-stuff","text":"I've omitted all the fixes and improvements that are internal (only noticeable inside the engine's codebase), but it's worth mentioning that... well, I've removed A BUNCH of unnecessary core, redundant stuff and fixed a lot of things. Huge refactors behind this big set of updates. I really liked the way it turned out.","title":"Internal stuff:"},{"location":"Docs/roadmap/","text":"Roadmap Cave Engine Alpha (Current) During this iteration the focus is to make Cave Engine as simple, usable, stable, solid and feature complete as possible. In other word, we need to make sure that everyone will be able to jump in and start making their games with the least amount of problems or difficults as possible. Here the focus will be on providing documentation, tutorials, bug fixes, build a community around it and also change and improve the UI and UX as much as we feel like it's necessary to make it as user friendly as possible. Again, from the ground up this engine needs to be friendly, easy to use and of course powerful enough to support your biggest dreams. So if something is missing to make that dream come true, here is the right time to add it! Cave Engine 1.0 Here the engine should be already stable enough and with a bunch of cool games made with it. Now it's time to keep cultivating so it can grow more and more! The attention to the usability and bug fixing still keeps the same (and this will never change), but now we have some cool new features in mind as wel.. Alpha Blending Particle System Viewport Gizmos and Tools Visual Scripting Cave Engine 2.0 Visual Shader Editing Timelines, a Cutscene Editor Terrain and Vegetation","title":"Roadmap"},{"location":"Docs/roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"Docs/roadmap/#cave-engine-alpha-current","text":"During this iteration the focus is to make Cave Engine as simple, usable, stable, solid and feature complete as possible. In other word, we need to make sure that everyone will be able to jump in and start making their games with the least amount of problems or difficults as possible. Here the focus will be on providing documentation, tutorials, bug fixes, build a community around it and also change and improve the UI and UX as much as we feel like it's necessary to make it as user friendly as possible. Again, from the ground up this engine needs to be friendly, easy to use and of course powerful enough to support your biggest dreams. So if something is missing to make that dream come true, here is the right time to add it!","title":"Cave Engine Alpha (Current)"},{"location":"Docs/roadmap/#cave-engine-10","text":"Here the engine should be already stable enough and with a bunch of cool games made with it. Now it's time to keep cultivating so it can grow more and more! The attention to the usability and bug fixing still keeps the same (and this will never change), but now we have some cool new features in mind as wel.. Alpha Blending Particle System Viewport Gizmos and Tools Visual Scripting","title":"Cave Engine 1.0"},{"location":"Docs/roadmap/#cave-engine-20","text":"Visual Shader Editing Timelines, a Cutscene Editor Terrain and Vegetation","title":"Cave Engine 2.0"},{"location":"Examples/python/","text":"Python Examples Ray Cast # Just getting the entity, transform and scene entity = self.getEntity() transform = entity.getTransform() scene = entity.getScene() # Ray Cast needs two parameters: origin and target. # It's basically where the ray starts and where it ends. # For this example, let's make the ray start at the player # position and go to its forward direction by 10 meters origin = transform.getPosition() target = origin + transform.getForwardVector() * 10 # The actual ray cast. Will return an cave.RayCastOut instance # that contains 4 variables: hit (bool), position (Vector3), # normal (Vector3), entity (cave.Entity or None) rOut = scene.rayCast(origin, target) if rOut.hit: hitEntity = rOut.entity print(\"Raycast hit with = \", hitEntity.name) point = rOut.position print(\"At this point = \", point.x, point.y, point.z) normal = rOut.normal print(\"Facing this Direction = \", normal.x, normal.y, normal.z) Mouselook Add this script to a Camera. It's recommended that you parent the camera to an object to represent the player. import cave class Mouselook(cave.Component): def __init__(self): self.mLastPos = None self.sensibility = 0.005 def start(self, scene): pass def mouselook(self): mPos = cave.getMousePosition(False) center = cave.getWindowSize() * 0.5 center = cave.Vector2(int(center.x), int(center.y)) if self.mLastPos: disp = center - mPos disp *= self.sensibility transform = self.entity.getTransform() transform.rotateOnPitch(disp.y) parent = self.entity.getParent() if parent: parentTransform = parent.getTransform() parentTransform.rotateOnRoll(disp.x) else: transform.rotateOnRoll(disp.x) cave.setMousePosition(int(center.x), int(center.y)) self.mLastPos = cave.Vector2(mPos.x, mPos.y) def update(self): events = cave.getEvents() if events.pressed(\"ESCAPE\"): cave.quitGame() self.mouselook() def end(self, scene): pass","title":"Python Scripting"},{"location":"Examples/python/#python-examples","text":"","title":"Python Examples"},{"location":"Examples/python/#ray-cast","text":"# Just getting the entity, transform and scene entity = self.getEntity() transform = entity.getTransform() scene = entity.getScene() # Ray Cast needs two parameters: origin and target. # It's basically where the ray starts and where it ends. # For this example, let's make the ray start at the player # position and go to its forward direction by 10 meters origin = transform.getPosition() target = origin + transform.getForwardVector() * 10 # The actual ray cast. Will return an cave.RayCastOut instance # that contains 4 variables: hit (bool), position (Vector3), # normal (Vector3), entity (cave.Entity or None) rOut = scene.rayCast(origin, target) if rOut.hit: hitEntity = rOut.entity print(\"Raycast hit with = \", hitEntity.name) point = rOut.position print(\"At this point = \", point.x, point.y, point.z) normal = rOut.normal print(\"Facing this Direction = \", normal.x, normal.y, normal.z)","title":"Ray Cast"},{"location":"Examples/python/#mouselook","text":"Add this script to a Camera. It's recommended that you parent the camera to an object to represent the player. import cave class Mouselook(cave.Component): def __init__(self): self.mLastPos = None self.sensibility = 0.005 def start(self, scene): pass def mouselook(self): mPos = cave.getMousePosition(False) center = cave.getWindowSize() * 0.5 center = cave.Vector2(int(center.x), int(center.y)) if self.mLastPos: disp = center - mPos disp *= self.sensibility transform = self.entity.getTransform() transform.rotateOnPitch(disp.y) parent = self.entity.getParent() if parent: parentTransform = parent.getTransform() parentTransform.rotateOnRoll(disp.x) else: transform.rotateOnRoll(disp.x) cave.setMousePosition(int(center.x), int(center.y)) self.mLastPos = cave.Vector2(mPos.x, mPos.y) def update(self): events = cave.getEvents() if events.pressed(\"ESCAPE\"): cave.quitGame() self.mouselook() def end(self, scene): pass","title":"Mouselook"},{"location":"Examples/tooling/","text":"Writting your own Tools In the Cave Engine you can write your own tools using python. They can be as simple as just executing a text to do something for you or more complex and well made tools, with a proper interface that contains buttons, sliders and whatever you want in a Tab format, that you can dock to the Editor's ui. To start writting your tools, create a new Python Script in the asset browser, open it in the text editor (double click) and delete the current startup code. Run your first Tool Let's start with a simple tool that just sets some Sun light settings: import cave # You can write the code you want to using the cave API: scene = cave.getCurrentScene() sun = scene.getSun() sun.hour = 6.15 sun.intensity = 5.0 sun.color = cave.Vector3(1.0, 0.8, 0.8) In order to run this code, simply go to \"Editor Tools..\" and then \"Run Script\": It will run and change the sun settings, as expected. Note that you can use print(...) here to debug your stuff as well. Have fun! Create a Tab and Interface for your Tool Now that you already know how to run simple scripts like that, it's time to understand how to do some a bit more advanced ones. So let's start talking about a tool with its own Tab docked in the editor, with a proper interface with buttons, sliders and so on. Here is a screenshot showing that in action. The code in the left generated the tab highlighted in red: Here is a simple code that produces a similar result and can be used as a starting point for your own tools: import cave import caveui as ui class Example(ui.DebugTab): def __init__(self): super().__init__() self.counter = 0 def draw(self): ui.text(\"Hello, world!\") ui.separator() self.counter = ui.prop(\"Counter\", self.counter) if ui.button(\"Increase counter (+1)\"): self.counter += 1 In order to run that and register the Tab to the ui, go to the \"Editor Tools...\" option and open the \"Register Tab...\" sub menu. It will automatically identify all the classes in the code that inherits from the base class caveui.DebugTab and show there. Simply click in the one you want to in order to register it.","title":"Writting your own Tools"},{"location":"Examples/tooling/#writting-your-own-tools","text":"In the Cave Engine you can write your own tools using python. They can be as simple as just executing a text to do something for you or more complex and well made tools, with a proper interface that contains buttons, sliders and whatever you want in a Tab format, that you can dock to the Editor's ui. To start writting your tools, create a new Python Script in the asset browser, open it in the text editor (double click) and delete the current startup code.","title":"Writting your own Tools"},{"location":"Examples/tooling/#run-your-first-tool","text":"Let's start with a simple tool that just sets some Sun light settings: import cave # You can write the code you want to using the cave API: scene = cave.getCurrentScene() sun = scene.getSun() sun.hour = 6.15 sun.intensity = 5.0 sun.color = cave.Vector3(1.0, 0.8, 0.8) In order to run this code, simply go to \"Editor Tools..\" and then \"Run Script\": It will run and change the sun settings, as expected. Note that you can use print(...) here to debug your stuff as well. Have fun!","title":"Run your first Tool"},{"location":"Examples/tooling/#create-a-tab-and-interface-for-your-tool","text":"Now that you already know how to run simple scripts like that, it's time to understand how to do some a bit more advanced ones. So let's start talking about a tool with its own Tab docked in the editor, with a proper interface with buttons, sliders and so on. Here is a screenshot showing that in action. The code in the left generated the tab highlighted in red: Here is a simple code that produces a similar result and can be used as a starting point for your own tools: import cave import caveui as ui class Example(ui.DebugTab): def __init__(self): super().__init__() self.counter = 0 def draw(self): ui.text(\"Hello, world!\") ui.separator() self.counter = ui.prop(\"Counter\", self.counter) if ui.button(\"Increase counter (+1)\"): self.counter += 1 In order to run that and register the Tab to the ui, go to the \"Editor Tools...\" option and open the \"Register Tab...\" sub menu. It will automatically identify all the classes in the code that inherits from the base class caveui.DebugTab and show there. Simply click in the one you want to in order to register it.","title":"Create a Tab and Interface for your Tool"},{"location":"PythonAPI/cave_module/","text":"Cave Module General Functions General game engine related functions and global variables. cave.getEvents() -> cave.Events cave.getDeltaTime() -> float You can use the deltaTime to multiply your variables before moving or rotating an entity, so the action will be consistent independently of the current FPS the game is running on. cave.getMousePosition() -> cave.Vector2 cave.setMousePosition(int x, int y) cave.getWindowSize() -> cave.Vector2 cave.quitGame() -> None cave.getCurrentScene() -> cave.Scene cave.setScene(sceneName : str) -> None cave.restartCurrentScene() -> None cave.Events How to use this class: events = cave.getEvents() if events.pressed(\"W\"): print(\"The user pressed the key W!\") if events.released(\"MOUSE_LEFT\"): print(\"The user released the left mouse button!\") Note: Do not instantiate a new instance of this class, you should always use the one provided by the cave.getEvents() function. Methods pressed(event : str) -> bool Returns True if the user just pressed the event key or False if not. active(event : str) -> bool Always returns True while the user is pressing the event key or False if not. released(event : str) -> bool Returns True if the user just released the event key or False if not. cave.Entity Variables name : str Methods kill() hasTag(tag : str) -> bool add(component : cave.Component) get(component : str) -> cave.Component getAll(component : str) -> list(cave.Component) getScene() -> cave.Scene getParent() -> cave.Entity getChildren() -> list(cave.Entity) getTransform() -> cave.TransformComponent getID() -> int cave.RayCastOut Variables hit : bool position : cave.Vector3 normal : cave.Vector3 entity : cave.Entity cave.Scene Methods newEntity() -> cave.Entity add(entity : cave.Entity) -> cave.Entity addFromTemplate(templateName : str, overrideTransform=True) -> cave.Entity The scene.add(entity) method is used to add an entity you manually build by yourself in the code. Most of the times it's not exactly what you want. That's why there is a scene.addFromTemplate(name) alternative: Given an Entity Template name, the engine will construct a new entity for you followying that template. Both methods returns the added entity for convenience. remove(entity : cave.Entity) rayCast(origin : cave.Vector3, target : cave.Vector3) -> cave.RayCastOut getSun() -> cave.Sun getEntity(id : int) -> cave.Entity getEntity(name : str) -> cave.Entity Note: Time complexity of getting an Entity by name (string) is O(n) and by ID is O(1) . In other words: get by name is way slower than by ID so it's recommended to store the entity ID and use it as much as you can. Also, when you have multiple entities with the same name in the scene, it will always return the first entity found (and this result may be non deterministic - in other words the result may vary). cave.Sun Variables hour : float # 0.0 to 24.0 angle : float # 0.0 to 360.0 color : cave.Vector3 intensity : float cave.Timer Methods get() -> float set(value : float) reset() cave.Component Variables entity : cave.Entity Methods start(scene : cave.Scene) update() end(scene : cave.Scene) reload() The reload() method will end() the component and then start() it again. It's useful because some components like the Mesh and the Light, for optimization purposes, pre cache the data and only changes it during the start.","title":"Cave Module"},{"location":"PythonAPI/cave_module/#cave-module","text":"","title":"Cave Module"},{"location":"PythonAPI/cave_module/#general-functions","text":"General game engine related functions and global variables. cave.getEvents() -> cave.Events cave.getDeltaTime() -> float You can use the deltaTime to multiply your variables before moving or rotating an entity, so the action will be consistent independently of the current FPS the game is running on. cave.getMousePosition() -> cave.Vector2 cave.setMousePosition(int x, int y) cave.getWindowSize() -> cave.Vector2 cave.quitGame() -> None cave.getCurrentScene() -> cave.Scene cave.setScene(sceneName : str) -> None cave.restartCurrentScene() -> None","title":"General Functions"},{"location":"PythonAPI/cave_module/#caveevents","text":"How to use this class: events = cave.getEvents() if events.pressed(\"W\"): print(\"The user pressed the key W!\") if events.released(\"MOUSE_LEFT\"): print(\"The user released the left mouse button!\") Note: Do not instantiate a new instance of this class, you should always use the one provided by the cave.getEvents() function.","title":"cave.Events"},{"location":"PythonAPI/cave_module/#methods","text":"pressed(event : str) -> bool Returns True if the user just pressed the event key or False if not. active(event : str) -> bool Always returns True while the user is pressing the event key or False if not. released(event : str) -> bool Returns True if the user just released the event key or False if not.","title":"Methods"},{"location":"PythonAPI/cave_module/#caveentity","text":"","title":"cave.Entity"},{"location":"PythonAPI/cave_module/#variables","text":"name : str","title":"Variables"},{"location":"PythonAPI/cave_module/#methods_1","text":"kill() hasTag(tag : str) -> bool add(component : cave.Component) get(component : str) -> cave.Component getAll(component : str) -> list(cave.Component) getScene() -> cave.Scene getParent() -> cave.Entity getChildren() -> list(cave.Entity) getTransform() -> cave.TransformComponent getID() -> int","title":"Methods"},{"location":"PythonAPI/cave_module/#caveraycastout","text":"","title":"cave.RayCastOut"},{"location":"PythonAPI/cave_module/#variables_1","text":"hit : bool position : cave.Vector3 normal : cave.Vector3 entity : cave.Entity","title":"Variables"},{"location":"PythonAPI/cave_module/#cavescene","text":"","title":"cave.Scene"},{"location":"PythonAPI/cave_module/#methods_2","text":"newEntity() -> cave.Entity add(entity : cave.Entity) -> cave.Entity addFromTemplate(templateName : str, overrideTransform=True) -> cave.Entity The scene.add(entity) method is used to add an entity you manually build by yourself in the code. Most of the times it's not exactly what you want. That's why there is a scene.addFromTemplate(name) alternative: Given an Entity Template name, the engine will construct a new entity for you followying that template. Both methods returns the added entity for convenience. remove(entity : cave.Entity) rayCast(origin : cave.Vector3, target : cave.Vector3) -> cave.RayCastOut getSun() -> cave.Sun getEntity(id : int) -> cave.Entity getEntity(name : str) -> cave.Entity Note: Time complexity of getting an Entity by name (string) is O(n) and by ID is O(1) . In other words: get by name is way slower than by ID so it's recommended to store the entity ID and use it as much as you can. Also, when you have multiple entities with the same name in the scene, it will always return the first entity found (and this result may be non deterministic - in other words the result may vary).","title":"Methods"},{"location":"PythonAPI/cave_module/#cavesun","text":"","title":"cave.Sun"},{"location":"PythonAPI/cave_module/#variables_2","text":"hour : float # 0.0 to 24.0 angle : float # 0.0 to 360.0 color : cave.Vector3 intensity : float","title":"Variables"},{"location":"PythonAPI/cave_module/#cavetimer","text":"","title":"cave.Timer"},{"location":"PythonAPI/cave_module/#methods_3","text":"get() -> float set(value : float) reset()","title":"Methods"},{"location":"PythonAPI/cave_module/#cavecomponent","text":"","title":"cave.Component"},{"location":"PythonAPI/cave_module/#variables_3","text":"entity : cave.Entity","title":"Variables"},{"location":"PythonAPI/cave_module/#methods_4","text":"start(scene : cave.Scene) update() end(scene : cave.Scene) reload() The reload() method will end() the component and then start() it again. It's useful because some components like the Mesh and the Light, for optimization purposes, pre cache the data and only changes it during the start.","title":"Methods"},{"location":"PythonAPI/components/","text":"Components cave.TransformComponent Variables position : cave.Vector3 scale : cave.Vector3 Note that you can't get/set the rotation using regular variables as you can with the position and scale . That's due to the way the engine works internally. So use the getters and setters for euler angles or quaternions to rotate as you need to. You can see the details bellow. Sample code (as it would be in the update method of a Component): [...] def update(self): transform = self.entity.getTransform() # Modifying the current euler angles by adding 0.1 on the Y axis: euler = transform.getEuler() euler.y += 0.1 transform.setEuler(euler) # or you can use this to ROTATE the object: # (will produce the same result as the approach above) transform.rotate(0, 0.1, 0) [...] # Last but no least, you can also do this to SET the euler: # (note that this approach will not produce the same result # as the two others presented above. This one wil SET the # rotation to [0, 0, 0]) transform.setEuler(0, 0, 0) Methods getEuler() -> cave.Vector3 setEuler(euler : cave.Vector3) setEuler(x : float, y : float, z : float) getQuaternion() -> cave.Quaternion setQuaternion(quaternion : cave.Quaternion) setQuaternion(x : float, y : float, z : float, w: float) getMatrix() -> cave.Matrix4 setMatrix(mat : cave.Matrix4) rotate(x : float, y : float, z : float) move(x : float, y : float, z : float, local = True) rotateOnAxis(angle : float, axis : cave.Vector3) rotateOnPitch(angle : float) rotateOnYaw(angle : float) rotateOnRoll(angle : float) applyLocalMovement(x : float, y : float, z : float) getPitch() -> float getYaw() -> float getRoll() -> float getForwardVector() -> cave.Vector3 getRightVector() -> cave.Vector3 getUpVector() -> cave.Vector3 lookAt(direction : cave.Vector3, up = cave.Vector3(0, 1, 0)) rotateVector(vec : cave.Vector3) -> cave.Vector3 transformVector(vec : cave.Vector3) -> cave.Vector3 cave.MeshComponent Methods setAnimation(animation : string) cave.LightComponent You can adjust various light parameters. Here is a sample code that makes the light color pulse using some timers and the python native math.sin() function: import cave import math import random class PulsingLight(cave.Component): def start(self, scene): self.speed = 2.0 # Creating some timers with a random value to sample from self.colorX = cave.Timer(random.random()) self.colorY = cave.Timer(random.random()) self.colorZ = cave.Timer(random.random()) def compute(self, value): # Maps the timer into a sin curve ranged [0 - 1] return (math.sin(value * self.speed) + 1) / 2 def update(self): light = self.entity.get(\"Light Component\") light.color.x = self.compute(self.colorX.get()) light.color.y = self.compute(self.colorY.get()) light.color.z = self.compute(self.colorZ.get()) print(light.color.x, light.color.y, light.color.z) # Don't forget to reload the light, otherwise it will not be updated: light.reload() def end(self, scene): pass Variables NOTE: Lights are pre cached so the changes you made in the following parameters will not be effective (applied to the light) until you call the reload() method. color : cave.Vector3 radius : float intensity : float cave.UIElementComponent Variables text : str position : cave.UIVector scale : cave.UIVector text : str Methods isHovered() -> bool cave.RigidBodyComponent Variables alwaysActive : bool linearVelocity : cave.Vector3 angularVelocity : cave.Vector3 angularFactor : cave.Vector3 Methods getCollisions() -> list(cave.Entity) collidedWith(tag : string) -> bool applyTorque(x : float, y : float, z : float) applyForce(x : float, y : float, z : float, location : cave.Vector3) isDynamic() -> bool setMass(value : float)","title":"Components"},{"location":"PythonAPI/components/#components","text":"","title":"Components"},{"location":"PythonAPI/components/#cavetransformcomponent","text":"","title":"cave.TransformComponent"},{"location":"PythonAPI/components/#variables","text":"position : cave.Vector3 scale : cave.Vector3 Note that you can't get/set the rotation using regular variables as you can with the position and scale . That's due to the way the engine works internally. So use the getters and setters for euler angles or quaternions to rotate as you need to. You can see the details bellow. Sample code (as it would be in the update method of a Component): [...] def update(self): transform = self.entity.getTransform() # Modifying the current euler angles by adding 0.1 on the Y axis: euler = transform.getEuler() euler.y += 0.1 transform.setEuler(euler) # or you can use this to ROTATE the object: # (will produce the same result as the approach above) transform.rotate(0, 0.1, 0) [...] # Last but no least, you can also do this to SET the euler: # (note that this approach will not produce the same result # as the two others presented above. This one wil SET the # rotation to [0, 0, 0]) transform.setEuler(0, 0, 0)","title":"Variables"},{"location":"PythonAPI/components/#methods","text":"getEuler() -> cave.Vector3 setEuler(euler : cave.Vector3) setEuler(x : float, y : float, z : float) getQuaternion() -> cave.Quaternion setQuaternion(quaternion : cave.Quaternion) setQuaternion(x : float, y : float, z : float, w: float) getMatrix() -> cave.Matrix4 setMatrix(mat : cave.Matrix4) rotate(x : float, y : float, z : float) move(x : float, y : float, z : float, local = True) rotateOnAxis(angle : float, axis : cave.Vector3) rotateOnPitch(angle : float) rotateOnYaw(angle : float) rotateOnRoll(angle : float) applyLocalMovement(x : float, y : float, z : float) getPitch() -> float getYaw() -> float getRoll() -> float getForwardVector() -> cave.Vector3 getRightVector() -> cave.Vector3 getUpVector() -> cave.Vector3 lookAt(direction : cave.Vector3, up = cave.Vector3(0, 1, 0)) rotateVector(vec : cave.Vector3) -> cave.Vector3 transformVector(vec : cave.Vector3) -> cave.Vector3","title":"Methods"},{"location":"PythonAPI/components/#cavemeshcomponent","text":"","title":"cave.MeshComponent"},{"location":"PythonAPI/components/#methods_1","text":"setAnimation(animation : string)","title":"Methods"},{"location":"PythonAPI/components/#cavelightcomponent","text":"You can adjust various light parameters. Here is a sample code that makes the light color pulse using some timers and the python native math.sin() function: import cave import math import random class PulsingLight(cave.Component): def start(self, scene): self.speed = 2.0 # Creating some timers with a random value to sample from self.colorX = cave.Timer(random.random()) self.colorY = cave.Timer(random.random()) self.colorZ = cave.Timer(random.random()) def compute(self, value): # Maps the timer into a sin curve ranged [0 - 1] return (math.sin(value * self.speed) + 1) / 2 def update(self): light = self.entity.get(\"Light Component\") light.color.x = self.compute(self.colorX.get()) light.color.y = self.compute(self.colorY.get()) light.color.z = self.compute(self.colorZ.get()) print(light.color.x, light.color.y, light.color.z) # Don't forget to reload the light, otherwise it will not be updated: light.reload() def end(self, scene): pass","title":"cave.LightComponent"},{"location":"PythonAPI/components/#variables_1","text":"NOTE: Lights are pre cached so the changes you made in the following parameters will not be effective (applied to the light) until you call the reload() method. color : cave.Vector3 radius : float intensity : float","title":"Variables"},{"location":"PythonAPI/components/#caveuielementcomponent","text":"","title":"cave.UIElementComponent"},{"location":"PythonAPI/components/#variables_2","text":"text : str position : cave.UIVector scale : cave.UIVector text : str","title":"Variables"},{"location":"PythonAPI/components/#methods_2","text":"isHovered() -> bool","title":"Methods"},{"location":"PythonAPI/components/#caverigidbodycomponent","text":"","title":"cave.RigidBodyComponent"},{"location":"PythonAPI/components/#variables_3","text":"alwaysActive : bool linearVelocity : cave.Vector3 angularVelocity : cave.Vector3 angularFactor : cave.Vector3","title":"Variables"},{"location":"PythonAPI/components/#methods_3","text":"getCollisions() -> list(cave.Entity) collidedWith(tag : string) -> bool applyTorque(x : float, y : float, z : float) applyForce(x : float, y : float, z : float, location : cave.Vector3) isDynamic() -> bool setMass(value : float)","title":"Methods"},{"location":"PythonAPI/eventNames/","text":"Event Names See cave.Events for more details. Event Name Key \"0\" 0 \"1\" 1 \"2\" 2 \"3\" 3 \"4\" 4 \"5\" 5 \"6\" 6 \"7\" 7 \"8\" 8 \"9\" 9 \"A\" A \"AC_BACK\" Ac Back \"AC_BOOKMARKS\" Ac Bookmarks \"AC_FORWARD\" Ac Forward \"AC_HOME\" Ac Home \"AC_REFRESH\" Ac Refresh \"AC_SEARCH\" Ac Search \"AC_STOP\" Ac Stop \"AGAIN\" Again \"ALTERASE\" Alterase \"AMPERSAND\" Ampersand \"APPLICATION\" Application \"ASTERISK\" Asterisk \"AT\" At \"AUDIOMUTE\" Audiomute \"AUDIONEXT\" Audionext \"AUDIOPLAY\" Audioplay \"AUDIOPREV\" Audioprev \"AUDIOSTOP\" Audiostop \"B\" B \"BACKQUOTE\" Backquote \"BACKSLASH\" Backslash \"BACKSPACE\" Backspace \"BRIGHTNESSDOWN\" Brightnessdown \"BRIGHTNESSUP\" Brightnessup \"C\" C \"CALCULATOR\" Calculator \"CANCEL\" Cancel \"CAPSLOCK\" Capslock \"CARET\" Caret \"CLEAR\" Clear \"CLEARAGAIN\" Clearagain \"COLON\" Colon \"COMMA\" Comma \"COMPUTER\" Computer \"COPY\" Copy \"CRSEL\" Crsel \"CURRENCYSUBUNIT\" Currencysubunit \"CURRENCYUNIT\" Currencyunit \"CUT\" Cut \"D\" D \"DECIMALSEPARATOR\" Decimalseparator \"DELETE\" Delete \"DISPLAYSWITCH\" Displayswitch \"DOLLAR\" Dollar \"DOWN\" Down \"E\" E \"EJECT\" Eject \"END\" End \"EQUALS\" Equals \"ESCAPE\" Escape \"EXCLAIM\" Exclaim \"EXECUTE_\" Execute \"EXSEL\" Exsel \"F\" F \"F1\" F1 \"F10\" F10 \"F11\" F11 \"F12\" F12 \"F13\" F13 \"F14\" F14 \"F15\" F15 \"F16\" F16 \"F17\" F17 \"F18\" F18 \"F19\" F19 \"F2\" F2 \"F20\" F20 \"F21\" F21 \"F22\" F22 \"F23\" F23 \"F24\" F24 \"F3\" F3 \"F4\" F4 \"F5\" F5 \"F6\" F6 \"F7\" F7 \"F8\" F8 \"F9\" F9 \"FIND\" Find \"G\" G \"GREATER\" Greater \"H\" H \"HASH\" Hash \"HELP\" Help \"HOME\" Home \"I\" I \"INSERT\" Insert \"J\" J \"K\" K \"KBDILLUMDOWN\" Kbdillumdown \"KBDILLUMTOGGLE\" Kbdillumtoggle \"KBDILLUMUP\" Kbdillumup \"KP_0\" Kp 0 \"KP_00\" Kp 00 \"KP_000\" Kp 000 \"KP_1\" Kp 1 \"KP_2\" Kp 2 \"KP_3\" Kp 3 \"KP_4\" Kp 4 \"KP_5\" Kp 5 \"KP_6\" Kp 6 \"KP_7\" Kp 7 \"KP_8\" Kp 8 \"KP_9\" Kp 9 \"KP_A\" Kp A \"KP_AMPERSAND\" Kp Ampersand \"KP_AT\" Kp At \"KP_B\" Kp B \"KP_BACKSPACE\" Kp Backspace \"KP_BINARY\" Kp Binary \"KP_C\" Kp C \"KP_CLEAR\" Kp Clear \"KP_CLEARENTRY\" Kp Clearentry \"KP_COLON\" Kp Colon \"KP_COMMA\" Kp Comma \"KP_D\" Kp D \"KP_DBLAMPERSAND\" Kp Dblampersand \"KP_DBLVERTICALBAR\" Kp Dblverticalbar \"KP_DECIMAL\" Kp Decimal \"KP_DIVIDE\" Kp Divide \"KP_E\" Kp E \"KP_ENTER\" Kp Enter \"KP_EQUALS\" Kp Equals \"KP_EQUALSAS400\" Kp Equalsas400 \"KP_EXCLAM\" Kp Exclam \"KP_F\" Kp F \"KP_GREATER\" Kp Greater \"KP_HASH\" Kp Hash \"KP_HEXADECIMAL\" Kp Hexadecimal \"KP_LEFTBRACE\" Kp Leftbrace \"KP_LEFTPAREN\" Kp Leftparen \"KP_LESS\" Kp Less \"KP_MEMADD\" Kp Memadd \"KP_MEMCLEAR\" Kp Memclear \"KP_MEMDIVIDE\" Kp Memdivide \"KP_MEMMULTIPLY\" Kp Memmultiply \"KP_MEMRECALL\" Kp Memrecall \"KP_MEMSTORE\" Kp Memstore \"KP_MEMSUBTRACT\" Kp Memsubtract \"KP_MINUS\" Kp Minus \"KP_MULTIPLY\" Kp Multiply \"KP_OCTAL\" Kp Octal \"KP_PERCENT\" Kp Percent \"KP_PERIOD\" Kp Period \"KP_PLUS\" Kp Plus \"KP_PLUSMINUS\" Kp Plusminus \"KP_POWER\" Kp Power \"KP_RIGHTBRACE\" Kp Rightbrace \"KP_RIGHTPAREN\" Kp Rightparen \"KP_SPACE\" Kp Space \"KP_TAB\" Kp Tab \"KP_VERTICALBAR\" Kp Verticalbar \"KP_XOR\" Kp Xor \"L\" L \"LALT\" Lalt \"LCTRL\" Lctrl \"LEFT\" Left \"LEFTBRACKET\" Leftbracket \"LEFTPAREN\" Leftparen \"LESS\" Less \"LGUI\" Lgui \"LSHIFT\" Lshift \"M\" M \"MAIL\" Mail \"MEDIASELECT\" Mediaselect \"MENU\" Menu \"MINUS\" Minus \"MODE\" Mode \"MOUSE_LEFT\" Mouse Left \"MOUSE_MIDDLE\" Mouse Middle \"MOUSE_RIGHT\" Mouse Right \"MUTE\" Mute \"N\" N \"NUMLOCKCLEAR\" Numlockclear \"O\" O \"OPER\" Oper \"OUT\" Out \"P\" P \"PAGEDOWN\" Pagedown \"PAGEUP\" Pageup \"PASTE\" Paste \"PAUSE\" Pause \"PERCENT\" Percent \"PERIOD\" Period \"PLUS\" Plus \"POWER\" Power \"PRINTSCREEN\" Printscreen \"PRIOR\" Prior \"Q\" Q \"QUESTION\" Question \"QUOTE\" Quote \"QUOTEDBL\" Quotedbl \"R\" R \"RALT\" Ralt \"RCTRL\" Rctrl \"RETURN\" Return \"RETURN2\" Return2 \"RGUI\" Rgui \"RIGHT\" Right \"RIGHTBRACKET\" Rightbracket \"RIGHTPAREN\" Rightparen \"RSHIFT\" Rshift \"S\" S \"SCROLLLOCK\" Scrolllock \"SELECT\" Select \"SEMICOLON\" Semicolon \"SEPARATOR\" Separator \"SIZE\" Size \"SLASH\" Slash \"SLEEP\" Sleep \"SPACE\" Space \"STOP\" Stop \"SYSREQ\" Sysreq \"T\" T \"TAB\" Tab \"THOUSANDSSEPARATOR\" Thousandsseparator \"U\" U \"UNDO\" Undo \"UNKNOWN\" Unknown \"UP\" Up \"V\" V \"VOLUMEDOWN\" Volumedown \"VOLUMEUP\" Volumeup \"W\" W \"WWW\" Www \"X\" X \"Y\" Y \"Z\" Z","title":"Event Names"},{"location":"PythonAPI/eventNames/#event-names","text":"See cave.Events for more details. Event Name Key \"0\" 0 \"1\" 1 \"2\" 2 \"3\" 3 \"4\" 4 \"5\" 5 \"6\" 6 \"7\" 7 \"8\" 8 \"9\" 9 \"A\" A \"AC_BACK\" Ac Back \"AC_BOOKMARKS\" Ac Bookmarks \"AC_FORWARD\" Ac Forward \"AC_HOME\" Ac Home \"AC_REFRESH\" Ac Refresh \"AC_SEARCH\" Ac Search \"AC_STOP\" Ac Stop \"AGAIN\" Again \"ALTERASE\" Alterase \"AMPERSAND\" Ampersand \"APPLICATION\" Application \"ASTERISK\" Asterisk \"AT\" At \"AUDIOMUTE\" Audiomute \"AUDIONEXT\" Audionext \"AUDIOPLAY\" Audioplay \"AUDIOPREV\" Audioprev \"AUDIOSTOP\" Audiostop \"B\" B \"BACKQUOTE\" Backquote \"BACKSLASH\" Backslash \"BACKSPACE\" Backspace \"BRIGHTNESSDOWN\" Brightnessdown \"BRIGHTNESSUP\" Brightnessup \"C\" C \"CALCULATOR\" Calculator \"CANCEL\" Cancel \"CAPSLOCK\" Capslock \"CARET\" Caret \"CLEAR\" Clear \"CLEARAGAIN\" Clearagain \"COLON\" Colon \"COMMA\" Comma \"COMPUTER\" Computer \"COPY\" Copy \"CRSEL\" Crsel \"CURRENCYSUBUNIT\" Currencysubunit \"CURRENCYUNIT\" Currencyunit \"CUT\" Cut \"D\" D \"DECIMALSEPARATOR\" Decimalseparator \"DELETE\" Delete \"DISPLAYSWITCH\" Displayswitch \"DOLLAR\" Dollar \"DOWN\" Down \"E\" E \"EJECT\" Eject \"END\" End \"EQUALS\" Equals \"ESCAPE\" Escape \"EXCLAIM\" Exclaim \"EXECUTE_\" Execute \"EXSEL\" Exsel \"F\" F \"F1\" F1 \"F10\" F10 \"F11\" F11 \"F12\" F12 \"F13\" F13 \"F14\" F14 \"F15\" F15 \"F16\" F16 \"F17\" F17 \"F18\" F18 \"F19\" F19 \"F2\" F2 \"F20\" F20 \"F21\" F21 \"F22\" F22 \"F23\" F23 \"F24\" F24 \"F3\" F3 \"F4\" F4 \"F5\" F5 \"F6\" F6 \"F7\" F7 \"F8\" F8 \"F9\" F9 \"FIND\" Find \"G\" G \"GREATER\" Greater \"H\" H \"HASH\" Hash \"HELP\" Help \"HOME\" Home \"I\" I \"INSERT\" Insert \"J\" J \"K\" K \"KBDILLUMDOWN\" Kbdillumdown \"KBDILLUMTOGGLE\" Kbdillumtoggle \"KBDILLUMUP\" Kbdillumup \"KP_0\" Kp 0 \"KP_00\" Kp 00 \"KP_000\" Kp 000 \"KP_1\" Kp 1 \"KP_2\" Kp 2 \"KP_3\" Kp 3 \"KP_4\" Kp 4 \"KP_5\" Kp 5 \"KP_6\" Kp 6 \"KP_7\" Kp 7 \"KP_8\" Kp 8 \"KP_9\" Kp 9 \"KP_A\" Kp A \"KP_AMPERSAND\" Kp Ampersand \"KP_AT\" Kp At \"KP_B\" Kp B \"KP_BACKSPACE\" Kp Backspace \"KP_BINARY\" Kp Binary \"KP_C\" Kp C \"KP_CLEAR\" Kp Clear \"KP_CLEARENTRY\" Kp Clearentry \"KP_COLON\" Kp Colon \"KP_COMMA\" Kp Comma \"KP_D\" Kp D \"KP_DBLAMPERSAND\" Kp Dblampersand \"KP_DBLVERTICALBAR\" Kp Dblverticalbar \"KP_DECIMAL\" Kp Decimal \"KP_DIVIDE\" Kp Divide \"KP_E\" Kp E \"KP_ENTER\" Kp Enter \"KP_EQUALS\" Kp Equals \"KP_EQUALSAS400\" Kp Equalsas400 \"KP_EXCLAM\" Kp Exclam \"KP_F\" Kp F \"KP_GREATER\" Kp Greater \"KP_HASH\" Kp Hash \"KP_HEXADECIMAL\" Kp Hexadecimal \"KP_LEFTBRACE\" Kp Leftbrace \"KP_LEFTPAREN\" Kp Leftparen \"KP_LESS\" Kp Less \"KP_MEMADD\" Kp Memadd \"KP_MEMCLEAR\" Kp Memclear \"KP_MEMDIVIDE\" Kp Memdivide \"KP_MEMMULTIPLY\" Kp Memmultiply \"KP_MEMRECALL\" Kp Memrecall \"KP_MEMSTORE\" Kp Memstore \"KP_MEMSUBTRACT\" Kp Memsubtract \"KP_MINUS\" Kp Minus \"KP_MULTIPLY\" Kp Multiply \"KP_OCTAL\" Kp Octal \"KP_PERCENT\" Kp Percent \"KP_PERIOD\" Kp Period \"KP_PLUS\" Kp Plus \"KP_PLUSMINUS\" Kp Plusminus \"KP_POWER\" Kp Power \"KP_RIGHTBRACE\" Kp Rightbrace \"KP_RIGHTPAREN\" Kp Rightparen \"KP_SPACE\" Kp Space \"KP_TAB\" Kp Tab \"KP_VERTICALBAR\" Kp Verticalbar \"KP_XOR\" Kp Xor \"L\" L \"LALT\" Lalt \"LCTRL\" Lctrl \"LEFT\" Left \"LEFTBRACKET\" Leftbracket \"LEFTPAREN\" Leftparen \"LESS\" Less \"LGUI\" Lgui \"LSHIFT\" Lshift \"M\" M \"MAIL\" Mail \"MEDIASELECT\" Mediaselect \"MENU\" Menu \"MINUS\" Minus \"MODE\" Mode \"MOUSE_LEFT\" Mouse Left \"MOUSE_MIDDLE\" Mouse Middle \"MOUSE_RIGHT\" Mouse Right \"MUTE\" Mute \"N\" N \"NUMLOCKCLEAR\" Numlockclear \"O\" O \"OPER\" Oper \"OUT\" Out \"P\" P \"PAGEDOWN\" Pagedown \"PAGEUP\" Pageup \"PASTE\" Paste \"PAUSE\" Pause \"PERCENT\" Percent \"PERIOD\" Period \"PLUS\" Plus \"POWER\" Power \"PRINTSCREEN\" Printscreen \"PRIOR\" Prior \"Q\" Q \"QUESTION\" Question \"QUOTE\" Quote \"QUOTEDBL\" Quotedbl \"R\" R \"RALT\" Ralt \"RCTRL\" Rctrl \"RETURN\" Return \"RETURN2\" Return2 \"RGUI\" Rgui \"RIGHT\" Right \"RIGHTBRACKET\" Rightbracket \"RIGHTPAREN\" Rightparen \"RSHIFT\" Rshift \"S\" S \"SCROLLLOCK\" Scrolllock \"SELECT\" Select \"SEMICOLON\" Semicolon \"SEPARATOR\" Separator \"SIZE\" Size \"SLASH\" Slash \"SLEEP\" Sleep \"SPACE\" Space \"STOP\" Stop \"SYSREQ\" Sysreq \"T\" T \"TAB\" Tab \"THOUSANDSSEPARATOR\" Thousandsseparator \"U\" U \"UNDO\" Undo \"UNKNOWN\" Unknown \"UP\" Up \"V\" V \"VOLUMEDOWN\" Volumedown \"VOLUMEUP\" Volumeup \"W\" W \"WWW\" Www \"X\" X \"Y\" Y \"Z\" Z","title":"Event Names"},{"location":"PythonAPI/math/","text":"Math cave Functions normalized(vec : cave.Vector3) -> cave.Vector3 length(vec : cave.Vector3) -> float Vector Classes Cave Engine provides wrappers to low level C++ vector classes and operations. Initialization Example Here is an initialization example to get started: # Default constructor: vec = cave.Vector() # Intialize the vector with (0, 0): myVec1 = cave.Vector2(0) # Regular (x, y) constructor for the 2D Vector: myVec2 = cave.Vector2(0, 1) # Copy the vector: myVec3 = cave.Vector3(myVec2) Supported Vector Operations You can do all sorts of operations using vectors: Operation Usage == if vecA == vecB: ... + vec = vecA + vecB += vec += vecB - vec = vecA - vecB -= vec -= vecB * vec = vecB * 50.0 * vec = 50.0 * vecB *= vec *= 100.0 Including operations between a cave.Vector3 and an cave.Quaternion : Operation Usage * vec = vec * quaterion * vec = quaterion * vecB *= vec *= quaterion cave.Vector2 Variables x : float y : float Note: You can also access the x, y parameters by using s, t or u, v . cave.Vector3 Variables x : float y : float z : float Note: You can also access the x, y, z parameters by using r, g, b as an acronym for the color channels Red , Green and Blue . cave.Vector4 Variables x : float y : float z : float w : float Note: You can also access the x, y, z, w parameters by using r, g, b, a as an acronym for the color channels Red , Green , Blue and Alpha . cave.Quaternion Quaternions, just like the vectors, are low level implementations that supports all sorts of operations ( ==, +, +=, -, -=, *, *= ). Variables x : float y : float z : float w : float cave.UIVector The cave.UIVector is a different vector, used specifically for the in Game User Interface (Game UI). It needs to be a different type of vector because it also takes into account the anchoring and if the element is relative (or not) to it's parent. If the vector is relative, the X, Y values will be represented with a [0-1] ranged float number (percentage). If not, it will be represented by two ints for the pixels. Variables anchoringX : int anchoringY : int The supported anchoring values are: -1, 0, 1 . Methods isRelativeX() -> bool isRelativeY() -> bool getX(parentScale = 1.0) -> float getY(parentScale = 1.0) -> float setPixelX(value : int) setPixelY(value : int) setPixel(x : int, y : int) setRelativeX(value : float) setRelativeY(value : float) setRelative(x : float, y : float)","title":"Math"},{"location":"PythonAPI/math/#math","text":"","title":"Math"},{"location":"PythonAPI/math/#cave","text":"","title":"cave"},{"location":"PythonAPI/math/#functions","text":"normalized(vec : cave.Vector3) -> cave.Vector3 length(vec : cave.Vector3) -> float","title":"Functions"},{"location":"PythonAPI/math/#vector-classes","text":"Cave Engine provides wrappers to low level C++ vector classes and operations.","title":"Vector Classes"},{"location":"PythonAPI/math/#initialization-example","text":"Here is an initialization example to get started: # Default constructor: vec = cave.Vector() # Intialize the vector with (0, 0): myVec1 = cave.Vector2(0) # Regular (x, y) constructor for the 2D Vector: myVec2 = cave.Vector2(0, 1) # Copy the vector: myVec3 = cave.Vector3(myVec2)","title":"Initialization Example"},{"location":"PythonAPI/math/#supported-vector-operations","text":"You can do all sorts of operations using vectors: Operation Usage == if vecA == vecB: ... + vec = vecA + vecB += vec += vecB - vec = vecA - vecB -= vec -= vecB * vec = vecB * 50.0 * vec = 50.0 * vecB *= vec *= 100.0 Including operations between a cave.Vector3 and an cave.Quaternion : Operation Usage * vec = vec * quaterion * vec = quaterion * vecB *= vec *= quaterion","title":"Supported Vector Operations"},{"location":"PythonAPI/math/#cavevector2","text":"","title":"cave.Vector2"},{"location":"PythonAPI/math/#variables","text":"x : float y : float Note: You can also access the x, y parameters by using s, t or u, v .","title":"Variables"},{"location":"PythonAPI/math/#cavevector3","text":"","title":"cave.Vector3"},{"location":"PythonAPI/math/#variables_1","text":"x : float y : float z : float Note: You can also access the x, y, z parameters by using r, g, b as an acronym for the color channels Red , Green and Blue .","title":"Variables"},{"location":"PythonAPI/math/#cavevector4","text":"","title":"cave.Vector4"},{"location":"PythonAPI/math/#variables_2","text":"x : float y : float z : float w : float Note: You can also access the x, y, z, w parameters by using r, g, b, a as an acronym for the color channels Red , Green , Blue and Alpha .","title":"Variables"},{"location":"PythonAPI/math/#cavequaternion","text":"Quaternions, just like the vectors, are low level implementations that supports all sorts of operations ( ==, +, +=, -, -=, *, *= ).","title":"cave.Quaternion"},{"location":"PythonAPI/math/#variables_3","text":"x : float y : float z : float w : float","title":"Variables"},{"location":"PythonAPI/math/#caveuivector","text":"The cave.UIVector is a different vector, used specifically for the in Game User Interface (Game UI). It needs to be a different type of vector because it also takes into account the anchoring and if the element is relative (or not) to it's parent. If the vector is relative, the X, Y values will be represented with a [0-1] ranged float number (percentage). If not, it will be represented by two ints for the pixels.","title":"cave.UIVector"},{"location":"PythonAPI/math/#variables_4","text":"anchoringX : int anchoringY : int The supported anchoring values are: -1, 0, 1 .","title":"Variables"},{"location":"PythonAPI/math/#methods","text":"isRelativeX() -> bool isRelativeY() -> bool getX(parentScale = 1.0) -> float getY(parentScale = 1.0) -> float setPixelX(value : int) setPixelY(value : int) setPixel(x : int, y : int) setRelativeX(value : float) setRelativeY(value : float) setRelative(x : float, y : float)","title":"Methods"},{"location":"Showcase/games/","text":"Games Powered by Cave In this section you'll find good examples of what is possible to do using Cave Engine . Sweet Shelter The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here: Sweet Shelter on itch io Ralph! Ralph is also doing some amazing work using the engine: He was one of the first active Cave Engine user, way before it was even named cave. Thank you!","title":"Games Made with Cave"},{"location":"Showcase/games/#games-powered-by-cave","text":"In this section you'll find good examples of what is possible to do using Cave Engine .","title":"Games Powered by Cave"},{"location":"Showcase/games/#sweet-shelter","text":"The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here: Sweet Shelter on itch io","title":"Sweet Shelter"},{"location":"Showcase/games/#ralph","text":"Ralph is also doing some amazing work using the engine: He was one of the first active Cave Engine user, way before it was even named cave. Thank you!","title":"Ralph!"}]}