{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Cave Engine's Documentation (Use the top menu to navigate in the categories) Cave Engine is a Simple 3D desktop Game Engine scriptable in Python. In this website you'll find the documentation you need to get started with the scripting in the engine and also some useful information such as the future roadmap and license. Download the Engine You can check the details and download the engine using this link: Download the Cave Engine 0.9.7 If you want to download the latest engine version (0.9.8) , please consider joining out discord server below. Our Discord Server If you want to talk about the engine, leave some suggestions, comments or get some help from the community, feel free to join us: Our Discord - In English Our Discord - In Portuguese (Brazil) Note that at the moment we have a portuguese and an english discord so you can feel free to join the one you're more confortable with.","title":"Home"},{"location":"#welcome-to-cave-engines-documentation","text":"(Use the top menu to navigate in the categories) Cave Engine is a Simple 3D desktop Game Engine scriptable in Python. In this website you'll find the documentation you need to get started with the scripting in the engine and also some useful information such as the future roadmap and license.","title":"Welcome to Cave Engine's Documentation"},{"location":"#download-the-engine","text":"You can check the details and download the engine using this link: Download the Cave Engine 0.9.7 If you want to download the latest engine version (0.9.8) , please consider joining out discord server below.","title":"Download the Engine"},{"location":"#our-discord-server","text":"If you want to talk about the engine, leave some suggestions, comments or get some help from the community, feel free to join us: Our Discord - In English Our Discord - In Portuguese (Brazil) Note that at the moment we have a portuguese and an english discord so you can feel free to join the one you're more confortable with.","title":"Our Discord Server"},{"location":"Docs/eula/","text":"In a Nutshell: Cave Engine consists in two parts : The Cave Engine Editor and everything it requires to run. The end-product \" Game \" generated by the editor. The Cave Engine Editor is an intellectual property of Uniday Studio and you have a personal, non-transferable, non-exclusive licence to use the Cave Engine Editor software on your devices. You're not allowed to share, modify or redistribute it in any forms other than the ones provided by Uniday Studio. The Game generated by the Cave Engine Editor can be redistributed (even commercially) uner the collowing term: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. Including the phrase: \"Made using Cave Engine - from Uniday Studio\" in the project and license, in a visible and easily foundable place is enough. Remember that the name Uniday Studio is a registered trademark and you are not allowed to use it to endorse your projects in any forms. End-User License Agreement (EULA) of Cave Engine This End-User License Agreement (\"EULA\") is a legal agreement between you and Uniday Studio . This EULA agreement governs your acquisition and use of our Cave Engine software (\"Software\") directly from Uniday Studio or indirectly through a Uniday Studio authorized reseller or distributor (a \"Reseller\"). Our Privacy Policy was created by the Privacy Policy Generator. Please read this EULA agreement carefully before completing the installation process and using the Cave Engine software. It provides a license to use the Cave Engine software and contains warranty information and liability disclaimers. If you register for a free trial of the Cave Engine software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Cave Engine software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Uniday Studio herewith regardless of whether other software is referred to or described herein. The terms also apply to any Uniday Studio updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply. License Grant Uniday Studio hereby grants you a personal, non-transferable, non-exclusive licence to use the Cave Engine software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Cave Engine software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Cave Engine software. Uniday Studios also hereby grants you the rights to redistribute the end-product \"Game\" generated by the editor, including for commercial purposes, under the following terms: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. The exported Game can not include a copy of the Cave Engine Editor . Not use a license that forces this software to be open source or change its license (such as GPL). Your project (game) can be source open but the Cave Engine Editor software can't be forced to. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose, except with the generated Game . Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Uniday Studio considers is a breach of this EULA agreement Intellectual Property and Ownership Uniday Studio shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Uniday Studio. Uniday Studio reserves the right to grant licences to use the Software to third parties. Termination This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Uniday Studio. It will also terminate immediately if you fail to comply with any term of this EULA agreement. Upon such termination, the licenses granted by this EULA agreement will immediately terminate and you agree to stop all access and use of the Software. The provisions that by their nature continue and survive will survive any termination of this EULA agreement. Governing Law This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of Brazil.","title":"License (EULA)"},{"location":"Docs/eula/#in-a-nutshell","text":"Cave Engine consists in two parts : The Cave Engine Editor and everything it requires to run. The end-product \" Game \" generated by the editor. The Cave Engine Editor is an intellectual property of Uniday Studio and you have a personal, non-transferable, non-exclusive licence to use the Cave Engine Editor software on your devices. You're not allowed to share, modify or redistribute it in any forms other than the ones provided by Uniday Studio. The Game generated by the Cave Engine Editor can be redistributed (even commercially) uner the collowing term: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. Including the phrase: \"Made using Cave Engine - from Uniday Studio\" in the project and license, in a visible and easily foundable place is enough. Remember that the name Uniday Studio is a registered trademark and you are not allowed to use it to endorse your projects in any forms.","title":"In a Nutshell:"},{"location":"Docs/eula/#end-user-license-agreement-eula-of-cave-engine","text":"This End-User License Agreement (\"EULA\") is a legal agreement between you and Uniday Studio . This EULA agreement governs your acquisition and use of our Cave Engine software (\"Software\") directly from Uniday Studio or indirectly through a Uniday Studio authorized reseller or distributor (a \"Reseller\"). Our Privacy Policy was created by the Privacy Policy Generator. Please read this EULA agreement carefully before completing the installation process and using the Cave Engine software. It provides a license to use the Cave Engine software and contains warranty information and liability disclaimers. If you register for a free trial of the Cave Engine software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Cave Engine software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Uniday Studio herewith regardless of whether other software is referred to or described herein. The terms also apply to any Uniday Studio updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply.","title":"End-User License Agreement (EULA) of Cave Engine"},{"location":"Docs/eula/#license-grant","text":"Uniday Studio hereby grants you a personal, non-transferable, non-exclusive licence to use the Cave Engine software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Cave Engine software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Cave Engine software. Uniday Studios also hereby grants you the rights to redistribute the end-product \"Game\" generated by the editor, including for commercial purposes, under the following terms: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. The exported Game can not include a copy of the Cave Engine Editor . Not use a license that forces this software to be open source or change its license (such as GPL). Your project (game) can be source open but the Cave Engine Editor software can't be forced to. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose, except with the generated Game . Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Uniday Studio considers is a breach of this EULA agreement","title":"License Grant"},{"location":"Docs/eula/#intellectual-property-and-ownership","text":"Uniday Studio shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Uniday Studio. Uniday Studio reserves the right to grant licences to use the Software to third parties.","title":"Intellectual Property and Ownership"},{"location":"Docs/eula/#termination","text":"This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Uniday Studio. It will also terminate immediately if you fail to comply with any term of this EULA agreement. Upon such termination, the licenses granted by this EULA agreement will immediately terminate and you agree to stop all access and use of the Software. The provisions that by their nature continue and survive will survive any termination of this EULA agreement.","title":"Termination"},{"location":"Docs/eula/#governing-law","text":"This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of Brazil.","title":"Governing Law"},{"location":"Docs/faq/","text":"Frequently Asked Questions (FAQ) What is the Point of Cave Engine? In a nutshell: Cave Engine is focusing 100% on the usability and your experience using it. Keep it as simple as possible so even someone with zero experience with game development will be able to use it, but at the same time, keep it powerful enough to support your biggest dreams . And how are we managing to do that? We are a company called Uniday Studio that develops and teaches game dev since many years ago. We had te opportunity to reach more than two million people across the world on YouTube, teaching game dev, and we have hundreds and hundreds of students in our courses. After so many years, students and answering literally dozens of thousands of questions about the topic, we realized that a lot of people don't make their games because they found too hard to get started or use the software. We reched a conclusion that, just like a joke, if a game engine needs an explanation on how to use it, then this engine may not be that good. And that's our main principle now. Of course, some things inside a game engine may need a few tips to figure out how to use, but hours and hours of tutorials only to get started? That's not an option for us. Cave Engine is focused in provide the smallest path between you and your dream games. Is Cave Engine free? At this point, you can either wait for the Free Releases or you can get Cave Engine PRO , that will grant you early access to it and some exclusive features. Can I sell or Redistribute my Game made using Cave Engine? Yes! Under attribution to the Cave Engine - by Uniday Studio. That's it! Can I sell or Redistribute the Cave Engine Editor? No! The Cave Engine Editor is an intellectual property of Uniday Studio and you don't have permission to sell or redistribute it. If you want/need to share the engine with someone, please use the links provided by Uniday Studio. Are there plans to support 2D Games ? No, there is no plans to add 2D game specific features. Cave Engine is 100% focused on 3D game development. But also note that nothing avoids you to use an ortographic camera and create a 2D game using it. How can I create my Logics using Cave Engine? You can do it using Python Scripts . A Visual Scripting alternative is work in progress, soon it will be out. Was the entire engine written in Python? Absolutely no! All the Engine and Editor was written in C/C++ and GLSL. We just provide Python Scripting as a front end for you to easily create the logic of your games. To which Platforms can I export my game? For now, you can export your games for Windows. There are plans to support Linux and Mac in the future, but it's low priority for now. Will be possible to export the game to other platforms such as Android in the future? It's too early to answer that question precisely. For now, the focus is to make the easiest and best engine for desktop development. Once we reach that goal, we think to start porting first to WebGL (to run in a Browser) and maybe Android. But it's not even in the roadmap yet.","title":"Frequently Asked Questions (FAQ)"},{"location":"Docs/faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"Docs/faq/#what-is-the-point-of-cave-engine","text":"In a nutshell: Cave Engine is focusing 100% on the usability and your experience using it. Keep it as simple as possible so even someone with zero experience with game development will be able to use it, but at the same time, keep it powerful enough to support your biggest dreams . And how are we managing to do that? We are a company called Uniday Studio that develops and teaches game dev since many years ago. We had te opportunity to reach more than two million people across the world on YouTube, teaching game dev, and we have hundreds and hundreds of students in our courses. After so many years, students and answering literally dozens of thousands of questions about the topic, we realized that a lot of people don't make their games because they found too hard to get started or use the software. We reched a conclusion that, just like a joke, if a game engine needs an explanation on how to use it, then this engine may not be that good. And that's our main principle now. Of course, some things inside a game engine may need a few tips to figure out how to use, but hours and hours of tutorials only to get started? That's not an option for us. Cave Engine is focused in provide the smallest path between you and your dream games.","title":"What is the Point of Cave Engine?"},{"location":"Docs/faq/#is-cave-engine-free","text":"At this point, you can either wait for the Free Releases or you can get Cave Engine PRO , that will grant you early access to it and some exclusive features.","title":"Is Cave Engine free?"},{"location":"Docs/faq/#can-i-sell-or-redistribute-my-game-made-using-cave-engine","text":"Yes! Under attribution to the Cave Engine - by Uniday Studio. That's it!","title":"Can I sell or Redistribute my Game made using Cave Engine?"},{"location":"Docs/faq/#can-i-sell-or-redistribute-the-cave-engine-editor","text":"No! The Cave Engine Editor is an intellectual property of Uniday Studio and you don't have permission to sell or redistribute it. If you want/need to share the engine with someone, please use the links provided by Uniday Studio.","title":"Can I sell or Redistribute the Cave Engine Editor?"},{"location":"Docs/faq/#are-there-plans-to-support-2d-games","text":"No, there is no plans to add 2D game specific features. Cave Engine is 100% focused on 3D game development. But also note that nothing avoids you to use an ortographic camera and create a 2D game using it.","title":"Are there plans to support 2D Games?"},{"location":"Docs/faq/#how-can-i-create-my-logics-using-cave-engine","text":"You can do it using Python Scripts . A Visual Scripting alternative is work in progress, soon it will be out.","title":"How can I create my Logics using Cave Engine?"},{"location":"Docs/faq/#was-the-entire-engine-written-in-python","text":"Absolutely no! All the Engine and Editor was written in C/C++ and GLSL. We just provide Python Scripting as a front end for you to easily create the logic of your games.","title":"Was the entire engine written in Python?"},{"location":"Docs/faq/#to-which-platforms-can-i-export-my-game","text":"For now, you can export your games for Windows. There are plans to support Linux and Mac in the future, but it's low priority for now.","title":"To which Platforms can I export my game?"},{"location":"Docs/faq/#will-be-possible-to-export-the-game-to-other-platforms-such-as-android-in-the-future","text":"It's too early to answer that question precisely. For now, the focus is to make the easiest and best engine for desktop development. Once we reach that goal, we think to start porting first to WebGL (to run in a Browser) and maybe Android. But it's not even in the roadmap yet.","title":"Will be possible to export the game to other platforms such as Android in the future?"},{"location":"Docs/roadmap/","text":"Roadmap Cave Engine Beta (Current) During this development iteration (until version 1.0.0), the focus is to make Cave Engine as simple, usable, stable, solid and feature complete as possible. In other word, we need to make sure that everyone will be able to jump in and start making their games with the least amount of problems or difficults as possible. The focus here will be on providing documentation, tutorials, bug fixes, build a community around it and also change and improve the UI and UX as much as we feel like it's necessary to make it as user friendly as possible. Again, from the ground up this engine needs to be friendly, easy to use and of course powerful enough to support your biggest dreams. So if something is missing to make that dream come true, here is the right time to add it! Cave Engine 1.X Here the engine should be already stable enough and with a bunch of cool games made with it. Now it's time to keep cultivating so it can grow more and more! The attention to the usability and bug fixing still keeps the same (and this will never change), but now we have some cool new features in mind as well. Feature Status Alpha Blending Done! Particle System Done! (experimental) Viewport Gizmos and Tools Done! Visual Scripting Work in Progress New Game UI System TODO Joystick and Keyboard Mapping System TODO Cave Engine 2.X Feature Status Visual Shader Editing TODO Timelines, Cutscene Editor Already in early stages of development. There is a high change of this to be moved to the top of the priority lists, since it's something very useful and that is being required a lot by Uniday Studio to be able to develop some of our in house games. Terrain and Vegetation TODO Cave Engine 3.X? We don't know yet when those features will be out, but it's worth mentioning that they're on the scope, just not for now... Maybe in some years, who knows! Feature Status Android Support TODO . This features relies on having a new build system that's able to compile the engine for android. We'll also need to revisit the OpenGL backends to make sure that they only use OpenGL ES features. Serialization needs to be checked as well. Web Support TODO . This features relies on having a new build system that's able to compile the engine with emscripten. We'll also need to revisit the OpenGL backends to make sure that they only use WebGL compatible features. Serialization needs to be checked as well. Cave Engine PRO We also have solid plans for Cave Engine PRO exclusive features. Here is the list of the confirmed ones: Feature Status Procedural Generation Tools Work in Progress . I'm working on a procedural system that mainly focus on city generation (buildings, roads, etc). The goal is to allow you to create cities as easy as you can imagine.","title":"Roadmap"},{"location":"Docs/roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"Docs/roadmap/#cave-engine-beta-current","text":"During this development iteration (until version 1.0.0), the focus is to make Cave Engine as simple, usable, stable, solid and feature complete as possible. In other word, we need to make sure that everyone will be able to jump in and start making their games with the least amount of problems or difficults as possible. The focus here will be on providing documentation, tutorials, bug fixes, build a community around it and also change and improve the UI and UX as much as we feel like it's necessary to make it as user friendly as possible. Again, from the ground up this engine needs to be friendly, easy to use and of course powerful enough to support your biggest dreams. So if something is missing to make that dream come true, here is the right time to add it!","title":"Cave Engine Beta (Current)"},{"location":"Docs/roadmap/#cave-engine-1x","text":"Here the engine should be already stable enough and with a bunch of cool games made with it. Now it's time to keep cultivating so it can grow more and more! The attention to the usability and bug fixing still keeps the same (and this will never change), but now we have some cool new features in mind as well. Feature Status Alpha Blending Done! Particle System Done! (experimental) Viewport Gizmos and Tools Done! Visual Scripting Work in Progress New Game UI System TODO Joystick and Keyboard Mapping System TODO","title":"Cave Engine 1.X"},{"location":"Docs/roadmap/#cave-engine-2x","text":"Feature Status Visual Shader Editing TODO Timelines, Cutscene Editor Already in early stages of development. There is a high change of this to be moved to the top of the priority lists, since it's something very useful and that is being required a lot by Uniday Studio to be able to develop some of our in house games. Terrain and Vegetation TODO","title":"Cave Engine 2.X"},{"location":"Docs/roadmap/#cave-engine-3x","text":"We don't know yet when those features will be out, but it's worth mentioning that they're on the scope, just not for now... Maybe in some years, who knows! Feature Status Android Support TODO . This features relies on having a new build system that's able to compile the engine for android. We'll also need to revisit the OpenGL backends to make sure that they only use OpenGL ES features. Serialization needs to be checked as well. Web Support TODO . This features relies on having a new build system that's able to compile the engine with emscripten. We'll also need to revisit the OpenGL backends to make sure that they only use WebGL compatible features. Serialization needs to be checked as well.","title":"Cave Engine 3.X?"},{"location":"Docs/roadmap/#cave-engine-pro","text":"We also have solid plans for Cave Engine PRO exclusive features. Here is the list of the confirmed ones: Feature Status Procedural Generation Tools Work in Progress . I'm working on a procedural system that mainly focus on city generation (buildings, roads, etc). The goal is to allow you to create cities as easy as you can imagine.","title":"Cave Engine PRO"},{"location":"Docs/Releases/v097/","text":"Development logs Welcome to the engine's development logs. If you want, also check the itch io page to see the release notes (under the Development log area): Cave Engine on itch io Cave Engine 0.9.7 (alpha) Release Notes! Say hello to the Cave Engine version 0.9.7 (alpha)! It took a while, but it's finally here. I'm very happy about how it turned out and that's thanks to you and the amazing on growth community being built around it. Talking about community, I do have some exciting news: We finally have The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here if you want to: Sweet Shelter on itch io . Of course, this one was made using the previous version (0.9.6), but Renato actually teamed up with two more people (Bruno and Murilo) and they made a second game, using a closed version of 0.9.7 (that I've released earlier to my Patrons ) and I'll probably do a video on it soon. Ralph is also doing some amazing work using the engine: Thank you everyone using the engine and involved somehow, the community is amazing! I'm excited and I really hope y'all like it as I do. So let's jump to the release notes! New Renderer! Let's start with the big features! The entire renderer was rewritten from scratch. Why? Because now it is much more PBR accurate, easy to use and adjust and the best part: more lightweight! But that's not everything... besides all that, there is a bunch of new exciting features on it: ALPHA BLENDING is here! If you've used the engine before, you know that there was zero alpha blend support (only alpha clip). Now you can prepare your .png files, because it is working like a charm! Even with particles... so say hello to your smoke. Added Mist! The good and old mist. I use to say with some friends that mist is that magical button you press to instantly make the game looks better and now you have it in Cave. Awesome! Added an Aperture variable to the camera Soon we'll have HDR, but for now, you can manually adjust the camera aperture to support higher color ranges in your scene. Old Renderer removed! Well, I'm pretty sure that with the new one, no one will gonna mist that, but it's worth mentioning. The last thing I want it to have a bunch of different and non compatible renderers in the engine at the same time (as some other GEs are doing) so I decided to remove the old one. But don't worry: it means that I'll have more time to work in the new renderer and make it even more exciting and feature complete! New Editor's Console I know, I know... the Editor already had a Console before. But now it is 100% of what it was intended to be: Python prints and errors are displayed in the Editor's Console System console is now hidden by default That means no awkward black console window floating around when you're using the engine. Everything you need will be displayed in the editor's console. But if you're really that kind of person who likes random windows floating around your monitors, you can still enable back the console in the top menu. Just keep in mind that it will probably remain empty. Animations Animations are way cooler now. Let's start by the fact that I've fixed THIS (it took me a while, but it's working!). And... Now it's possible to blend two different animations when changing the current one. Animations now have independent frames and always starts from the beginning (cheerz!) Improved the Animation Importer: Previously it was not considering more than 4 bone weights. Well, it still doesn't, but now it sorts the weights in order to get the higher influences and also renormalizes it to avoid glitches. Audio YES! Audio finally received some love. Now there is 3D sound support and you can access the audio instance being executed and do a lot of fun stuff with it: class AddSoundTest(cave.Component): def start(self, scene): # kw arguments = volume=1, fadeIn=0, loop=0 self.sound = cave.playSound(\"testSound\", fadeIn=2.0) self.timer = cave.Timer() def update(self): self.sound.volume = math.sin(self.timer.get()) * 0.5 + 0.5 events = cave.getEvents() if events.pressed(\"W\"): self.sound.pause() elif events.pressed(\"S\"): self.sound.resume() def end(self, scene): pass Including 3D audio. But if you're not into code, you can use the native new Audio Component as well! Entity Templates: Working like a charm! Entity Templates are something very special and important in the game engine. Let's say that you are making a platform game with multiple levels and a lot of enemies spread across the maps. How would you make the same player have an instance on every level? Or even more: How to use the same enemy, without a bunch of duplicates (that makes you project hard to maintain) all across the map? That's why we have entity templates: You can create a new template by right clicking in the asset browser and then assign a selected object (in the 3D view) to it. It will store the entity structure and make it available to you to use anywhere you want to. So it will be just a matter of adding an empty where you want to spawn the template and select it in the entity's Settings menu. Previously it was not working as intended but now it is! Expect ( a lot ) more on it later. Editor Tools Previously I've said that I was planning to improve the Tooling support. And I did it! I've added default Editor Tools and you can make your own if you want to! Let me explain: Now it's possible to paste python scripts inside the Editor/Tools/ folder to automatically register them into the editor. So every time you open the engine, the custom made tools will be there, ready to use. Well, which tools? Various, including the community tools! But someone had to be the first one to write a tool for it, right? Right. So I decided to start this: The world's first official Cave tool is a built in Python API! And why that's good? I'm glad you asked. The tool uses the cave module itself to retrieve the data, so it will be always up to date to your current version. So if you want to check if there is a bleeding edge but yet not documented feature in the api, this is your place! This tool if far from complete yet, but the good news is that it's source open and everyone can go to \"Editor/Tools/\" and edit it. Enjoy! Python API If you want to create some advanced logic for you game, you can use Python scripts for it (visual scripting is coming). So it's very important to provide a smooth and easy experience for you to make everything you want. That's why version 0.9.7 is full of new exciting python features! Let's start with some usability improvements: You often want to access other custom made components inside your code. Previously, there was no garantee that all the python components in your entity where initialized when running the start method, so that could lead to self.entity.get(\"YourComponent\") returning None . Now all the components are initialized first and then the start method is called. So if you have Foo and Bar attached to your entity, you can always access each other: class Foo(cave.Component): def start(self, scene): cmp = self.entity.get(\"Bar\") print(\"Bar = \", cmp) def end(self, scene): pass class Bar(cave.Component): def start(self, scene): cmp = self.entity.get(\"Foo\") print(\"Foo = \", cmp) def end(self, scene): pass But that could be not enough. Sometimes you actually want to wait until certain component initialize properly before accessing it. That's why we now have the optional method firstUpdate() . As the name suggest, it will be called once after all start(s) method run and before the regular update() . class Bar(cave.Component): def start(self, scene): print(\"Start method...\") def firstUpdate(self): print(\"FirstUpdate method...\") def update(self): # Called every frame! print(\"Update method...\") def end(self, scene): print(\"End method...\") To be honest, I can talk FOREVER about the python api improvements. Now you can grab the Mesh Component , get, set or modify its current mesh, material, animation and more! You can select the mesh, copy it to make it unique to a specific object and change as you want to. cmp = self.entity.get(\"Mesh\") # MeshComponent mesh = cmp.getMesh() mesh = mesh.getCopy() cmp.setMesh(mesh) # Do whatever you want with the mesh here! for vertex in mesh.vertices: mesh.position += cave.Vector(0, random.random(), 0) for index in mesh.indices: # For every 3 indices, we have a triangle print(index) mesh.reload() For instance, the code bellow will duplicate the material from the MeshComponent (to make it unique to that specific object) and make it pulse a random glow value, in realtime. Watch the Showcase Video : import cave import random import math class Emissive(cave.Component): def start(self, scene): self.timer = cave.Timer(random.random()*6) cmp = self.entity.get(\"Mesh\") self.mat = cmp.getMaterial() self.mat = self.mat.getCopy() cmp.setMaterial(self.mat) def update(self): c = (math.sin(self.timer.get()) + 1) / 2 self.mat.emission.set(c, c, c) def end(self, scene): pass And there is much more! Transform: lerp, untransform, unrotate Now it's possible to get python made components from python cmp = self.entity.get(\"YourOwnComponent\") . Exposed a transform.[get/set]WorldPosition() method to the Python API Exposed the CharacterComponent fields to the Python API Added a RigidBodyComponent.applyImpulse(...) method Added a MeshComponent.getAnimationLoops() method Added the MeshComponent.getAnimationProgress() method Exposed the DecalComponent to python Mouselook Component This one deserves his own section: Now there is a new default component called \"Mouselook\". It allows you to use the mouse movement to apply some specific rotation to an object. You can use it to, well, do a mouselook, but for a lot more, such as that badass \"item preview\" from Skyrim, that rotates with the mouse. Documentation The engine's documentation is still not 100% up to date (at least not by the time I'm writting this release notes), but I did a lot of improvements on it. By the way, check the previous \"Tooling\" category to see why you should not be worried about the Python API documentation anymore! Anyways, here is some changed I've made: Renamed \"engine\" to \"cave\" New homepage + theme Added Tooling examples Added a Showcase tab New Entity UI + tag UI Now the entity tab (properties) are more organized, divided into sub tabs: Components, Settings and Tags. Tag UI was redesigned as well. New \"Quit Editor\" popup menu The \"quit editor\" window was redesigned to use the engine's UI instead of the OS message dialogues and now displays a \"Cancel\" button. Git control When people started working with Cave for real, they sent me some messages regarding the \"git friendless\". In other words, it was necessary to make the engine work with git so multiple people could work in the same project at the same time. So I've made some changed to allow this: Option to expose the scripts externally, in a Scripts/ folder Exposed the Asset names in the Project Files (previously it was just the unique ID, aka a weird and huge number) I'm planning to do more things related to that, but it was a great start! Usability (UI/UX): Want to see a lot of miscellaneous improvements regarding the engine usability? Here you go! UI Text Renderer rewritten from scratch The previous UI Text was very sketchy and was not working at all in a lot of cases. Now it was completely rewritted and it's working like a charm. Highlight active asset in the Asset Browser Added a debug grid to the viewport Changed the color of the selected text (it was not visible before) Reduced the color of the tab arrow (text editor) Mesh Entity are now added with a rigid body component by default Do not change the window focus while simulating the game! Addressing the report: \"The Shift + Space makes the screen in Full mode. The problem is that when I run+jump with the character controller it keeps scaling up/down\" Removed the Delete and Duplicate icon from the Scene Graph items: The user could easily accidentally click on them. I've added a dropdown menu instead. Those options are still available using the keyboard shortcuts. Added bulk actions for the Animation Asset Increased the Sun bias range in the editor Project Manager improvements Project manager is the first window you see when you open the engine. Keep in mind that there is a bunch of other things I'm planning to make on it. Soon! Show a message when there is no projects Improve the \"new project\" layout Export Game: I did a bunch of things related to the game exporting: Fix: The engine was not copying the the folders inside the \"Lib/\" directory, causing the game to not run as a standalone (exported version). Renamed the executable to the project name (previously it was always \"Game.exe\") Removed the Python STDOUT from the runtime + hide terminal Don't allow the user to export the game without a default scene selected! I've also improved the Settings UI by adding tabs to organize the content on it. Fixes: Something very important happened recently: We started to have actual Games being made using Cave Engine . And because of that, I had to make sure that the engine was stable enough and \"bug free\". So that's why we have so many bug fixes. Good news: it's working very well now! Fix: Crash when trying to display a nullptr image (ui) Fix: Light Gizmo was not world space (when parented) Fix: Camera with 0 scale was resulting in NaN values Fix: Overlapping text when hovering some dropdowns Fix: Editor Icons + use a custom file extension Fix: Camera view not working most of the times: The camera view was a bit sketchy, most of the times, it would simply not work at all and keep using the free camera of the viewport. Specially in the runtime. Now it works just fine. Fix: Deleting an Entity Tag was crashing the engine Fix: Tools getting invalid when you stop the game Fix: glDrawElements access violation (crash) Fix: Problem when displaying multiple ColorSampler UIs in the editor Fix a typo in the PropRange UI element Fix: ColorSampler loading issue Fix: Crash when adding physics to a Folder: Personal Developer note: Yes, someone had to try to add rigid body physics to.. wel... A FOLDER! You guys are amazing finding all sorts of corner cases and I LOVE IT! Cheerz. lol Fix: View Gizmo was being activated when moving a tab around (over it): Two actions at the same time when You're moving tab + You forgot to not move cursor over 3D View Cube at the same time... Thank you Ralph for the report. Fix: Character sliding Fix: It was not possible to set a character's position Fix: Some python components where not showing in the UI Fix: It was not possible to edit two PyComponents at the same time Fix: Making it possible to always have multiple components of the same type in an entity Fix: Dropdown filter was not working Fix: Crash when you run a python script with no start method Fix: I've Hidden the Jump Height because it is not used by bullet at all: There was a character physics option called \"Jump Height\". But after a close inspection in the bullet's source code, I relized that the jump Height was not used at all... lol (that's not my fault). Bullet code - for the Nerds Fix: PythonComponent was not being properly copied when duplicated Fix: Animation issues: This one is huge... remember This Video I made sometime ago? Well... it turns out that it was my fault as well (thanks to quaternions not being normalized). But now it's fixed! No more weird rotation behaviours. Fix: Activating the RigidBody when you set something Fix: Removed the shader error exception throw Fix: Some EntityTemplate crashes Fix: Crash when iterating the childrens Fix: Entity mem leaks and mem violations Fix: Shadows disappearing when the camera is far away from the world's center Fix: It was not possible to add components in realtime (python) Fix: Ensure that the Python Components are all constructed when calling the start Fix: Crash when modifying the entity component list (during iteration) Fix: Unicode characters was not working in the game UI: For the brazilian people out there (and maybe the russians and others): Say hello to special characters in your games! Words like \"A\u00c7\u00c3O!\" and \"PA\u00c7OCA\" will be displayed properly in the game UI. Internal stuff: I've omitted all the fixes and improvements that are internal (only noticeable inside the engine's codebase), but it's worth mentioning that... well, I've removed A BUNCH of unnecessary core, redundant stuff and fixed a lot of things. Huge refactors behind this big set of updates. I really liked the way it turned out.","title":"Cave 0.9.7"},{"location":"Docs/Releases/v097/#development-logs","text":"Welcome to the engine's development logs. If you want, also check the itch io page to see the release notes (under the Development log area): Cave Engine on itch io","title":"Development logs"},{"location":"Docs/Releases/v097/#cave-engine-097-alpha-release-notes","text":"Say hello to the Cave Engine version 0.9.7 (alpha)! It took a while, but it's finally here. I'm very happy about how it turned out and that's thanks to you and the amazing on growth community being built around it. Talking about community, I do have some exciting news: We finally have The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here if you want to: Sweet Shelter on itch io . Of course, this one was made using the previous version (0.9.6), but Renato actually teamed up with two more people (Bruno and Murilo) and they made a second game, using a closed version of 0.9.7 (that I've released earlier to my Patrons ) and I'll probably do a video on it soon. Ralph is also doing some amazing work using the engine: Thank you everyone using the engine and involved somehow, the community is amazing! I'm excited and I really hope y'all like it as I do. So let's jump to the release notes!","title":"Cave Engine 0.9.7 (alpha) Release Notes!"},{"location":"Docs/Releases/v097/#new-renderer","text":"Let's start with the big features! The entire renderer was rewritten from scratch. Why? Because now it is much more PBR accurate, easy to use and adjust and the best part: more lightweight! But that's not everything... besides all that, there is a bunch of new exciting features on it: ALPHA BLENDING is here! If you've used the engine before, you know that there was zero alpha blend support (only alpha clip). Now you can prepare your .png files, because it is working like a charm! Even with particles... so say hello to your smoke. Added Mist! The good and old mist. I use to say with some friends that mist is that magical button you press to instantly make the game looks better and now you have it in Cave. Awesome! Added an Aperture variable to the camera Soon we'll have HDR, but for now, you can manually adjust the camera aperture to support higher color ranges in your scene. Old Renderer removed! Well, I'm pretty sure that with the new one, no one will gonna mist that, but it's worth mentioning. The last thing I want it to have a bunch of different and non compatible renderers in the engine at the same time (as some other GEs are doing) so I decided to remove the old one. But don't worry: it means that I'll have more time to work in the new renderer and make it even more exciting and feature complete!","title":"New Renderer!"},{"location":"Docs/Releases/v097/#new-editors-console","text":"I know, I know... the Editor already had a Console before. But now it is 100% of what it was intended to be: Python prints and errors are displayed in the Editor's Console System console is now hidden by default That means no awkward black console window floating around when you're using the engine. Everything you need will be displayed in the editor's console. But if you're really that kind of person who likes random windows floating around your monitors, you can still enable back the console in the top menu. Just keep in mind that it will probably remain empty.","title":"New Editor's Console"},{"location":"Docs/Releases/v097/#animations","text":"Animations are way cooler now. Let's start by the fact that I've fixed THIS (it took me a while, but it's working!). And... Now it's possible to blend two different animations when changing the current one. Animations now have independent frames and always starts from the beginning (cheerz!) Improved the Animation Importer: Previously it was not considering more than 4 bone weights. Well, it still doesn't, but now it sorts the weights in order to get the higher influences and also renormalizes it to avoid glitches.","title":"Animations"},{"location":"Docs/Releases/v097/#audio","text":"YES! Audio finally received some love. Now there is 3D sound support and you can access the audio instance being executed and do a lot of fun stuff with it: class AddSoundTest(cave.Component): def start(self, scene): # kw arguments = volume=1, fadeIn=0, loop=0 self.sound = cave.playSound(\"testSound\", fadeIn=2.0) self.timer = cave.Timer() def update(self): self.sound.volume = math.sin(self.timer.get()) * 0.5 + 0.5 events = cave.getEvents() if events.pressed(\"W\"): self.sound.pause() elif events.pressed(\"S\"): self.sound.resume() def end(self, scene): pass Including 3D audio. But if you're not into code, you can use the native new Audio Component as well!","title":"Audio"},{"location":"Docs/Releases/v097/#entity-templates-working-like-a-charm","text":"Entity Templates are something very special and important in the game engine. Let's say that you are making a platform game with multiple levels and a lot of enemies spread across the maps. How would you make the same player have an instance on every level? Or even more: How to use the same enemy, without a bunch of duplicates (that makes you project hard to maintain) all across the map? That's why we have entity templates: You can create a new template by right clicking in the asset browser and then assign a selected object (in the 3D view) to it. It will store the entity structure and make it available to you to use anywhere you want to. So it will be just a matter of adding an empty where you want to spawn the template and select it in the entity's Settings menu. Previously it was not working as intended but now it is! Expect ( a lot ) more on it later.","title":"Entity Templates: Working like a charm!"},{"location":"Docs/Releases/v097/#editor-tools","text":"Previously I've said that I was planning to improve the Tooling support. And I did it! I've added default Editor Tools and you can make your own if you want to! Let me explain: Now it's possible to paste python scripts inside the Editor/Tools/ folder to automatically register them into the editor. So every time you open the engine, the custom made tools will be there, ready to use. Well, which tools? Various, including the community tools! But someone had to be the first one to write a tool for it, right? Right. So I decided to start this: The world's first official Cave tool is a built in Python API! And why that's good? I'm glad you asked. The tool uses the cave module itself to retrieve the data, so it will be always up to date to your current version. So if you want to check if there is a bleeding edge but yet not documented feature in the api, this is your place! This tool if far from complete yet, but the good news is that it's source open and everyone can go to \"Editor/Tools/\" and edit it. Enjoy!","title":"Editor Tools"},{"location":"Docs/Releases/v097/#python-api","text":"If you want to create some advanced logic for you game, you can use Python scripts for it (visual scripting is coming). So it's very important to provide a smooth and easy experience for you to make everything you want. That's why version 0.9.7 is full of new exciting python features! Let's start with some usability improvements: You often want to access other custom made components inside your code. Previously, there was no garantee that all the python components in your entity where initialized when running the start method, so that could lead to self.entity.get(\"YourComponent\") returning None . Now all the components are initialized first and then the start method is called. So if you have Foo and Bar attached to your entity, you can always access each other: class Foo(cave.Component): def start(self, scene): cmp = self.entity.get(\"Bar\") print(\"Bar = \", cmp) def end(self, scene): pass class Bar(cave.Component): def start(self, scene): cmp = self.entity.get(\"Foo\") print(\"Foo = \", cmp) def end(self, scene): pass But that could be not enough. Sometimes you actually want to wait until certain component initialize properly before accessing it. That's why we now have the optional method firstUpdate() . As the name suggest, it will be called once after all start(s) method run and before the regular update() . class Bar(cave.Component): def start(self, scene): print(\"Start method...\") def firstUpdate(self): print(\"FirstUpdate method...\") def update(self): # Called every frame! print(\"Update method...\") def end(self, scene): print(\"End method...\") To be honest, I can talk FOREVER about the python api improvements. Now you can grab the Mesh Component , get, set or modify its current mesh, material, animation and more! You can select the mesh, copy it to make it unique to a specific object and change as you want to. cmp = self.entity.get(\"Mesh\") # MeshComponent mesh = cmp.getMesh() mesh = mesh.getCopy() cmp.setMesh(mesh) # Do whatever you want with the mesh here! for vertex in mesh.vertices: mesh.position += cave.Vector(0, random.random(), 0) for index in mesh.indices: # For every 3 indices, we have a triangle print(index) mesh.reload() For instance, the code bellow will duplicate the material from the MeshComponent (to make it unique to that specific object) and make it pulse a random glow value, in realtime. Watch the Showcase Video : import cave import random import math class Emissive(cave.Component): def start(self, scene): self.timer = cave.Timer(random.random()*6) cmp = self.entity.get(\"Mesh\") self.mat = cmp.getMaterial() self.mat = self.mat.getCopy() cmp.setMaterial(self.mat) def update(self): c = (math.sin(self.timer.get()) + 1) / 2 self.mat.emission.set(c, c, c) def end(self, scene): pass And there is much more! Transform: lerp, untransform, unrotate Now it's possible to get python made components from python cmp = self.entity.get(\"YourOwnComponent\") . Exposed a transform.[get/set]WorldPosition() method to the Python API Exposed the CharacterComponent fields to the Python API Added a RigidBodyComponent.applyImpulse(...) method Added a MeshComponent.getAnimationLoops() method Added the MeshComponent.getAnimationProgress() method Exposed the DecalComponent to python","title":"Python API"},{"location":"Docs/Releases/v097/#mouselook-component","text":"This one deserves his own section: Now there is a new default component called \"Mouselook\". It allows you to use the mouse movement to apply some specific rotation to an object. You can use it to, well, do a mouselook, but for a lot more, such as that badass \"item preview\" from Skyrim, that rotates with the mouse.","title":"Mouselook Component"},{"location":"Docs/Releases/v097/#documentation","text":"The engine's documentation is still not 100% up to date (at least not by the time I'm writting this release notes), but I did a lot of improvements on it. By the way, check the previous \"Tooling\" category to see why you should not be worried about the Python API documentation anymore! Anyways, here is some changed I've made: Renamed \"engine\" to \"cave\" New homepage + theme Added Tooling examples Added a Showcase tab","title":"Documentation"},{"location":"Docs/Releases/v097/#new-entity-ui-tag-ui","text":"Now the entity tab (properties) are more organized, divided into sub tabs: Components, Settings and Tags. Tag UI was redesigned as well.","title":"New Entity UI + tag UI"},{"location":"Docs/Releases/v097/#new-quit-editor-popup-menu","text":"The \"quit editor\" window was redesigned to use the engine's UI instead of the OS message dialogues and now displays a \"Cancel\" button.","title":"New \"Quit Editor\" popup menu"},{"location":"Docs/Releases/v097/#git-control","text":"When people started working with Cave for real, they sent me some messages regarding the \"git friendless\". In other words, it was necessary to make the engine work with git so multiple people could work in the same project at the same time. So I've made some changed to allow this: Option to expose the scripts externally, in a Scripts/ folder Exposed the Asset names in the Project Files (previously it was just the unique ID, aka a weird and huge number) I'm planning to do more things related to that, but it was a great start!","title":"Git control"},{"location":"Docs/Releases/v097/#usability-uiux","text":"Want to see a lot of miscellaneous improvements regarding the engine usability? Here you go! UI Text Renderer rewritten from scratch The previous UI Text was very sketchy and was not working at all in a lot of cases. Now it was completely rewritted and it's working like a charm. Highlight active asset in the Asset Browser Added a debug grid to the viewport Changed the color of the selected text (it was not visible before) Reduced the color of the tab arrow (text editor) Mesh Entity are now added with a rigid body component by default Do not change the window focus while simulating the game! Addressing the report: \"The Shift + Space makes the screen in Full mode. The problem is that when I run+jump with the character controller it keeps scaling up/down\" Removed the Delete and Duplicate icon from the Scene Graph items: The user could easily accidentally click on them. I've added a dropdown menu instead. Those options are still available using the keyboard shortcuts. Added bulk actions for the Animation Asset Increased the Sun bias range in the editor","title":"Usability (UI/UX):"},{"location":"Docs/Releases/v097/#project-manager-improvements","text":"Project manager is the first window you see when you open the engine. Keep in mind that there is a bunch of other things I'm planning to make on it. Soon! Show a message when there is no projects Improve the \"new project\" layout","title":"Project Manager improvements"},{"location":"Docs/Releases/v097/#export-game","text":"I did a bunch of things related to the game exporting: Fix: The engine was not copying the the folders inside the \"Lib/\" directory, causing the game to not run as a standalone (exported version). Renamed the executable to the project name (previously it was always \"Game.exe\") Removed the Python STDOUT from the runtime + hide terminal Don't allow the user to export the game without a default scene selected! I've also improved the Settings UI by adding tabs to organize the content on it.","title":"Export Game:"},{"location":"Docs/Releases/v097/#fixes","text":"Something very important happened recently: We started to have actual Games being made using Cave Engine . And because of that, I had to make sure that the engine was stable enough and \"bug free\". So that's why we have so many bug fixes. Good news: it's working very well now! Fix: Crash when trying to display a nullptr image (ui) Fix: Light Gizmo was not world space (when parented) Fix: Camera with 0 scale was resulting in NaN values Fix: Overlapping text when hovering some dropdowns Fix: Editor Icons + use a custom file extension Fix: Camera view not working most of the times: The camera view was a bit sketchy, most of the times, it would simply not work at all and keep using the free camera of the viewport. Specially in the runtime. Now it works just fine. Fix: Deleting an Entity Tag was crashing the engine Fix: Tools getting invalid when you stop the game Fix: glDrawElements access violation (crash) Fix: Problem when displaying multiple ColorSampler UIs in the editor Fix a typo in the PropRange UI element Fix: ColorSampler loading issue Fix: Crash when adding physics to a Folder: Personal Developer note: Yes, someone had to try to add rigid body physics to.. wel... A FOLDER! You guys are amazing finding all sorts of corner cases and I LOVE IT! Cheerz. lol Fix: View Gizmo was being activated when moving a tab around (over it): Two actions at the same time when You're moving tab + You forgot to not move cursor over 3D View Cube at the same time... Thank you Ralph for the report. Fix: Character sliding Fix: It was not possible to set a character's position Fix: Some python components where not showing in the UI Fix: It was not possible to edit two PyComponents at the same time Fix: Making it possible to always have multiple components of the same type in an entity Fix: Dropdown filter was not working Fix: Crash when you run a python script with no start method Fix: I've Hidden the Jump Height because it is not used by bullet at all: There was a character physics option called \"Jump Height\". But after a close inspection in the bullet's source code, I relized that the jump Height was not used at all... lol (that's not my fault). Bullet code - for the Nerds Fix: PythonComponent was not being properly copied when duplicated Fix: Animation issues: This one is huge... remember This Video I made sometime ago? Well... it turns out that it was my fault as well (thanks to quaternions not being normalized). But now it's fixed! No more weird rotation behaviours. Fix: Activating the RigidBody when you set something Fix: Removed the shader error exception throw Fix: Some EntityTemplate crashes Fix: Crash when iterating the childrens Fix: Entity mem leaks and mem violations Fix: Shadows disappearing when the camera is far away from the world's center Fix: It was not possible to add components in realtime (python) Fix: Ensure that the Python Components are all constructed when calling the start Fix: Crash when modifying the entity component list (during iteration) Fix: Unicode characters was not working in the game UI: For the brazilian people out there (and maybe the russians and others): Say hello to special characters in your games! Words like \"A\u00c7\u00c3O!\" and \"PA\u00c7OCA\" will be displayed properly in the game UI.","title":"Fixes:"},{"location":"Docs/Releases/v097/#internal-stuff","text":"I've omitted all the fixes and improvements that are internal (only noticeable inside the engine's codebase), but it's worth mentioning that... well, I've removed A BUNCH of unnecessary core, redundant stuff and fixed a lot of things. Huge refactors behind this big set of updates. I really liked the way it turned out.","title":"Internal stuff:"},{"location":"Docs/Releases/v0972/","text":"Important Note: Cave Engine 0.9.8 is not yet released publicly (it's Patreon only at the moment), but it will in the next couple of days. Please check our discord server for updates. Cave Engine 0.9.8 Release Notes! Welcome to the biggest Cave release yet! In order to cheer this big release, let's start the notes by talking about the first official Uniday Studio game made using Cave: . The Looper's Bug is a game made in 72 hours for the Game Jam Ludum Dare 50 where you control Looper, a robot that loses his energy (in a shape of energy orbs) as you walk. When it runs out of energy, it explodes! The good news is that looper does have clones to help you walk throught the levels and their clones will recover energy from your past lost orbs. It's a puzzle game available for you to Play on Itch io . After this game, Cave Engine finally got past a stage that I'd like to call \"The battlefield test\" . In other words, it was used in production to an actual released game (that's not just a test project without a start and an end), testes \"in battle\" with lots of people playing it everywhere. So there is no doubts that the engine is now perfectly capable (and stable enough) to make a full game using it. It's also worth mentioning that this was not the first complete game made using cave. Back in the 0.9.6 release, @renatoaruffo made the game Sweet Shelter . A Personal note from the Dev Hi, it's Guilherme and thank you a lot for being here. It's been almost an year since the last engine's release (aug 17, 2021) and in the meanwhile, a lot of things happened! I got a Senior job in the Game Industry, as a Game Engine Dev, working with huge in house game engines (way bigger than Cave or anything I've worked before) and porting giant commercial games to consoles (such as Xbox One). I got hundreds of new students into my paid courses, made some new games and last, but not least, worked A TON in Cave! It was a great time. I had an opportunity to meet many cool devs across the world and learn a lot in such a small period of time. Having this senior game engine dev role in the industry really made a lot of difference as well. During this past year I've also realized how I love to make game and tools (such as engines) and help people to get started in game development. I'm very excited about this new release. As you saw, it's the first time ever I've used the engine to make a complete and released game. As a result, the engine received a lot of polish and fixed, which is awesome! To be honest, it would be a new dream becoming reality if I was able to work full time on Cave Engine some day. And with your help, that could be possible! The engine is currently free and it is my Gift for you to help you making your amazing games! But if you want to give something back by supporting Cave and future projects, I've setup a Patreon for you to help me get going with the project. I've setup 3 tier levels: starting at $3, you can be a general supporter. At $10, you'll have early access to future releases of Cave Engine and Dynami Engine, when they come out. Meaning that you'll not have to wait much to start using all the new features. Last, but not least, at $20 you'll get access to Cave PRO when it comes out (that's basically Cave, but with steroids). So don't forget to check the page and see if it is for you. In any case, thank you a lot for the support and for the presence here. You're awesome! Now that's enough introduction. Let's jump to all the release notes! New Project Manager UI Remember that ugly Project Manager that the engine used to have? Well, I don't, because here is how it looks like now: The new Project Manager now have Project thumbnails that you can mouse over to see details (such as last write date, engine version and project location), right click (to duplicate, reveal in explorer, open or simply delete the project) and, of course, open it. I've also added an \"About\" tab with a bunch of useful debug hints and informations. The Project Manager now have a splash screen! The goal is to feature some amazing games made using Cave. Meaning that your game can also be highlighted over there, for the entire world to see! New way to Edit Entity Templates! Entity Template is something very important for game development using Cave: it is the official way for you to create a \"base object\" that can be used all across your game. For example, if you'd like to create a player, enemies and collectable items that can be used several times across different levels, you'll do them by creating entity templates. Creating a Template is simple: Just right click in the Asset Browser, new asset, entity template. And now things gets interesting: you can now double click an EntityTemplate in the Asset Browser and it will open a special scene for you to edit it as you want. Changes gets applied to all entities using that template as soon as you leave its editing scene. Some other smaller updates within this commit: Added a thumbnail for the Templates Thumbnails can now have a colored footer (like UE) to help recognize the asset type. For now, Templates are green, scenes are Blue and meshes are grey. Added a green moldure in the Entity Template's Editor viewport Note: You can't start the game while editing a template. Rendering Features: The Cave Engine rendered received a lot of love in this version as well. Here is the main highlights: Exposed the Alpha threshold variable for opaque materials. Reduced the default texture format size to increase performance Added a post processing pass : It does not do much at the moment, but it will be essential in future releases to allow you to easily tweak the visuals of your game. Setting the proper OpenGL Context + forcing the offboard GPU to be used: Previously, for some unknown reason, the engine was not using the offboard GPU in some computers, meaning that, in some cases (just as an example) if you had an intel CPU and an RTX 3090 installed, it will attempt to use Intel Graphics instead. Now fixed. Improved the Shadow Bias and Peter Panning: Cascade shadow mapping is still planned for future releases. But for now, at least the shadows are way better then before! Fixed the previously Sketchy font rendering (in game)...(now it works) Mesh Component Tint Now every mesh component have a \"Tint\" variable that allows you to tint the material color as you want. The default color is white but you can use it to do a lot of cool stuff, such as a red color animation when a character takes damage, for example. It also allows the particle system to have a custom tint over life. Particle System Added an \"Use Parenting\" option: If enabled, the particles will move with the Entity. Improved the Particle Component's UI Particle life tint (as a curve!) Logic and Python API Writting your game logic using Cave ws never so easy and versatile as it is right now! Check all the new features and improvements made to this: Added a python properties dict to the Scenes: You can now store anything you want at a scene level by using the scene.properties python dictionary. Entity now have a \"properties\" field (python dict) as well (just like the scenes) CharacterComponent can now dettect collision You can use the methods getCollisions and collidedWith in order to get collisions from the CharacterComponent. Entity's children options added to the API Now you can find the following classmethods in the Entity: entity.add(...) entity.get(...) # Returns a given component entity.getScene(...) entity.getAll(...) # Returns a list of all components entity.getParent(...) entity.getChild(...) entity.getChildren(...) entity.getChildrenRecursive(...) entity.getTransform(...) Added an \"isAlive()\" method to the Entities After you attempt to kill an entity ( entity.kill() ), while it is still there, the method isAlive() will no longer return true. Remember that when calling kill() , the action will only be performed by the engine by the end of the frame. That's why the isAlive() is useful. Added some Smooth PlayerComponent Movement options Now you can Schedule to Kill an Entity . Awesome! If you want to add an entity to the scene (or any given entity) and kill them after some time, you can do it so by typing: entity.scheduleKill(5) # The entity will be killed within 5 seconds. Improved the Scene::AddFromTemplate(...) API When creating a new entity from a template ( scene.addFromTemplate(\"TemplateName\") ), you can now pass three optional parameters: position , rotation and scale . New Transform's LookAtSmooth method + fixed the LookAt UIElement: quadAlpha added to the Python API Character::IsFalling + more Python APIs The Character Component received even more love with all those new methods: isMoving() , isFalling() and onGround() . The Mesh Component also received: getArmature() and getAnimation() . Cave.ui backends refactored Previously it was caveui and now it's cave.ui . Meaning that: # This: import caveui as ui # Is now this: import cave.ui as ui The math functions also received an upgrade, with its own cave submodule as well: cave.math . Added mouselook limits to the Mouselook Component Added some new math utility functions Some math functions are really useful when creating games. Such as: # Lerp a to b, it works with floats, vectors and quaternions: out = cave.math.lerp(a, b, value) # We also now have an slerp variant, for quaternions only: out = cave.math.slerp(a, b, value) # Clamping floats: out = cave.math.clamp(x, 1.0, 3.0) # Mapping ranges, from [0,1] to [35,60], in this example: out = cave.math.mapRange(value, 0.0, 1.0, 35.0, 60.0) # It's worth mentioning that it also works if the range is backwards, such as: out = cave.math.mapRange(value, 0.0, 1.0, 60.0, 35.0) The New Python Code Component Some times you want to write some Python code, but it's not as important or big to justify creating an entire new Python Component... Well, now that's no longer a concern: you can simply create a Python Code Component an inline all that code directly into the component's UI. It's a very handy feature to make small python procedures. UI/UX: I'll not gonna lie: the engine is looking good now. Check this screenshot: And that also reflects to the usability! I've made a lot of quality of life improvements on it: Better Search bars to the engine! Now the search bars are no longer case sensitive (so if you're looking for an asset called \"TestingAsset\" and type \"test\", it will appear in the results). Lots of smaller tweaks were made as well. Improved the Asset Browser Thumbnails Increased the Editor's font resolution New Asset Picking (by clicking in the Viewport) Now it uses a pixel perfect approach, so it's no longer annoying to point and click to select an asset. Selected entity highlight in the Viewport: Now it's also easier to see the selected entities, since they'll be highlighted. Drag and Drop to Viewport: EntityTemplates, Textures and Materials are now possible! If you drop a template, it will automatically build it into the world for you. For the materials, you can drop it to a mesh to instantly apply. Last but not least, if you drop a texture directly to a mesh, it will automatically create a material for you (and apply to that mesh). Awesome! Material UI Refactored New \"Curve\" editor property type Asset Browser: added an \"Empty Folder\" text when, well, there is nothing in the folder (lol) Refactored the New Entity's names and settings If you drop a template to the viewport, the entity created will have the template name. I've also fixed the new \"Rigid Body Mesh\" option that was not making any sense... Entity's tree nodes are now open by default (in the scene graph) Better Scene thumbnail generator Previously the scene's thumbnails in the editor were mostly all the time blank or wrong. Now fixed. Editor: Allow TAB Key on multiline UI text Improved the Entity's UI a bit more Asset Importer UI: Option to batch [de]select assets to import Changed the drag and drop message to a more informative one. MeshComponent: Option to build a RigidBody based on the mesh used Previously it was annoying to create a blank rigid body and then selecting the same mesh as the one in the mesh component from a dropdown. Now there is a ... icon in the MeshComponent that allows you to automatically build the rigid body from it. Changed some RenderGraph UI icons Scene Graph: new Entity Right Click Menu! Now you have a lot of useful options when right clicking an entity in the Scene Graph. Awesome! Main Menu Bar improved + Play/Stop Button Removed that ugly \"Add\" Button (bottom right of entity's UI) There was a button in the entity menu and project browser that was supposed to serve as a way to add new components/projects. But it never worked as good as expected so I've removed it. The Editor's thumbnail system received a complete rewrite as well to allow all those cool new features. Viewport UI and Editing Enhancements Hold CTRL to toggle snapping Hold ALT before moving an Entity to duplicate it Controls gets disabled when you play the game. You can toggle them on/off using F3 (during the play mode) Shortcut: Alt+W/E/R to reset pos, rot, scl Now it Displays the current Scene's name in the Viewport (bottom left) Improved the CameraCmp Gizmo (Viewport) Now it also indicated the \"up\" direction of the camera view, making it easier to not place the cameras upside down. General Features: Animation: There is not a lot \"visible\" in terms of new features, but the Animation (skeletal) system received a lot of internal work, including fixes and improvements. I'm making it versatile enough to support multiple types of custom animations in the future, such as blend spaces and automatic character controllers. Physics: Rigid Bodies can how be in \"Ghost mode\" More Draw Debug Physics Backends Exported Game (Standalone): Option to use the Desktop Resolution on Standalone Created the Stats For Nerds Tab! Now the engine saves the time you spent on your projects + some other cool information about it. It's so cool! :) Added a Loading Screen: Now both the editor and the standalone game does have a pulsing loading screen before it starts up, while all the game resources are being loaded. It also means that the window will not appear as \"not responding\". Fixes: Fix: Python Script being edited was being closed when you quit game Fix: Broken Material Editor UI Fix: Text Editor Zoom was not working Fix: RigidBodyComponent was crashing with no shape Fix: Project Sorting by date in the Project Manager was wrong Fix: Crash when closing the Editor/Game Fix: Crash when creating an empty mesh + disabled grid in thumbnail Fix: First rendered mesh outline (when selected) was wrong Fix: Alpha not working after drawing texts in the UI Fix: Particle was not working when selecting the Entity Fix: Crash when creating a new project Fix: Ghost point lamp This one was almost a classic bug in Cave by now. If you notice, until v0.9.7, there was always a ghost point lamp casting light into the world. Now gone (sorry, ghost!). Fix: Inactive PlayerComponent was not resetting the walk Fix: Viewport was not drawing gizmos Fix: Crash when Killing the same Entity multiple times Fix: Crash Closing the engine with no Scene Opened Fix: UIButton was working while disabled (that was not supposed to happen) Fix: disabled Button wrongly receiving input Fix: Transform::lookAt method was doing some weird stuff in some corner cases Fix: UIElement layer was not being copied Fix: GetCollisions(obj) was returning ALL collisions No way I let that pass for so many time... but, well, now it's fixed. :) Fix: It was possible to select invisible UI elements Fix: Particle reload was incorrect in the Editor Fix: Py setAnimation was not working Fix: Sketchy font rendering... Fix: AudioTrackInst was not stopping on stop() Fix: FaceCulling not working in standalone I'll tell you a small story on how I figure out this bug... As you may know, I've made a game in 72 hours using cave for the Ludum Dare 50 . In the final hour before submitting the game, I exported it as runtime and tested... And I was only able to see a black screen. I freaked out thinking that I messed up the engine really bad during the jam (I've changed a lot or things during it). It ended up being an one line fix. :P Fix: Wrong RenderToTexture Aspect Fix: Scene Thumbnails was sometimes Empty Fix: deleting some assets was not working 100% It was removing the asset from the Asset Browser, but not deleting it from the project itself. That bug was happening with inherinted assets (such as ImageTexture, that inherits from Texture). Now fixed. Fix: Misaligned UI Icons (all of them) Fix Proj Manager thumbnail sizes Fix: Dropping stuff in the viewport was not working Fix: Possible template duplication issue Fix: Crash when loading a Project Still Work in Progress I was also working in some exciting new features that unfortunately didn't make to the 0.9.8 release. Initial Network layer (not available yet) In the future, Cave will have native methods to make online games. Logic Bricks: Visual Scripting (not available yet) It already allows me to create new nodes, logic bricks, attach them to a component, run and so on. Serialization is also 100% working as well. What's left is to write the front end (the node UIs) so the use will be able to create their own logic bricks trees as they want to. I'm almost there! :) Animation System (not available yet) As I said, I'm working on a versatile animation system for the engine to make your life way easier. I'm still not sure how it will be released, since I'm also working on Cave Engine PRO (paid, for the ones who want to support the engine and also use some extra features). Here is the plan so far: Animation inherits (from IAnimation): The animation types can use the Entity's properties to gather the necessary variables Character animation: With slots for: idle walk run jump (up, idle, landing) die (dying, dead idle) 4-directional animation (plus idle in the middle) 8-directional anumation (plus idle in the middle) Animation Blender (to blend anims): Allows you to have a base IAnimation and multiple layers on top. For each layer: An IAnimation + blend weight A list will all the bones to select/unselect the ones you want to influence The way I'm writting this system will also allow you to nest animations. For example, you can use a Character Animation for your player, but instead of a simple walk animation, you can use a 4 or 8-directional animation.","title":"Cave 0.9.7.2"},{"location":"Docs/Releases/v0972/#cave-engine-098-release-notes","text":"Welcome to the biggest Cave release yet! In order to cheer this big release, let's start the notes by talking about the first official Uniday Studio game made using Cave: . The Looper's Bug is a game made in 72 hours for the Game Jam Ludum Dare 50 where you control Looper, a robot that loses his energy (in a shape of energy orbs) as you walk. When it runs out of energy, it explodes! The good news is that looper does have clones to help you walk throught the levels and their clones will recover energy from your past lost orbs. It's a puzzle game available for you to Play on Itch io . After this game, Cave Engine finally got past a stage that I'd like to call \"The battlefield test\" . In other words, it was used in production to an actual released game (that's not just a test project without a start and an end), testes \"in battle\" with lots of people playing it everywhere. So there is no doubts that the engine is now perfectly capable (and stable enough) to make a full game using it. It's also worth mentioning that this was not the first complete game made using cave. Back in the 0.9.6 release, @renatoaruffo made the game Sweet Shelter .","title":"Cave Engine 0.9.8 Release Notes!"},{"location":"Docs/Releases/v0972/#a-personal-note-from-the-dev","text":"Hi, it's Guilherme and thank you a lot for being here. It's been almost an year since the last engine's release (aug 17, 2021) and in the meanwhile, a lot of things happened! I got a Senior job in the Game Industry, as a Game Engine Dev, working with huge in house game engines (way bigger than Cave or anything I've worked before) and porting giant commercial games to consoles (such as Xbox One). I got hundreds of new students into my paid courses, made some new games and last, but not least, worked A TON in Cave! It was a great time. I had an opportunity to meet many cool devs across the world and learn a lot in such a small period of time. Having this senior game engine dev role in the industry really made a lot of difference as well. During this past year I've also realized how I love to make game and tools (such as engines) and help people to get started in game development. I'm very excited about this new release. As you saw, it's the first time ever I've used the engine to make a complete and released game. As a result, the engine received a lot of polish and fixed, which is awesome! To be honest, it would be a new dream becoming reality if I was able to work full time on Cave Engine some day. And with your help, that could be possible! The engine is currently free and it is my Gift for you to help you making your amazing games! But if you want to give something back by supporting Cave and future projects, I've setup a Patreon for you to help me get going with the project. I've setup 3 tier levels: starting at $3, you can be a general supporter. At $10, you'll have early access to future releases of Cave Engine and Dynami Engine, when they come out. Meaning that you'll not have to wait much to start using all the new features. Last, but not least, at $20 you'll get access to Cave PRO when it comes out (that's basically Cave, but with steroids). So don't forget to check the page and see if it is for you. In any case, thank you a lot for the support and for the presence here. You're awesome! Now that's enough introduction. Let's jump to all the release notes!","title":"A Personal note from the Dev"},{"location":"Docs/Releases/v0972/#new-project-manager-ui","text":"Remember that ugly Project Manager that the engine used to have? Well, I don't, because here is how it looks like now: The new Project Manager now have Project thumbnails that you can mouse over to see details (such as last write date, engine version and project location), right click (to duplicate, reveal in explorer, open or simply delete the project) and, of course, open it. I've also added an \"About\" tab with a bunch of useful debug hints and informations. The Project Manager now have a splash screen! The goal is to feature some amazing games made using Cave. Meaning that your game can also be highlighted over there, for the entire world to see!","title":"New Project Manager UI"},{"location":"Docs/Releases/v0972/#new-way-to-edit-entity-templates","text":"Entity Template is something very important for game development using Cave: it is the official way for you to create a \"base object\" that can be used all across your game. For example, if you'd like to create a player, enemies and collectable items that can be used several times across different levels, you'll do them by creating entity templates. Creating a Template is simple: Just right click in the Asset Browser, new asset, entity template. And now things gets interesting: you can now double click an EntityTemplate in the Asset Browser and it will open a special scene for you to edit it as you want. Changes gets applied to all entities using that template as soon as you leave its editing scene. Some other smaller updates within this commit: Added a thumbnail for the Templates Thumbnails can now have a colored footer (like UE) to help recognize the asset type. For now, Templates are green, scenes are Blue and meshes are grey. Added a green moldure in the Entity Template's Editor viewport Note: You can't start the game while editing a template.","title":"New way to Edit Entity Templates!"},{"location":"Docs/Releases/v0972/#rendering-features","text":"The Cave Engine rendered received a lot of love in this version as well. Here is the main highlights: Exposed the Alpha threshold variable for opaque materials. Reduced the default texture format size to increase performance Added a post processing pass : It does not do much at the moment, but it will be essential in future releases to allow you to easily tweak the visuals of your game. Setting the proper OpenGL Context + forcing the offboard GPU to be used: Previously, for some unknown reason, the engine was not using the offboard GPU in some computers, meaning that, in some cases (just as an example) if you had an intel CPU and an RTX 3090 installed, it will attempt to use Intel Graphics instead. Now fixed. Improved the Shadow Bias and Peter Panning: Cascade shadow mapping is still planned for future releases. But for now, at least the shadows are way better then before! Fixed the previously Sketchy font rendering (in game)...(now it works)","title":"Rendering Features:"},{"location":"Docs/Releases/v0972/#mesh-component-tint","text":"Now every mesh component have a \"Tint\" variable that allows you to tint the material color as you want. The default color is white but you can use it to do a lot of cool stuff, such as a red color animation when a character takes damage, for example. It also allows the particle system to have a custom tint over life.","title":"Mesh Component Tint"},{"location":"Docs/Releases/v0972/#particle-system","text":"Added an \"Use Parenting\" option: If enabled, the particles will move with the Entity. Improved the Particle Component's UI Particle life tint (as a curve!)","title":"Particle System"},{"location":"Docs/Releases/v0972/#logic-and-python-api","text":"Writting your game logic using Cave ws never so easy and versatile as it is right now! Check all the new features and improvements made to this: Added a python properties dict to the Scenes: You can now store anything you want at a scene level by using the scene.properties python dictionary. Entity now have a \"properties\" field (python dict) as well (just like the scenes) CharacterComponent can now dettect collision You can use the methods getCollisions and collidedWith in order to get collisions from the CharacterComponent. Entity's children options added to the API Now you can find the following classmethods in the Entity: entity.add(...) entity.get(...) # Returns a given component entity.getScene(...) entity.getAll(...) # Returns a list of all components entity.getParent(...) entity.getChild(...) entity.getChildren(...) entity.getChildrenRecursive(...) entity.getTransform(...) Added an \"isAlive()\" method to the Entities After you attempt to kill an entity ( entity.kill() ), while it is still there, the method isAlive() will no longer return true. Remember that when calling kill() , the action will only be performed by the engine by the end of the frame. That's why the isAlive() is useful. Added some Smooth PlayerComponent Movement options Now you can Schedule to Kill an Entity . Awesome! If you want to add an entity to the scene (or any given entity) and kill them after some time, you can do it so by typing: entity.scheduleKill(5) # The entity will be killed within 5 seconds. Improved the Scene::AddFromTemplate(...) API When creating a new entity from a template ( scene.addFromTemplate(\"TemplateName\") ), you can now pass three optional parameters: position , rotation and scale . New Transform's LookAtSmooth method + fixed the LookAt UIElement: quadAlpha added to the Python API Character::IsFalling + more Python APIs The Character Component received even more love with all those new methods: isMoving() , isFalling() and onGround() . The Mesh Component also received: getArmature() and getAnimation() . Cave.ui backends refactored Previously it was caveui and now it's cave.ui . Meaning that: # This: import caveui as ui # Is now this: import cave.ui as ui The math functions also received an upgrade, with its own cave submodule as well: cave.math . Added mouselook limits to the Mouselook Component Added some new math utility functions Some math functions are really useful when creating games. Such as: # Lerp a to b, it works with floats, vectors and quaternions: out = cave.math.lerp(a, b, value) # We also now have an slerp variant, for quaternions only: out = cave.math.slerp(a, b, value) # Clamping floats: out = cave.math.clamp(x, 1.0, 3.0) # Mapping ranges, from [0,1] to [35,60], in this example: out = cave.math.mapRange(value, 0.0, 1.0, 35.0, 60.0) # It's worth mentioning that it also works if the range is backwards, such as: out = cave.math.mapRange(value, 0.0, 1.0, 60.0, 35.0)","title":"Logic and Python API"},{"location":"Docs/Releases/v0972/#the-new-python-code-component","text":"Some times you want to write some Python code, but it's not as important or big to justify creating an entire new Python Component... Well, now that's no longer a concern: you can simply create a Python Code Component an inline all that code directly into the component's UI. It's a very handy feature to make small python procedures.","title":"The New Python Code Component"},{"location":"Docs/Releases/v0972/#uiux","text":"I'll not gonna lie: the engine is looking good now. Check this screenshot: And that also reflects to the usability! I've made a lot of quality of life improvements on it: Better Search bars to the engine! Now the search bars are no longer case sensitive (so if you're looking for an asset called \"TestingAsset\" and type \"test\", it will appear in the results). Lots of smaller tweaks were made as well. Improved the Asset Browser Thumbnails Increased the Editor's font resolution New Asset Picking (by clicking in the Viewport) Now it uses a pixel perfect approach, so it's no longer annoying to point and click to select an asset. Selected entity highlight in the Viewport: Now it's also easier to see the selected entities, since they'll be highlighted. Drag and Drop to Viewport: EntityTemplates, Textures and Materials are now possible! If you drop a template, it will automatically build it into the world for you. For the materials, you can drop it to a mesh to instantly apply. Last but not least, if you drop a texture directly to a mesh, it will automatically create a material for you (and apply to that mesh). Awesome! Material UI Refactored New \"Curve\" editor property type Asset Browser: added an \"Empty Folder\" text when, well, there is nothing in the folder (lol) Refactored the New Entity's names and settings If you drop a template to the viewport, the entity created will have the template name. I've also fixed the new \"Rigid Body Mesh\" option that was not making any sense... Entity's tree nodes are now open by default (in the scene graph) Better Scene thumbnail generator Previously the scene's thumbnails in the editor were mostly all the time blank or wrong. Now fixed. Editor: Allow TAB Key on multiline UI text Improved the Entity's UI a bit more Asset Importer UI: Option to batch [de]select assets to import Changed the drag and drop message to a more informative one. MeshComponent: Option to build a RigidBody based on the mesh used Previously it was annoying to create a blank rigid body and then selecting the same mesh as the one in the mesh component from a dropdown. Now there is a ... icon in the MeshComponent that allows you to automatically build the rigid body from it. Changed some RenderGraph UI icons Scene Graph: new Entity Right Click Menu! Now you have a lot of useful options when right clicking an entity in the Scene Graph. Awesome! Main Menu Bar improved + Play/Stop Button Removed that ugly \"Add\" Button (bottom right of entity's UI) There was a button in the entity menu and project browser that was supposed to serve as a way to add new components/projects. But it never worked as good as expected so I've removed it. The Editor's thumbnail system received a complete rewrite as well to allow all those cool new features.","title":"UI/UX:"},{"location":"Docs/Releases/v0972/#viewport-ui-and-editing-enhancements","text":"Hold CTRL to toggle snapping Hold ALT before moving an Entity to duplicate it Controls gets disabled when you play the game. You can toggle them on/off using F3 (during the play mode) Shortcut: Alt+W/E/R to reset pos, rot, scl Now it Displays the current Scene's name in the Viewport (bottom left) Improved the CameraCmp Gizmo (Viewport) Now it also indicated the \"up\" direction of the camera view, making it easier to not place the cameras upside down.","title":"Viewport UI and Editing Enhancements"},{"location":"Docs/Releases/v0972/#general-features","text":"","title":"General Features:"},{"location":"Docs/Releases/v0972/#animation","text":"There is not a lot \"visible\" in terms of new features, but the Animation (skeletal) system received a lot of internal work, including fixes and improvements. I'm making it versatile enough to support multiple types of custom animations in the future, such as blend spaces and automatic character controllers.","title":"Animation:"},{"location":"Docs/Releases/v0972/#physics","text":"Rigid Bodies can how be in \"Ghost mode\" More Draw Debug Physics Backends","title":"Physics:"},{"location":"Docs/Releases/v0972/#exported-game-standalone","text":"Option to use the Desktop Resolution on Standalone","title":"Exported Game (Standalone):"},{"location":"Docs/Releases/v0972/#created-the-stats-for-nerds-tab","text":"Now the engine saves the time you spent on your projects + some other cool information about it. It's so cool! :)","title":"Created the Stats For Nerds Tab!"},{"location":"Docs/Releases/v0972/#added-a-loading-screen","text":"Now both the editor and the standalone game does have a pulsing loading screen before it starts up, while all the game resources are being loaded. It also means that the window will not appear as \"not responding\".","title":"Added a Loading Screen:"},{"location":"Docs/Releases/v0972/#fixes","text":"Fix: Python Script being edited was being closed when you quit game Fix: Broken Material Editor UI Fix: Text Editor Zoom was not working Fix: RigidBodyComponent was crashing with no shape Fix: Project Sorting by date in the Project Manager was wrong Fix: Crash when closing the Editor/Game Fix: Crash when creating an empty mesh + disabled grid in thumbnail Fix: First rendered mesh outline (when selected) was wrong Fix: Alpha not working after drawing texts in the UI Fix: Particle was not working when selecting the Entity Fix: Crash when creating a new project Fix: Ghost point lamp This one was almost a classic bug in Cave by now. If you notice, until v0.9.7, there was always a ghost point lamp casting light into the world. Now gone (sorry, ghost!). Fix: Inactive PlayerComponent was not resetting the walk Fix: Viewport was not drawing gizmos Fix: Crash when Killing the same Entity multiple times Fix: Crash Closing the engine with no Scene Opened Fix: UIButton was working while disabled (that was not supposed to happen) Fix: disabled Button wrongly receiving input Fix: Transform::lookAt method was doing some weird stuff in some corner cases Fix: UIElement layer was not being copied Fix: GetCollisions(obj) was returning ALL collisions No way I let that pass for so many time... but, well, now it's fixed. :) Fix: It was possible to select invisible UI elements Fix: Particle reload was incorrect in the Editor Fix: Py setAnimation was not working Fix: Sketchy font rendering... Fix: AudioTrackInst was not stopping on stop() Fix: FaceCulling not working in standalone I'll tell you a small story on how I figure out this bug... As you may know, I've made a game in 72 hours using cave for the Ludum Dare 50 . In the final hour before submitting the game, I exported it as runtime and tested... And I was only able to see a black screen. I freaked out thinking that I messed up the engine really bad during the jam (I've changed a lot or things during it). It ended up being an one line fix. :P Fix: Wrong RenderToTexture Aspect Fix: Scene Thumbnails was sometimes Empty Fix: deleting some assets was not working 100% It was removing the asset from the Asset Browser, but not deleting it from the project itself. That bug was happening with inherinted assets (such as ImageTexture, that inherits from Texture). Now fixed. Fix: Misaligned UI Icons (all of them) Fix Proj Manager thumbnail sizes Fix: Dropping stuff in the viewport was not working Fix: Possible template duplication issue Fix: Crash when loading a Project","title":"Fixes:"},{"location":"Docs/Releases/v0972/#still-work-in-progress","text":"I was also working in some exciting new features that unfortunately didn't make to the 0.9.8 release.","title":"Still Work in Progress"},{"location":"Docs/Releases/v0972/#initial-network-layer-not-available-yet","text":"In the future, Cave will have native methods to make online games.","title":"Initial Network layer (not available yet)"},{"location":"Docs/Releases/v0972/#logic-bricks-visual-scripting-not-available-yet","text":"It already allows me to create new nodes, logic bricks, attach them to a component, run and so on. Serialization is also 100% working as well. What's left is to write the front end (the node UIs) so the use will be able to create their own logic bricks trees as they want to. I'm almost there! :)","title":"Logic Bricks: Visual Scripting (not available yet)"},{"location":"Docs/Releases/v0972/#animation-system-not-available-yet","text":"As I said, I'm working on a versatile animation system for the engine to make your life way easier. I'm still not sure how it will be released, since I'm also working on Cave Engine PRO (paid, for the ones who want to support the engine and also use some extra features). Here is the plan so far: Animation inherits (from IAnimation): The animation types can use the Entity's properties to gather the necessary variables Character animation: With slots for: idle walk run jump (up, idle, landing) die (dying, dead idle) 4-directional animation (plus idle in the middle) 8-directional anumation (plus idle in the middle) Animation Blender (to blend anims): Allows you to have a base IAnimation and multiple layers on top. For each layer: An IAnimation + blend weight A list will all the bones to select/unselect the ones you want to influence The way I'm writting this system will also allow you to nest animations. For example, you can use a Character Animation for your player, but instead of a simple walk animation, you can use a 4 or 8-directional animation.","title":"Animation System (not available yet)"},{"location":"Docs/Releases/v098/","text":"Cave Engine 0.9.8 Release Notes! Welcome to the biggest Cave release yet! In fact, this release is so big that I've started to write its release notes a while ago ( check this ) and was not able to put even half of it in the document. And since this release note is pretty much what's delaying the engine from actually being released, I'll leave it as a \"TODO\" here for now. But feel free to join our discord server to discover the rest of the new features! :) Our Discord Servers Our Discord - In English Our Discord - In Portuguese (Brazil)","title":"Cave 0.9.8"},{"location":"Docs/Releases/v098/#cave-engine-098-release-notes","text":"Welcome to the biggest Cave release yet! In fact, this release is so big that I've started to write its release notes a while ago ( check this ) and was not able to put even half of it in the document. And since this release note is pretty much what's delaying the engine from actually being released, I'll leave it as a \"TODO\" here for now. But feel free to join our discord server to discover the rest of the new features! :)","title":"Cave Engine 0.9.8 Release Notes!"},{"location":"Docs/Releases/v098/#our-discord-servers","text":"Our Discord - In English Our Discord - In Portuguese (Brazil)","title":"Our Discord Servers"},{"location":"PythonAPI/engineMisc/","text":"Engine Miscellaneous Here you'll find various engine classes. Counting Time Cave Engine provides two useful classes for you to count Time: Timer and SceneTimer . They have the exact same API and the only different between them is that the latter will use the scene's elapsed time (when not paused) and the regular Timer will use the system time. In practice, this means that if you pause the scene , the SceneTimer will also pause and the Timer will keep counting. Most of the times, what you're looking for will be the SceneTimer . :) cave.Timer You can Initialize it in two ways: # This way it will start counting time at zero: timer = Timer() # And this way it will start at 10 seconds (for example): timer = Timer(10.0) Methods # Returns the elapsed time (in seconds): get() -> float # Sets the counter to some initial value (in seconds): set(value: float) # Resets the counter to 0: reset() cave.SceneTimer You can Initialize it in two ways: # This way it will start counting time at zero: timer = SceneTimer() # And this way it will start at 10 seconds (for example): timer = SceneTimer(10.0) Methods # Returns the elapsed time (in seconds): get() -> float # Sets the counter to some initial value (in seconds): set(value: float) # Resets the counter to 0: reset() Others cave.BitMask The BitMask is used by cave as Masks to filter various things, such as Rendering related components or even Physics. A bitmask consists in 32 bits, mapped from [0 to 31] . Keep in mind that if you attempt to manipulate a bit that's outside this range, it may lead to undefined behaviour. A BitMask class can be instantiated by you just fine if you want: myBitMask = cave.BitMask() myBitMask.enable(1) myBitMask.disable(2) Methods If you have two BitMasks and want to check if them intersect, meaning if they have some enabled bits in common, you can use this method: intersect(other: BitMask) -> bool Both functions bellow serves to check if a specific bit is enabled (True) or disabled (False). isEnabled(bit: int) -> bool get(bit: int) -> bool To change a bit (enabling or disabling it), you can either use the set(...) method or the equivalent enable/disable ones: set(bit: int, value: bool) enable(bit: int) disable(bit: int)","title":"Miscellaneous"},{"location":"PythonAPI/engineMisc/#engine-miscellaneous","text":"Here you'll find various engine classes.","title":"Engine Miscellaneous"},{"location":"PythonAPI/engineMisc/#counting-time","text":"Cave Engine provides two useful classes for you to count Time: Timer and SceneTimer . They have the exact same API and the only different between them is that the latter will use the scene's elapsed time (when not paused) and the regular Timer will use the system time. In practice, this means that if you pause the scene , the SceneTimer will also pause and the Timer will keep counting. Most of the times, what you're looking for will be the SceneTimer . :)","title":"Counting Time"},{"location":"PythonAPI/engineMisc/#cavetimer","text":"You can Initialize it in two ways: # This way it will start counting time at zero: timer = Timer() # And this way it will start at 10 seconds (for example): timer = Timer(10.0)","title":"cave.Timer"},{"location":"PythonAPI/engineMisc/#methods","text":"# Returns the elapsed time (in seconds): get() -> float # Sets the counter to some initial value (in seconds): set(value: float) # Resets the counter to 0: reset()","title":"Methods"},{"location":"PythonAPI/engineMisc/#cavescenetimer","text":"You can Initialize it in two ways: # This way it will start counting time at zero: timer = SceneTimer() # And this way it will start at 10 seconds (for example): timer = SceneTimer(10.0)","title":"cave.SceneTimer"},{"location":"PythonAPI/engineMisc/#methods_1","text":"# Returns the elapsed time (in seconds): get() -> float # Sets the counter to some initial value (in seconds): set(value: float) # Resets the counter to 0: reset()","title":"Methods"},{"location":"PythonAPI/engineMisc/#others","text":"","title":"Others"},{"location":"PythonAPI/engineMisc/#cavebitmask","text":"The BitMask is used by cave as Masks to filter various things, such as Rendering related components or even Physics. A bitmask consists in 32 bits, mapped from [0 to 31] . Keep in mind that if you attempt to manipulate a bit that's outside this range, it may lead to undefined behaviour. A BitMask class can be instantiated by you just fine if you want: myBitMask = cave.BitMask() myBitMask.enable(1) myBitMask.disable(2)","title":"cave.BitMask"},{"location":"PythonAPI/engineMisc/#methods_2","text":"If you have two BitMasks and want to check if them intersect, meaning if they have some enabled bits in common, you can use this method: intersect(other: BitMask) -> bool Both functions bellow serves to check if a specific bit is enabled (True) or disabled (False). isEnabled(bit: int) -> bool get(bit: int) -> bool To change a bit (enabling or disabling it), you can either use the set(...) method or the equivalent enable/disable ones: set(bit: int, value: bool) enable(bit: int) disable(bit: int)","title":"Methods"},{"location":"PythonAPI/engineUtils/","text":"Engine Utilities Here you'll find some useful functions to operate the engine and your game using Cave. Time Related This is the Delta Time function. You can multiply this value by ano movement factor in your game in order to make sure that it will run at the same speed regardless of the FPS. Check this link to undertstand this concept a bit better. Reference: cave.getDeltaTime() -> float You can use this function to see at how many FPS your game is running at. cave.getFPS() -> float General Use this function to Quit the game. It will close the game application. If you're editing the game and hit stop, it will just stop the game execution. Reference: cave.quitGame() In order to handle user events (such as keyboard and mouse inputs), you need to get the Cave's event system. Use this function for the matter. Reference: # NOTE: See the documentation for **cave.Events** to get more details. cave.getEvents() -> Events Scene In order to make your games, you'll need to be able to manipulate scenes. Here is you you handle them: Returns the current scene being played by the engine: cave.getCurrentScene() -> Scene # Alias (same function, different name): cave.getScene() -> Scene Allows you to change scenes: cave.setScene(name: str) If you want to Restart the current scene, here is what you're looking for: cave.restartCurrentScene() Mouse You can use those functions to get/set the mouse position. If you pass True to cave.getMousePosition (normalize parameter), it will divide the mouse pos by the window size and returns the value to you, ranging from 0.0 and 1.0. Otherwise, the value will be in pixels. You can only set the mouse position in pixels. If you need to convert the normalized mouse pos back to pixels, consider multiplying it by the window size. cave.getMousePosition(normalize=False) -> Vector2 cave.setMousePosition(x: int, y: int) Window cave.getWindowSize() -> Vector2 Audio Playing NOTE: Check the Assets > Audio Playing category for more details! You can play any sound you want anytime by calling the cave.playSound function. You'll need to pass the asset name for the sound (exactly how it is written in the asset browser) and the optional parameters: Parameter Description volume How loud or quiet the sound will be. 0 means muted, 1 means max. fadeIn In seconds, if greated than zero, it will slowly fade in the sound by the amount of time you pass. loop How many times you want the sound to be played. -1 means that it will play forever, zero means that it will play once and 1 (or more) means that it will play and repeat by 1 (or the number you pass). This function returns an AudioTrackInstance that allows you to later change those values, pause/resume the sound and more. Reference code: cave.playSound(name: str, volume=1.0, fadeIn=0.0, loop=0) -> AudioTrackInstance","title":"Utilities"},{"location":"PythonAPI/engineUtils/#engine-utilities","text":"Here you'll find some useful functions to operate the engine and your game using Cave.","title":"Engine Utilities"},{"location":"PythonAPI/engineUtils/#time-related","text":"This is the Delta Time function. You can multiply this value by ano movement factor in your game in order to make sure that it will run at the same speed regardless of the FPS. Check this link to undertstand this concept a bit better. Reference: cave.getDeltaTime() -> float You can use this function to see at how many FPS your game is running at. cave.getFPS() -> float","title":"Time Related"},{"location":"PythonAPI/engineUtils/#general","text":"Use this function to Quit the game. It will close the game application. If you're editing the game and hit stop, it will just stop the game execution. Reference: cave.quitGame() In order to handle user events (such as keyboard and mouse inputs), you need to get the Cave's event system. Use this function for the matter. Reference: # NOTE: See the documentation for **cave.Events** to get more details. cave.getEvents() -> Events","title":"General"},{"location":"PythonAPI/engineUtils/#scene","text":"In order to make your games, you'll need to be able to manipulate scenes. Here is you you handle them: Returns the current scene being played by the engine: cave.getCurrentScene() -> Scene # Alias (same function, different name): cave.getScene() -> Scene Allows you to change scenes: cave.setScene(name: str) If you want to Restart the current scene, here is what you're looking for: cave.restartCurrentScene()","title":"Scene"},{"location":"PythonAPI/engineUtils/#mouse","text":"You can use those functions to get/set the mouse position. If you pass True to cave.getMousePosition (normalize parameter), it will divide the mouse pos by the window size and returns the value to you, ranging from 0.0 and 1.0. Otherwise, the value will be in pixels. You can only set the mouse position in pixels. If you need to convert the normalized mouse pos back to pixels, consider multiplying it by the window size. cave.getMousePosition(normalize=False) -> Vector2 cave.setMousePosition(x: int, y: int)","title":"Mouse"},{"location":"PythonAPI/engineUtils/#window","text":"cave.getWindowSize() -> Vector2","title":"Window"},{"location":"PythonAPI/engineUtils/#audio-playing","text":"NOTE: Check the Assets > Audio Playing category for more details! You can play any sound you want anytime by calling the cave.playSound function. You'll need to pass the asset name for the sound (exactly how it is written in the asset browser) and the optional parameters: Parameter Description volume How loud or quiet the sound will be. 0 means muted, 1 means max. fadeIn In seconds, if greated than zero, it will slowly fade in the sound by the amount of time you pass. loop How many times you want the sound to be played. -1 means that it will play forever, zero means that it will play once and 1 (or more) means that it will play and repeat by 1 (or the number you pass). This function returns an AudioTrackInstance that allows you to later change those values, pause/resume the sound and more. Reference code: cave.playSound(name: str, volume=1.0, fadeIn=0.0, loop=0) -> AudioTrackInstance","title":"Audio Playing"},{"location":"PythonAPI/introduction/","text":"Welcome to Cave Engine's Python API! (Note: This API is up to date with Cave Engine v0.9.8 - PRO ) Welcome to the official Cave Engine API, written to give you a good overview of how python scripting works in Cave and also serve as a Reference for you to write your own custom code. It was designed with readability in mind, so it's strongly recommended that you to take some time and read thought the entire API to better understand everything . It is full of code samples, tips and insights on how you can use those functions, classes and variables to get the best out of the engine. It also shares some cool and good to know secrets on how Cave works internally, so you can better use and understand it. Keep in mind that this API is not a Python (language) tutorial and we expect that you have a basic understanding on how this programming language works and how to write code using it, as well as some Object Oriented Programming (OOP) knowledge. If you don't know Python, check this to get started . How to read the API? You can start reading it in order, as it appears in the Python API top menu, starting with the Core elements (Scene, Entity, Component) and then exploring all the others. Remember that you can always go back later and use this API as a reference while writting your own codes. Do I need to install Python or anything? No! Cave Engine comes with python embedded by default and all the cave modules and submodules are within the engine. Meaning that there is no need to install python by hand on your machine and you also don't need to install any cave modules yourself. In fact, it's not even possible to install it yourself since they only work inside Cave Engine. Do you have any questions? If you have any questions, suggestions or comments, feel free to Join one of our discord servers and ask there: Our Discord - In English Our Discord - In Portuguese (Brazil)","title":"Introduction"},{"location":"PythonAPI/introduction/#welcome-to-cave-engines-python-api","text":"(Note: This API is up to date with Cave Engine v0.9.8 - PRO ) Welcome to the official Cave Engine API, written to give you a good overview of how python scripting works in Cave and also serve as a Reference for you to write your own custom code. It was designed with readability in mind, so it's strongly recommended that you to take some time and read thought the entire API to better understand everything . It is full of code samples, tips and insights on how you can use those functions, classes and variables to get the best out of the engine. It also shares some cool and good to know secrets on how Cave works internally, so you can better use and understand it. Keep in mind that this API is not a Python (language) tutorial and we expect that you have a basic understanding on how this programming language works and how to write code using it, as well as some Object Oriented Programming (OOP) knowledge. If you don't know Python, check this to get started .","title":"Welcome to Cave Engine's Python API!"},{"location":"PythonAPI/introduction/#how-to-read-the-api","text":"You can start reading it in order, as it appears in the Python API top menu, starting with the Core elements (Scene, Entity, Component) and then exploring all the others. Remember that you can always go back later and use this API as a reference while writting your own codes.","title":"How to read the API?"},{"location":"PythonAPI/introduction/#do-i-need-to-install-python-or-anything","text":"No! Cave Engine comes with python embedded by default and all the cave modules and submodules are within the engine. Meaning that there is no need to install python by hand on your machine and you also don't need to install any cave modules yourself. In fact, it's not even possible to install it yourself since they only work inside Cave Engine.","title":"Do I need to install Python or anything?"},{"location":"PythonAPI/introduction/#do-you-have-any-questions","text":"If you have any questions, suggestions or comments, feel free to Join one of our discord servers and ask there: Our Discord - In English Our Discord - In Portuguese (Brazil)","title":"Do you have any questions?"},{"location":"PythonAPI/math/","text":"Math The following functions and classes are related to Math operations. Cave engine does have a cave.math submodule, but in order to simplify and speedup your code writting, the classes belongs to the main cave. module. Only the functions belongs to the submodule. cave.math Functions cave.math.normalized(vec : cave.Vector3) -> cave.Vector3 cave.math.length(vec : cave.Vector3) -> float cave.math.clamp(x : float, minValue : float, maxValue: float) -> float You can also lerp two values by a factor (value) using cave.math.lerp . The supported types are: float, Vector2, Vector3, Vector4 and Quaternion. Reference: cave.math.lerp(a: TYPE, b: TYPE, value: float) -> TYPE If you're using Quaternions , slerp is also supported. See this link to understand slerp. Reference: cave.math.slerp(a: cave.Quaternion, b: cave.Quaternion, value: float) -> cave.Quaternion Map Range is also an useful function that allows you to map a value from one range to other. For example, if you have a health variable that is represented in percentage (0 to 100) and you want to make a mesh becomes invisible as the health decreases, you can map the health value from the range [0, 100] to the range [1.0, 0.0] and apply that as the alpha tint of the mesh, since alpha 1.0 (when health is 100%) means completely opaque and alpha 0.0 (when health is 0%) means completely transparent. Reference: cave.math.mapRange(value: float, fromMin: float, fromMax: float, toMin: float, toMax: float) -> float A common vector operator is the dot product . Supported in cave with the cave.math.dot(...) function and works with Vector2, Vector3 and Vector4. See this link to understand how dot product works. Reference: cave.math.dot(a: VectorX, b: VectorX) -> VectorX Cave also supports the inverse function to invert a Quaternion or Matrix4: cave.math.inverse(quat: cave.Quaternion) -> cave.Quaternion cave.math.inverse(quat: cave.Matrix4) -> cave.Matrix4 Vector Classes Cave Engine provides wrappers to low level C++ vector classes and operations. Initialization Example Here is an initialization example to get started: # Default constructor: vec = cave.Vector() # Intialize the vector with (0, 0): myVec1 = cave.Vector2(0) # Regular (x, y) constructor for the 2D Vector: myVec2 = cave.Vector2(0, 1) # Copy the vector: myVec3 = cave.Vector3(myVec2) Supported Vector Operations You can do all sorts of operations using vectors: Operation Usage == if vecA == vecB: ... + vec = vecA + vecB += vec += vecB - vec = vecA - vecB -= vec -= vecB * vec = vecB * 50.0 * vec = 50.0 * vecB *= vec *= 100.0 Including operations between a cave.Vector3 and an cave.Quaternion : Operation Usage * vec = vec * quaterion * vec = quaterion * vecB *= vec *= quaterion cave.Vector2 Variables x : float y : float Note: You can also access the x, y parameters by using s, t or u, v . cave.Vector3 Variables x : float y : float z : float Note: You can also access the x, y, z parameters by using r, g, b as an acronym for the color channels Red , Green and Blue . cave.Vector4 Variables x : float y : float z : float w : float Note: You can also access the x, y, z, w parameters by using r, g, b, a as an acronym for the color channels Red , Green , Blue and Alpha . Other Classes cave.Quaternion Quaternions, just like the vectors, are low level implementations that supports all sorts of operations ( ==, +, +=, -, -=, *, *= ). Variables x : float y : float z : float w : float cave.Matrix4 This class is declared for the Cave API, but not yet implemented, so right now there is no way to directly manipulate the Matrix4 using Python. cave.UIVector The cave.UIVector is a different vector, used specifically for the in Game User Interface (Game UI). It needs to be a different type of vector because it also takes into account the anchoring and if the element is relative (or not) to it's parent. If the vector is relative, the X, Y values will be represented with a [0-1] ranged float number (percentage). If not, it will be represented by two ints for the pixels. Variables anchoringX : int anchoringY : int The supported anchoring values are: -1, 0, 1 . Methods isRelativeX() -> bool isRelativeY() -> bool getX(parentScale = 1.0) -> float getY(parentScale = 1.0) -> float setPixelX(value : int) setPixelY(value : int) setPixel(x : int, y : int) setRelativeX(value : float) setRelativeY(value : float) setRelative(x : float, y : float)","title":"Math"},{"location":"PythonAPI/math/#math","text":"The following functions and classes are related to Math operations. Cave engine does have a cave.math submodule, but in order to simplify and speedup your code writting, the classes belongs to the main cave. module. Only the functions belongs to the submodule.","title":"Math"},{"location":"PythonAPI/math/#cavemath","text":"","title":"cave.math"},{"location":"PythonAPI/math/#functions","text":"cave.math.normalized(vec : cave.Vector3) -> cave.Vector3 cave.math.length(vec : cave.Vector3) -> float cave.math.clamp(x : float, minValue : float, maxValue: float) -> float You can also lerp two values by a factor (value) using cave.math.lerp . The supported types are: float, Vector2, Vector3, Vector4 and Quaternion. Reference: cave.math.lerp(a: TYPE, b: TYPE, value: float) -> TYPE If you're using Quaternions , slerp is also supported. See this link to understand slerp. Reference: cave.math.slerp(a: cave.Quaternion, b: cave.Quaternion, value: float) -> cave.Quaternion Map Range is also an useful function that allows you to map a value from one range to other. For example, if you have a health variable that is represented in percentage (0 to 100) and you want to make a mesh becomes invisible as the health decreases, you can map the health value from the range [0, 100] to the range [1.0, 0.0] and apply that as the alpha tint of the mesh, since alpha 1.0 (when health is 100%) means completely opaque and alpha 0.0 (when health is 0%) means completely transparent. Reference: cave.math.mapRange(value: float, fromMin: float, fromMax: float, toMin: float, toMax: float) -> float A common vector operator is the dot product . Supported in cave with the cave.math.dot(...) function and works with Vector2, Vector3 and Vector4. See this link to understand how dot product works. Reference: cave.math.dot(a: VectorX, b: VectorX) -> VectorX Cave also supports the inverse function to invert a Quaternion or Matrix4: cave.math.inverse(quat: cave.Quaternion) -> cave.Quaternion cave.math.inverse(quat: cave.Matrix4) -> cave.Matrix4","title":"Functions"},{"location":"PythonAPI/math/#vector-classes","text":"Cave Engine provides wrappers to low level C++ vector classes and operations.","title":"Vector Classes"},{"location":"PythonAPI/math/#initialization-example","text":"Here is an initialization example to get started: # Default constructor: vec = cave.Vector() # Intialize the vector with (0, 0): myVec1 = cave.Vector2(0) # Regular (x, y) constructor for the 2D Vector: myVec2 = cave.Vector2(0, 1) # Copy the vector: myVec3 = cave.Vector3(myVec2)","title":"Initialization Example"},{"location":"PythonAPI/math/#supported-vector-operations","text":"You can do all sorts of operations using vectors: Operation Usage == if vecA == vecB: ... + vec = vecA + vecB += vec += vecB - vec = vecA - vecB -= vec -= vecB * vec = vecB * 50.0 * vec = 50.0 * vecB *= vec *= 100.0 Including operations between a cave.Vector3 and an cave.Quaternion : Operation Usage * vec = vec * quaterion * vec = quaterion * vecB *= vec *= quaterion","title":"Supported Vector Operations"},{"location":"PythonAPI/math/#cavevector2","text":"","title":"cave.Vector2"},{"location":"PythonAPI/math/#variables","text":"x : float y : float Note: You can also access the x, y parameters by using s, t or u, v .","title":"Variables"},{"location":"PythonAPI/math/#cavevector3","text":"","title":"cave.Vector3"},{"location":"PythonAPI/math/#variables_1","text":"x : float y : float z : float Note: You can also access the x, y, z parameters by using r, g, b as an acronym for the color channels Red , Green and Blue .","title":"Variables"},{"location":"PythonAPI/math/#cavevector4","text":"","title":"cave.Vector4"},{"location":"PythonAPI/math/#variables_2","text":"x : float y : float z : float w : float Note: You can also access the x, y, z, w parameters by using r, g, b, a as an acronym for the color channels Red , Green , Blue and Alpha .","title":"Variables"},{"location":"PythonAPI/math/#other-classes","text":"","title":"Other Classes"},{"location":"PythonAPI/math/#cavequaternion","text":"Quaternions, just like the vectors, are low level implementations that supports all sorts of operations ( ==, +, +=, -, -=, *, *= ).","title":"cave.Quaternion"},{"location":"PythonAPI/math/#variables_3","text":"x : float y : float z : float w : float","title":"Variables"},{"location":"PythonAPI/math/#cavematrix4","text":"This class is declared for the Cave API, but not yet implemented, so right now there is no way to directly manipulate the Matrix4 using Python.","title":"cave.Matrix4"},{"location":"PythonAPI/math/#caveuivector","text":"The cave.UIVector is a different vector, used specifically for the in Game User Interface (Game UI). It needs to be a different type of vector because it also takes into account the anchoring and if the element is relative (or not) to it's parent. If the vector is relative, the X, Y values will be represented with a [0-1] ranged float number (percentage). If not, it will be represented by two ints for the pixels.","title":"cave.UIVector"},{"location":"PythonAPI/math/#variables_4","text":"anchoringX : int anchoringY : int The supported anchoring values are: -1, 0, 1 .","title":"Variables"},{"location":"PythonAPI/math/#methods","text":"isRelativeX() -> bool isRelativeY() -> bool getX(parentScale = 1.0) -> float getY(parentScale = 1.0) -> float setPixelX(value : int) setPixelY(value : int) setPixel(x : int, y : int) setRelativeX(value : float) setRelativeY(value : float) setRelative(x : float, y : float)","title":"Methods"},{"location":"PythonAPI/Assets/audio/","text":"Audio Playing You can play any sound you want anytime by calling the cave.playSound function. You'll need to pass the asset name for the sound (exactly how it is written in the asset browser) and the optional parameters: Parameter Description volume How loud or quiet the sound will be. 0 means muted, 1 means max. fadeIn In seconds, if greated than zero, it will slowly fade in the sound by the amount of time you pass. loop How many times you want the sound to be played. -1 means that it will play forever, zero means that it will play once and 1 (or more) means that it will play and repeat by 1 (or the number you pass). This function returns an AudioTrackInstance that allows you to later change those values, pause/resume the sound and more. Reference code: cave.playSound(name: str, volume=1.0, fadeIn=0.0, loop=0) -> AudioTrackInstance The Audio Handler As explained above, by calling cave.playSound , the function will return AudioTrackInstance . Here is everything you need to know about it: cave.AudioTrackInstance Here is an example of the AudioTrackInstance in action. The following component only plays the sound if the scene is NOT paused: class AudioExample(cave.Component): def start(self, scene): self.handler = cave.playAudio(\"MyCoolSound.ogg\", 1.0) def update(self): if self.handler.isPaused(): self.handler.resume() def pausedUpdate(self): if self.handler.isPlaying(): self.handler.pause() Variables You can use this variable to adjust the sound volume. Keep in mind that it must be between 0 and 1. volume : float Methods Here is the basic operations to work with the sound (pause, resume and stop): pause() resume() # If you pass a fadeout (in seconds), if will slowly fade out the audio until it stops. stop(fadeOut=0.0) You can also use the handler to check certain things and status of it: # Returns true if the track is being played or is paused. False if not: isActive() -> bool isPlaying() -> bool isPaused() -> bool isFadingIn() -> bool isFadingOut() -> bool # Returns the channel that this audio is being played at: getChannel() -> int 3D Sounds: Cave Engine supports 3D sounds, but you'll need to manually call this method every frame in order to update it: calculate3D(audioPos: Vector3, maxDistance=100.0)","title":"Audio Playing"},{"location":"PythonAPI/Assets/audio/#audio-playing","text":"You can play any sound you want anytime by calling the cave.playSound function. You'll need to pass the asset name for the sound (exactly how it is written in the asset browser) and the optional parameters: Parameter Description volume How loud or quiet the sound will be. 0 means muted, 1 means max. fadeIn In seconds, if greated than zero, it will slowly fade in the sound by the amount of time you pass. loop How many times you want the sound to be played. -1 means that it will play forever, zero means that it will play once and 1 (or more) means that it will play and repeat by 1 (or the number you pass). This function returns an AudioTrackInstance that allows you to later change those values, pause/resume the sound and more. Reference code: cave.playSound(name: str, volume=1.0, fadeIn=0.0, loop=0) -> AudioTrackInstance","title":"Audio Playing"},{"location":"PythonAPI/Assets/audio/#the-audio-handler","text":"As explained above, by calling cave.playSound , the function will return AudioTrackInstance . Here is everything you need to know about it:","title":"The Audio Handler"},{"location":"PythonAPI/Assets/audio/#caveaudiotrackinstance","text":"Here is an example of the AudioTrackInstance in action. The following component only plays the sound if the scene is NOT paused: class AudioExample(cave.Component): def start(self, scene): self.handler = cave.playAudio(\"MyCoolSound.ogg\", 1.0) def update(self): if self.handler.isPaused(): self.handler.resume() def pausedUpdate(self): if self.handler.isPlaying(): self.handler.pause()","title":"cave.AudioTrackInstance"},{"location":"PythonAPI/Assets/audio/#variables","text":"You can use this variable to adjust the sound volume. Keep in mind that it must be between 0 and 1. volume : float","title":"Variables"},{"location":"PythonAPI/Assets/audio/#methods","text":"Here is the basic operations to work with the sound (pause, resume and stop): pause() resume() # If you pass a fadeout (in seconds), if will slowly fade out the audio until it stops. stop(fadeOut=0.0) You can also use the handler to check certain things and status of it: # Returns true if the track is being played or is paused. False if not: isActive() -> bool isPlaying() -> bool isPaused() -> bool isFadingIn() -> bool isFadingOut() -> bool # Returns the channel that this audio is being played at: getChannel() -> int","title":"Methods"},{"location":"PythonAPI/Assets/audio/#3d-sounds","text":"Cave Engine supports 3D sounds, but you'll need to manually call this method every frame in order to update it: calculate3D(audioPos: Vector3, maxDistance=100.0)","title":"3D Sounds:"},{"location":"PythonAPI/Assets/materials/","text":"Material Related Assets In order to properly manipulate materials and colors in Cave, you'll need to acknowledge two main classes: ColorSampler and Material . Check them below. Be aware that right now the engine does not support custom material shaders or pipelines, but it will provide you some basic functionalities such as changing colors and textures in realtime. How to get a Material Instance? The way you'll tipically get a Material class instance is by retrieving them from a MeshComponent , do NOT try to create your own instance from scratch , it will not work. Here is an example of how it's done: # Getting the mesh component: meshComponent = self.entity.get(\"Mesh\") # Getting the material: material = meshComponent.getMaterial() # If you want to change the material settings for a specific Entity, # you can duplicate it and reassign to the Component: materialCopy = material.getCopy() meshComponent.setMaterial(materialCopy) # Now you'll be able to do local changes to the *materialCopy*: materialCopy.albedo.set(1,0,0,1) Documentation Here is the full documentation: cave.ColorSampler You probably have noticed that when it comes to Material colors, Cave Engine allows you most of the times to choose if you want to use a Texture (an image) or a raw Color (with reg, green, blue and alpha values). To archieve that, Cave uses what we call ColorSampler . You'll find ways to change its color below. Methods # Returns true if the color sampler has a texture. hasTexture() -> bool # Will return the color sampler's color getColor() -> Vector4 # Will return the color sampler's texture name (if there is a texture) getTexture() -> string In order to change the ColorSampler values, you can use one of those two setters, depending if you want to set it to a color or a texture. # Use this one if you want to set it to a raw color: set(r: float, g: float, b: float, a=1.0) # Use this one if you want to set it to a texture: set(textureName: str) cave.Material Variables All the following variables returns ColorSampler class instances. Check the documentation above for more details on how to handle them. albedo: ColorSampler roughness: ColorSampler metallic: ColorSampler normal: ColorSampler emission: ColorSampler Methods If you need to duplicate a material (in order to do local changes to a specific Entity, for example), this is what you're looking for. It will duplicate the material and add it to the game data! getCopy() -> cave.Material","title":"Material Manipulation"},{"location":"PythonAPI/Assets/materials/#material-related-assets","text":"In order to properly manipulate materials and colors in Cave, you'll need to acknowledge two main classes: ColorSampler and Material . Check them below. Be aware that right now the engine does not support custom material shaders or pipelines, but it will provide you some basic functionalities such as changing colors and textures in realtime.","title":"Material Related Assets"},{"location":"PythonAPI/Assets/materials/#how-to-get-a-material-instance","text":"The way you'll tipically get a Material class instance is by retrieving them from a MeshComponent , do NOT try to create your own instance from scratch , it will not work. Here is an example of how it's done: # Getting the mesh component: meshComponent = self.entity.get(\"Mesh\") # Getting the material: material = meshComponent.getMaterial() # If you want to change the material settings for a specific Entity, # you can duplicate it and reassign to the Component: materialCopy = material.getCopy() meshComponent.setMaterial(materialCopy) # Now you'll be able to do local changes to the *materialCopy*: materialCopy.albedo.set(1,0,0,1)","title":"How to get a Material Instance?"},{"location":"PythonAPI/Assets/materials/#documentation","text":"Here is the full documentation:","title":"Documentation"},{"location":"PythonAPI/Assets/materials/#cavecolorsampler","text":"You probably have noticed that when it comes to Material colors, Cave Engine allows you most of the times to choose if you want to use a Texture (an image) or a raw Color (with reg, green, blue and alpha values). To archieve that, Cave uses what we call ColorSampler . You'll find ways to change its color below.","title":"cave.ColorSampler"},{"location":"PythonAPI/Assets/materials/#methods","text":"# Returns true if the color sampler has a texture. hasTexture() -> bool # Will return the color sampler's color getColor() -> Vector4 # Will return the color sampler's texture name (if there is a texture) getTexture() -> string In order to change the ColorSampler values, you can use one of those two setters, depending if you want to set it to a color or a texture. # Use this one if you want to set it to a raw color: set(r: float, g: float, b: float, a=1.0) # Use this one if you want to set it to a texture: set(textureName: str)","title":"Methods"},{"location":"PythonAPI/Assets/materials/#cavematerial","text":"","title":"cave.Material"},{"location":"PythonAPI/Assets/materials/#variables","text":"All the following variables returns ColorSampler class instances. Check the documentation above for more details on how to handle them. albedo: ColorSampler roughness: ColorSampler metallic: ColorSampler normal: ColorSampler emission: ColorSampler","title":"Variables"},{"location":"PythonAPI/Assets/materials/#methods_1","text":"If you need to duplicate a material (in order to do local changes to a specific Entity, for example), this is what you're looking for. It will duplicate the material and add it to the game data! getCopy() -> cave.Material","title":"Methods"},{"location":"PythonAPI/Assets/meshes/","text":"Mesh Related Assets Just like the materials, in order to manipulate Meshes, you'll need to acknowledge two main classes: Vertex and Mesh . We highly recommend that you have a basic knowledge on how Meshes works before attempting to work with the Mesh Manipulation APIs provided below. This is a good start if you don't have experience with it. Before jumping to the class Documentation , I'll explain how Cave Engine handles meshes, so you can have a better knowledge of it in order to manipulate them. The Cave meshes consists in two lists: a list with all the vertex information (for each vertice, its position, normal, uv and so on) and a list of indices to build the faces with. The indices are basically integer numbers that corresponds to a vertice in the vertex list. Every 3 consecutive indexes in the indices list corresponds to a Triangle . So if you want to create a triangle mesh, the vertex list will probably have 3 Vertex elements, one for each corner of the triangle, and the indices will likely to be: [0, 1, 2] . You'll see below that the cave.Mesh class does have python lists for both of those elements, called vertices and indices , respectively. They behave as normal python lists, supporting all the operators that you expect to it, such as append and remove. IMPORTANT: Be aware that after any modification to a mesh, you need to update it in the GPU. That can be done by calling the Mesh's reload() method. Keep in mind that this operation is expensive and may cause performance issues if you call it every frame (for example). How to get a Mesh Instance? The way you'll tipically get a Mesh class instance is by retrieving them from a MeshComponent , do NOT try to create your own instance from scratch , it will not work. Here is an example of how it's done: # Getting the mesh component: meshComponent = self.entity.get(\"Mesh\") # Getting the mesh: mesh = meshComponent.getMesh() # If you want to change the mesh of a specific Entity, # you can duplicate it and reassign to the Component: meshCopy = mesh.getCopy() meshComponent.setMesh(meshCopy) # Now you'll be able to do local changes to the *meshCopy*: print(meshCopy.indices) Documentation Here is the full documentation: cave.Vertex This class describes a Vertex. You can instantiate it in your code and when you do it, all the variables will be initialized with zeros and the jointIDs will all be -1 (meaning that there is no bone influencing the vertex). Sample code: v = cave.Vertex() v.position = cave.Vector3(0,1,0) # And so on... Variables API reference: position: Vector3 normal: Vector3 tangent: Vector3 uv: Vector2 jointWeights: Vector4 jointIDs: Vector4 Here is the description of every variable in the Vertex class: Variable Description position The local position of the Vertex. Keep in mind that the Entity's transform will be taken into account automatically by the GPU code, so you don't need to consider it here. normal The local normal of the Vertex, that represents the direction that it is looking at. Mainly used for shading and also takes the Entity's transform into account. Read this for more details . tangent The local tangent of the Vertex. Same details as the normal, read this for more details . uv The UV mapped coordinates of the Vertex (in 2D space). This is used to texture the Mesh and does not take (or need to) the Entity's transform into account. Read this for more details . If the mesh was intended to be used with an Armature , it will contain bone influence data. In cave, a vertex can only be influenced by up to 4 bones. The total weight of all the influenced bones must be equal to 1.0 (otherwise you'll see some animation artefacts). For each bone, its weight needs to be set into the joinWeights variable and its bone ID in the jointIDs . If there is no bone influencing the vertex, the ID should be -1. Notice that both variables have the type Vector4. Meaning that each bone that influences the vertex (again, up to 4), will correspond to an ID of the vector (0 to 3, or .x to .z ). Variable Description jointWeights For each dimension of the vector (up to 4), the bone weight (if any). The bone's ID is set in the variable below, if -1, the number here will be ignored. jointIDs For each dimension of the vector (up to 4), the corresponding bone ID to map in the armature. If there is no bone, it should be set to -1. cave.Mesh This is the main mesh class. As explained above, here is where you can add or remove vertices and use the indices to connect them as triangles. Polygons (a face with more than 3 vertices) are not directly supported and you should convert triangulate them before adding to the indices list. Variables Both lists below are treated as python lists, supporting all its operations. vertices : list of Vertex indices : list of ints Methods Aftet doing any change to the Mesh (such as adding or removing elements from the vertices and indices or modifying them, like changing a vertex's position), you need to reload the Mesh in order to update the GPU with the new values. It can be done by calling this function below. NOTE: it may be expensive, depending on the amount of polygons you have! reload() If you need to duplicate a mesh (in order to do local changes to a specific Entity, for example), this is what you're looking for. It will duplicate the mesh and add it to the game data! GetCopy() -> Mesh","title":"Mesh Manipulation"},{"location":"PythonAPI/Assets/meshes/#mesh-related-assets","text":"Just like the materials, in order to manipulate Meshes, you'll need to acknowledge two main classes: Vertex and Mesh . We highly recommend that you have a basic knowledge on how Meshes works before attempting to work with the Mesh Manipulation APIs provided below. This is a good start if you don't have experience with it. Before jumping to the class Documentation , I'll explain how Cave Engine handles meshes, so you can have a better knowledge of it in order to manipulate them. The Cave meshes consists in two lists: a list with all the vertex information (for each vertice, its position, normal, uv and so on) and a list of indices to build the faces with. The indices are basically integer numbers that corresponds to a vertice in the vertex list. Every 3 consecutive indexes in the indices list corresponds to a Triangle . So if you want to create a triangle mesh, the vertex list will probably have 3 Vertex elements, one for each corner of the triangle, and the indices will likely to be: [0, 1, 2] . You'll see below that the cave.Mesh class does have python lists for both of those elements, called vertices and indices , respectively. They behave as normal python lists, supporting all the operators that you expect to it, such as append and remove. IMPORTANT: Be aware that after any modification to a mesh, you need to update it in the GPU. That can be done by calling the Mesh's reload() method. Keep in mind that this operation is expensive and may cause performance issues if you call it every frame (for example).","title":"Mesh Related Assets"},{"location":"PythonAPI/Assets/meshes/#how-to-get-a-mesh-instance","text":"The way you'll tipically get a Mesh class instance is by retrieving them from a MeshComponent , do NOT try to create your own instance from scratch , it will not work. Here is an example of how it's done: # Getting the mesh component: meshComponent = self.entity.get(\"Mesh\") # Getting the mesh: mesh = meshComponent.getMesh() # If you want to change the mesh of a specific Entity, # you can duplicate it and reassign to the Component: meshCopy = mesh.getCopy() meshComponent.setMesh(meshCopy) # Now you'll be able to do local changes to the *meshCopy*: print(meshCopy.indices)","title":"How to get a Mesh Instance?"},{"location":"PythonAPI/Assets/meshes/#documentation","text":"Here is the full documentation:","title":"Documentation"},{"location":"PythonAPI/Assets/meshes/#cavevertex","text":"This class describes a Vertex. You can instantiate it in your code and when you do it, all the variables will be initialized with zeros and the jointIDs will all be -1 (meaning that there is no bone influencing the vertex). Sample code: v = cave.Vertex() v.position = cave.Vector3(0,1,0) # And so on...","title":"cave.Vertex"},{"location":"PythonAPI/Assets/meshes/#variables","text":"API reference: position: Vector3 normal: Vector3 tangent: Vector3 uv: Vector2 jointWeights: Vector4 jointIDs: Vector4 Here is the description of every variable in the Vertex class: Variable Description position The local position of the Vertex. Keep in mind that the Entity's transform will be taken into account automatically by the GPU code, so you don't need to consider it here. normal The local normal of the Vertex, that represents the direction that it is looking at. Mainly used for shading and also takes the Entity's transform into account. Read this for more details . tangent The local tangent of the Vertex. Same details as the normal, read this for more details . uv The UV mapped coordinates of the Vertex (in 2D space). This is used to texture the Mesh and does not take (or need to) the Entity's transform into account. Read this for more details . If the mesh was intended to be used with an Armature , it will contain bone influence data. In cave, a vertex can only be influenced by up to 4 bones. The total weight of all the influenced bones must be equal to 1.0 (otherwise you'll see some animation artefacts). For each bone, its weight needs to be set into the joinWeights variable and its bone ID in the jointIDs . If there is no bone influencing the vertex, the ID should be -1. Notice that both variables have the type Vector4. Meaning that each bone that influences the vertex (again, up to 4), will correspond to an ID of the vector (0 to 3, or .x to .z ). Variable Description jointWeights For each dimension of the vector (up to 4), the bone weight (if any). The bone's ID is set in the variable below, if -1, the number here will be ignored. jointIDs For each dimension of the vector (up to 4), the corresponding bone ID to map in the armature. If there is no bone, it should be set to -1.","title":"Variables"},{"location":"PythonAPI/Assets/meshes/#cavemesh","text":"This is the main mesh class. As explained above, here is where you can add or remove vertices and use the indices to connect them as triangles. Polygons (a face with more than 3 vertices) are not directly supported and you should convert triangulate them before adding to the indices list.","title":"cave.Mesh"},{"location":"PythonAPI/Assets/meshes/#variables_1","text":"Both lists below are treated as python lists, supporting all its operations. vertices : list of Vertex indices : list of ints","title":"Variables"},{"location":"PythonAPI/Assets/meshes/#methods","text":"Aftet doing any change to the Mesh (such as adding or removing elements from the vertices and indices or modifying them, like changing a vertex's position), you need to reload the Mesh in order to update the GPU with the new values. It can be done by calling this function below. NOTE: it may be expensive, depending on the amount of polygons you have! reload() If you need to duplicate a mesh (in order to do local changes to a specific Entity, for example), this is what you're looking for. It will duplicate the mesh and add it to the game data! GetCopy() -> Mesh","title":"Methods"},{"location":"PythonAPI/Components/gameplay/","text":"Gameplay Related Components Cave Engine prodives some builtin Gameplay Related components for you to use out of the box in your games. You'll find their documentation here. cave.PlayerComponent The PlayerComponent is a builtin component that you can use to add player controls to a Character. It will allow the user to move your entity around with W, A, S, D , jump with Space and run with Left Shift . (Note that the Player Component will only work if its Entity also have a CharacterComponent ). Variables Variable Description active The PlayerComponent will only run if this is set to True (as it is by default). You can use this do temporarely disable the Player's movement. walkSpeed Defines the Player's walk speed. runSpeed Defines the Player's run speed. localMovement If true, the Player will walk in local space, meaning that \"forward\" refers to the actual Entity's Transform's forward. jump The Player will only jump if this is set to True . Here is the Python API for Reference: active : bool walkSpeed : float runSpeed : float localMovement : bool jump : bool Methods isWalking() -> bool isRunning() -> bool cave.MouselookComponent If you want to make a Mouselook, you can use this builtin Cave Component to achieve that. That's useful for first and third person games, but not limited to it: This component works with any Entity (not only cameras), so feel free to use your creativity in order to get the best out of it. Variables Variable Description lockMousePos If True , it will disable the mouse visibility and lock it to the center of the screen. When doing a mouselook, that's probably what you expect it to do. xAxis Use this to adjust the mouse X axis (horizontal) behaviour. yAxis Use this to adjust the mouse Y axis (vertical) behaviour. Here is the Python API for Reference: lockMousePos : bool xAxis : cave.MouselookAxisConfig yAxis : cave.MouselookAxisConfig cave.MouselookAxisConfig This is a class designed to provide configuration settings for the MouselookComponent . You'll only find it there. Variables Variable Description use If True , the Mouselook will use this Axis. rotationLocal If True , it will apply a local rotation in the Transform. Global, otherwise. rotationAxis Can be 0, 1 or 2 , representing the X, Y and Z axis, respectively. sensitivity The Mouselook sentitivity in this Axis. Tip: if you want to invert the mouselook, you can set a negative sensitivity. threshold The minimum mouse movement before it starts considering it. Here is the Python API for Reference: use : bool rotationLocal : bool rotationAxis : int sensitivity : float threshold : float","title":"Gameplay Components"},{"location":"PythonAPI/Components/gameplay/#gameplay-related-components","text":"Cave Engine prodives some builtin Gameplay Related components for you to use out of the box in your games. You'll find their documentation here.","title":"Gameplay Related Components"},{"location":"PythonAPI/Components/gameplay/#caveplayercomponent","text":"The PlayerComponent is a builtin component that you can use to add player controls to a Character. It will allow the user to move your entity around with W, A, S, D , jump with Space and run with Left Shift . (Note that the Player Component will only work if its Entity also have a CharacterComponent ).","title":"cave.PlayerComponent"},{"location":"PythonAPI/Components/gameplay/#variables","text":"Variable Description active The PlayerComponent will only run if this is set to True (as it is by default). You can use this do temporarely disable the Player's movement. walkSpeed Defines the Player's walk speed. runSpeed Defines the Player's run speed. localMovement If true, the Player will walk in local space, meaning that \"forward\" refers to the actual Entity's Transform's forward. jump The Player will only jump if this is set to True . Here is the Python API for Reference: active : bool walkSpeed : float runSpeed : float localMovement : bool jump : bool","title":"Variables"},{"location":"PythonAPI/Components/gameplay/#methods","text":"isWalking() -> bool isRunning() -> bool","title":"Methods"},{"location":"PythonAPI/Components/gameplay/#cavemouselookcomponent","text":"If you want to make a Mouselook, you can use this builtin Cave Component to achieve that. That's useful for first and third person games, but not limited to it: This component works with any Entity (not only cameras), so feel free to use your creativity in order to get the best out of it.","title":"cave.MouselookComponent"},{"location":"PythonAPI/Components/gameplay/#variables_1","text":"Variable Description lockMousePos If True , it will disable the mouse visibility and lock it to the center of the screen. When doing a mouselook, that's probably what you expect it to do. xAxis Use this to adjust the mouse X axis (horizontal) behaviour. yAxis Use this to adjust the mouse Y axis (vertical) behaviour. Here is the Python API for Reference: lockMousePos : bool xAxis : cave.MouselookAxisConfig yAxis : cave.MouselookAxisConfig","title":"Variables"},{"location":"PythonAPI/Components/gameplay/#cavemouselookaxisconfig","text":"This is a class designed to provide configuration settings for the MouselookComponent . You'll only find it there.","title":"cave.MouselookAxisConfig"},{"location":"PythonAPI/Components/gameplay/#variables_2","text":"Variable Description use If True , the Mouselook will use this Axis. rotationLocal If True , it will apply a local rotation in the Transform. Global, otherwise. rotationAxis Can be 0, 1 or 2 , representing the X, Y and Z axis, respectively. sensitivity The Mouselook sentitivity in this Axis. Tip: if you want to invert the mouselook, you can set a negative sensitivity. threshold The minimum mouse movement before it starts considering it. Here is the Python API for Reference: use : bool rotationLocal : bool rotationAxis : int sensitivity : float threshold : float","title":"Variables"},{"location":"PythonAPI/Components/graphics/","text":"Graphics Related Components In this page you'll find all the 3D Graphics related Components and their Python API documentation. Meshes cave.MeshComponent Variables The MeshComponent only have one variable: the tint color. All the others parameters must be manipulated using their getters and setters. The tint is the color you want to tint the mesh to. Defaults to white (meaning no tint). Reference: tint : cave.Vector4 Methods The first thing that you may want to do is manipulate the Mesh used by this component (please read the cave.Mesh documentation for details). You can do it so by calling one of the following methods: getMesh() -> cave.Mesh setMesh(meshName: str) setMesh(mesh: cave.Mesh) Then you may want to manipulate the Material , that works in the same way. (Please read the cave.Material documentation for details). Reference: getMaterial() -> cave.Material setMaterial(matName: str) setMaterial(mat: cave.Material) You can also change the Armature used by the Mesh Component. Note that this one does not have a Python API yet, so you can only get and set it using its name (as a string). As you can see here: # Will return the name of the armature! getArmature() -> str setArmature(armatureName: str) - Working with Animations Cave's animation system is simple but versatile: Every MeshComponent have an Animation Stack, that is a list of animations currently being played. The purpose of this list is to allow you to blend different animations together or even play multiple ones at the same time. The Stack stores what we call cave.AnimationHandler (more on that later in this page). At the moment, you can't fully manipulate this stack via Python API, but you can do it so by using one of Cave's Animators assets . Still, there are some very useful things already possible to do via Python. The reason why it was important to explain the existance of this stack is because there is an important different between the animation at the top of the animation stack and the animation assigned to the MeshComponent itself. Let's use the RandomAnimator Asset for example. It is an animation type that you can actually set to the Mesh Component. But it's not a \"raw\" animation that the engine can directly execute for the Armature. But the RandomAnimator may have raw animations inside of it. The animations in the Animation Stack will most likely to be raw animations (that can be internally player directly by the Armature) and the animation in the MeshComponent itself can be anything, including a higher level one (such as the RandomAnimator ). For instance, that's why you can't fully manipulate the animation stack via Python: most of the times, the engine itself will internally decide what to do with it based on the actual animation asset you've added to the MeshComponent . But as you'll see below, it's useful for you to know the existence of the stack and even get the cave.AnimationHandler on top of it. So let's get started! First of all, if you want to change the actual Animation Asset of the MeshComponent , you can do it so by using their getter and setter. Notice that the animation asset does not have a Python representation yet, so you'll be manipulating them using their names (as they appear in the Asset Browser). getAnimation() -> str # If the blendTime is greated than zero, it will blend in the new animation! setAnimation(animation: str, blendTime=0.0) If you want to know the exact \"raw\" animation being executed or some of its current playing status (such as its execution progress or how many times it looped), you can use one of those APIs: # Will return the Animation name on top of the stack getAnimationFromStack() -> str # Returns how many times the current animation (top of the stack) looped the execution getAnimationLoops() -> int # Returns the animation progress, from [0 to 1] getAnimationProgress() -> float Or if you want even more information ( and control ) of the animation, you can consider getting its cave.AnimationHandler directly. IMPORTANT: Do NOT store this handler into a variable for more than a frame, because it may be freed internally by the engine, causing your game to \"explode\"! (crash) getAnimationHandler() -> cave.AnimationHandler Check the cave.AnimationHandler class reference below for more information on it. cave.AnimationHandler As explained, this Handler will give you information and control over the currently played animation (by the MeshComponent ). Do NOT store this handler into a variable for more than a frame, because it may be freed internally by the engine, causing your game to \"explode\"! (crash) The handler will give you a lot of freedom and options when manipulating the Animations, so enjoy it! Variables Variable Description frame The scurrent Animation Frame. speed The animation execution Speed. 1.0 means normal speed. influence Influence ranges from [0.0 to 1.0] and determines how much this animation will influence the final Armature Pose. If the animation stack have multiple animations, this will also determine the blend between them (and it is used by the engine to blend in/out animations). Note: If you set the influence, it will also cancel any existing blend. Here is the Python API for Reference: frame : float speed : float influence : float Methods Another way to set/set the animation frame , speed and influence (other than by their variables), is to call their getters and setters: getCurrentFrame() -> float setCurrentFrame(frame: float) getSpeed() -> float setSpeed(speed: float) getInfluence() -> float # Note: If you set the influence, it will also cancel any existing blend setInfluence(influence: float) The methods below will provide you additional information regarding the execution progress. # Returns how many times the animation looped: getLoops() -> int # Range [0 to 1], the animation's execution progress: getProgress() -> float # True if the animation is Paused: isPaused() -> bool # Returns true if, for some reason, the animation is finished. # For example: if the user asked to play it only once or a blendOut() isFinished() -> bool Tip: If you want to see if the animation \"finished\" its execution without the isFinished (that may not work in all situations), a good and easy option is to see if the getLoops() value is greated than zero. To control the animation execution, you can use one of those methods: pause() resume() # Freezes the animation on a specific frame: freeze(frame: float) And last but not least, you can blend in or out an animation any time you want by calling: blendIn(durationInSeconds= 1.0, resetInfluence=True) blendOut(durationInSeconds= 1.0) Particles cave.ParticleComponent The ParticleComponent actually **inherits from MeshComponent , meaning that everything that you've already learned at the Mesh Component's documentation will actually work here (and I'll not explain it twice). The only different is those two extra variables: Variables Variable Description instance Stores all the details on how the Particles will behave. See cave.ParticleInstanceDescriptor 's documentation below for more details on it. duration The current duration time of the particle. Used to determine its behavior. Here is the Python API for Reference: instance : cave.ParticleInstanceDescriptor duration : cave.SceneTimer cave.ParticleInstanceDescriptor As you saw above, the cave.ParticleInstanceDescriptor is a storage class containing all the information on how the Particles will behave in the ParticleComponent . Variables Variable Description count The amount of particles spawned by the component. Keep in mind that a lot of particles costs performance. spawnArea The boxed area that the particles should spawn at. Regarding the Spawn, you can specify a minimum and maximum range for the particle's scale and rotation by using the scaleMin/Max and rotationMin/Max variables. Variable Description isDynamic Dynamic particles basically means that they will be updated every frame. You want this to be True for all the Particle Systems that moves in your scene. If you're using the Particle System to add static elements such as Stars or Trees, then they should not be Dynamic . Dynamic particles are slower. useParent If tru True , the particles will be parented to the Entity and move with it. life The particle's Lifetime (in seconds). ZERO means it will life forever. respawn Respawn window of the particles. In other words, for for many time (in seconds) should the ParticleComponent keep respawning particles. ZERO means forever. Other than controlling the Particle's Spawn settings, you can also control its lifetime behavior using those variables below: | Variable | Description | |:-----------|-------------------------| | gravity | Gravity applied to the Particles. Tip: If you want to make smoke, you can apply a negative gravity, so they will fly to the air! | In order to move the particles, you can rely on the linear and angular forces , that will affect the particle's position and rotation , respectively. For each force, you'll be prompted with a Velocity variable ( linearVelocity and angularVelocity ) and a Friction ( linearFriction and angularFriction ), that represents the resistance that the particle will find regarding that specific force. Here is the Python API for Reference: count : int spawnArea : cave.Vector3 scaleMin : cave.Vector3 scaleMax : cave.Vector3 rotationMin : cave.Vector3 rotationMax : cave.Vector3 isDynamic : bool useParent : bool life : float respawn : float gravity : cave.Vector3 linearVelocity : cave.Vector3 linearFriction : cave.Vector3 angularVelocity : cave.Vector3 angularFriction : cave.Vector3 Others cave.DecalComponent Variables Variable Description material The cave.Material used by the Decal. opacity Decal opacity, ranging from [0 to 1] . layer Used to sort the decals. angleFade If True , it will fade out according to the angle. Here is the Python API for Reference: material : cave.Material opacity : float layer : int angleFade : bool cave.LightComponent You can adjust various light parameters. Here is a sample code that makes the light color pulse using some timers and the python native math.sin() function: import cave import math import random class PulsingLight(cave.Component): def start(self, scene): self.speed = 2.0 # Creating some timers with a random value to sample from self.colorX = cave.SceneTimer(random.random()) self.colorY = cave.SceneTimer(random.random()) self.colorZ = cave.SceneTimer(random.random()) def compute(self, value): # Maps the timer into a sin curve ranged [0 - 1] return (math.sin(value * self.speed) + 1) / 2 def update(self): light = self.entity.get(\"Light Component\") light.color.x = self.compute(self.colorX.get()) light.color.y = self.compute(self.colorY.get()) light.color.z = self.compute(self.colorZ.get()) print(light.color.x, light.color.y, light.color.z) # Don't forget to reload the light, otherwise it will not be updated: light.reload() def end(self, scene): pass NOTE: Lights are pre cached so the changes you made in the following parameters will not be effective (applied to the light) until you call the reload() method. Variables color : cave.Vector3 radius : float intensity : float","title":"Graphics Components"},{"location":"PythonAPI/Components/graphics/#graphics-related-components","text":"In this page you'll find all the 3D Graphics related Components and their Python API documentation.","title":"Graphics Related Components"},{"location":"PythonAPI/Components/graphics/#meshes","text":"","title":"Meshes"},{"location":"PythonAPI/Components/graphics/#cavemeshcomponent","text":"","title":"cave.MeshComponent"},{"location":"PythonAPI/Components/graphics/#variables","text":"The MeshComponent only have one variable: the tint color. All the others parameters must be manipulated using their getters and setters. The tint is the color you want to tint the mesh to. Defaults to white (meaning no tint). Reference: tint : cave.Vector4","title":"Variables"},{"location":"PythonAPI/Components/graphics/#methods","text":"The first thing that you may want to do is manipulate the Mesh used by this component (please read the cave.Mesh documentation for details). You can do it so by calling one of the following methods: getMesh() -> cave.Mesh setMesh(meshName: str) setMesh(mesh: cave.Mesh) Then you may want to manipulate the Material , that works in the same way. (Please read the cave.Material documentation for details). Reference: getMaterial() -> cave.Material setMaterial(matName: str) setMaterial(mat: cave.Material) You can also change the Armature used by the Mesh Component. Note that this one does not have a Python API yet, so you can only get and set it using its name (as a string). As you can see here: # Will return the name of the armature! getArmature() -> str setArmature(armatureName: str)","title":"Methods"},{"location":"PythonAPI/Components/graphics/#-working-with-animations","text":"Cave's animation system is simple but versatile: Every MeshComponent have an Animation Stack, that is a list of animations currently being played. The purpose of this list is to allow you to blend different animations together or even play multiple ones at the same time. The Stack stores what we call cave.AnimationHandler (more on that later in this page). At the moment, you can't fully manipulate this stack via Python API, but you can do it so by using one of Cave's Animators assets . Still, there are some very useful things already possible to do via Python. The reason why it was important to explain the existance of this stack is because there is an important different between the animation at the top of the animation stack and the animation assigned to the MeshComponent itself. Let's use the RandomAnimator Asset for example. It is an animation type that you can actually set to the Mesh Component. But it's not a \"raw\" animation that the engine can directly execute for the Armature. But the RandomAnimator may have raw animations inside of it. The animations in the Animation Stack will most likely to be raw animations (that can be internally player directly by the Armature) and the animation in the MeshComponent itself can be anything, including a higher level one (such as the RandomAnimator ). For instance, that's why you can't fully manipulate the animation stack via Python: most of the times, the engine itself will internally decide what to do with it based on the actual animation asset you've added to the MeshComponent . But as you'll see below, it's useful for you to know the existence of the stack and even get the cave.AnimationHandler on top of it. So let's get started! First of all, if you want to change the actual Animation Asset of the MeshComponent , you can do it so by using their getter and setter. Notice that the animation asset does not have a Python representation yet, so you'll be manipulating them using their names (as they appear in the Asset Browser). getAnimation() -> str # If the blendTime is greated than zero, it will blend in the new animation! setAnimation(animation: str, blendTime=0.0) If you want to know the exact \"raw\" animation being executed or some of its current playing status (such as its execution progress or how many times it looped), you can use one of those APIs: # Will return the Animation name on top of the stack getAnimationFromStack() -> str # Returns how many times the current animation (top of the stack) looped the execution getAnimationLoops() -> int # Returns the animation progress, from [0 to 1] getAnimationProgress() -> float Or if you want even more information ( and control ) of the animation, you can consider getting its cave.AnimationHandler directly. IMPORTANT: Do NOT store this handler into a variable for more than a frame, because it may be freed internally by the engine, causing your game to \"explode\"! (crash) getAnimationHandler() -> cave.AnimationHandler Check the cave.AnimationHandler class reference below for more information on it.","title":"- Working with Animations"},{"location":"PythonAPI/Components/graphics/#caveanimationhandler","text":"As explained, this Handler will give you information and control over the currently played animation (by the MeshComponent ). Do NOT store this handler into a variable for more than a frame, because it may be freed internally by the engine, causing your game to \"explode\"! (crash) The handler will give you a lot of freedom and options when manipulating the Animations, so enjoy it!","title":"cave.AnimationHandler"},{"location":"PythonAPI/Components/graphics/#variables_1","text":"Variable Description frame The scurrent Animation Frame. speed The animation execution Speed. 1.0 means normal speed. influence Influence ranges from [0.0 to 1.0] and determines how much this animation will influence the final Armature Pose. If the animation stack have multiple animations, this will also determine the blend between them (and it is used by the engine to blend in/out animations). Note: If you set the influence, it will also cancel any existing blend. Here is the Python API for Reference: frame : float speed : float influence : float","title":"Variables"},{"location":"PythonAPI/Components/graphics/#methods_1","text":"Another way to set/set the animation frame , speed and influence (other than by their variables), is to call their getters and setters: getCurrentFrame() -> float setCurrentFrame(frame: float) getSpeed() -> float setSpeed(speed: float) getInfluence() -> float # Note: If you set the influence, it will also cancel any existing blend setInfluence(influence: float) The methods below will provide you additional information regarding the execution progress. # Returns how many times the animation looped: getLoops() -> int # Range [0 to 1], the animation's execution progress: getProgress() -> float # True if the animation is Paused: isPaused() -> bool # Returns true if, for some reason, the animation is finished. # For example: if the user asked to play it only once or a blendOut() isFinished() -> bool Tip: If you want to see if the animation \"finished\" its execution without the isFinished (that may not work in all situations), a good and easy option is to see if the getLoops() value is greated than zero. To control the animation execution, you can use one of those methods: pause() resume() # Freezes the animation on a specific frame: freeze(frame: float) And last but not least, you can blend in or out an animation any time you want by calling: blendIn(durationInSeconds= 1.0, resetInfluence=True) blendOut(durationInSeconds= 1.0)","title":"Methods"},{"location":"PythonAPI/Components/graphics/#particles","text":"","title":"Particles"},{"location":"PythonAPI/Components/graphics/#caveparticlecomponent","text":"The ParticleComponent actually **inherits from MeshComponent , meaning that everything that you've already learned at the Mesh Component's documentation will actually work here (and I'll not explain it twice). The only different is those two extra variables:","title":"cave.ParticleComponent"},{"location":"PythonAPI/Components/graphics/#variables_2","text":"Variable Description instance Stores all the details on how the Particles will behave. See cave.ParticleInstanceDescriptor 's documentation below for more details on it. duration The current duration time of the particle. Used to determine its behavior. Here is the Python API for Reference: instance : cave.ParticleInstanceDescriptor duration : cave.SceneTimer","title":"Variables"},{"location":"PythonAPI/Components/graphics/#caveparticleinstancedescriptor","text":"As you saw above, the cave.ParticleInstanceDescriptor is a storage class containing all the information on how the Particles will behave in the ParticleComponent .","title":"cave.ParticleInstanceDescriptor"},{"location":"PythonAPI/Components/graphics/#variables_3","text":"Variable Description count The amount of particles spawned by the component. Keep in mind that a lot of particles costs performance. spawnArea The boxed area that the particles should spawn at. Regarding the Spawn, you can specify a minimum and maximum range for the particle's scale and rotation by using the scaleMin/Max and rotationMin/Max variables. Variable Description isDynamic Dynamic particles basically means that they will be updated every frame. You want this to be True for all the Particle Systems that moves in your scene. If you're using the Particle System to add static elements such as Stars or Trees, then they should not be Dynamic . Dynamic particles are slower. useParent If tru True , the particles will be parented to the Entity and move with it. life The particle's Lifetime (in seconds). ZERO means it will life forever. respawn Respawn window of the particles. In other words, for for many time (in seconds) should the ParticleComponent keep respawning particles. ZERO means forever. Other than controlling the Particle's Spawn settings, you can also control its lifetime behavior using those variables below: | Variable | Description | |:-----------|-------------------------| | gravity | Gravity applied to the Particles. Tip: If you want to make smoke, you can apply a negative gravity, so they will fly to the air! | In order to move the particles, you can rely on the linear and angular forces , that will affect the particle's position and rotation , respectively. For each force, you'll be prompted with a Velocity variable ( linearVelocity and angularVelocity ) and a Friction ( linearFriction and angularFriction ), that represents the resistance that the particle will find regarding that specific force. Here is the Python API for Reference: count : int spawnArea : cave.Vector3 scaleMin : cave.Vector3 scaleMax : cave.Vector3 rotationMin : cave.Vector3 rotationMax : cave.Vector3 isDynamic : bool useParent : bool life : float respawn : float gravity : cave.Vector3 linearVelocity : cave.Vector3 linearFriction : cave.Vector3 angularVelocity : cave.Vector3 angularFriction : cave.Vector3","title":"Variables"},{"location":"PythonAPI/Components/graphics/#others","text":"","title":"Others"},{"location":"PythonAPI/Components/graphics/#cavedecalcomponent","text":"","title":"cave.DecalComponent"},{"location":"PythonAPI/Components/graphics/#variables_4","text":"Variable Description material The cave.Material used by the Decal. opacity Decal opacity, ranging from [0 to 1] . layer Used to sort the decals. angleFade If True , it will fade out according to the angle. Here is the Python API for Reference: material : cave.Material opacity : float layer : int angleFade : bool","title":"Variables"},{"location":"PythonAPI/Components/graphics/#cavelightcomponent","text":"You can adjust various light parameters. Here is a sample code that makes the light color pulse using some timers and the python native math.sin() function: import cave import math import random class PulsingLight(cave.Component): def start(self, scene): self.speed = 2.0 # Creating some timers with a random value to sample from self.colorX = cave.SceneTimer(random.random()) self.colorY = cave.SceneTimer(random.random()) self.colorZ = cave.SceneTimer(random.random()) def compute(self, value): # Maps the timer into a sin curve ranged [0 - 1] return (math.sin(value * self.speed) + 1) / 2 def update(self): light = self.entity.get(\"Light Component\") light.color.x = self.compute(self.colorX.get()) light.color.y = self.compute(self.colorY.get()) light.color.z = self.compute(self.colorZ.get()) print(light.color.x, light.color.y, light.color.z) # Don't forget to reload the light, otherwise it will not be updated: light.reload() def end(self, scene): pass NOTE: Lights are pre cached so the changes you made in the following parameters will not be effective (applied to the light) until you call the reload() method.","title":"cave.LightComponent"},{"location":"PythonAPI/Components/graphics/#variables_5","text":"color : cave.Vector3 radius : float intensity : float","title":"Variables"},{"location":"PythonAPI/Components/interface/","text":"Game UI Components As you may know, Cave Engine allows you to create custom in game UIs by using some Builtin Components. Here you'll find their available Python APIs. cave.UIElementComponent Variables If the Element have a Font, you can type texts in it do be displayed in your game. For this, use the text variable: text : str In order to position and scale your UI element, you can use those variables: position : cave.UIVector scale : cave.UIVector _ Note: Read the cave.UIVector 's Documentation in the Math section of this API._ You can change the component's color by adjusting one of those variables: quadAlpha : float quadColor : cave.Vector Methods To see if the user is hovering your UI element, you can use thid method: isHovered() -> bool","title":"Game UI"},{"location":"PythonAPI/Components/interface/#game-ui-components","text":"As you may know, Cave Engine allows you to create custom in game UIs by using some Builtin Components. Here you'll find their available Python APIs.","title":"Game UI Components"},{"location":"PythonAPI/Components/interface/#caveuielementcomponent","text":"","title":"cave.UIElementComponent"},{"location":"PythonAPI/Components/interface/#variables","text":"If the Element have a Font, you can type texts in it do be displayed in your game. For this, use the text variable: text : str In order to position and scale your UI element, you can use those variables: position : cave.UIVector scale : cave.UIVector _ Note: Read the cave.UIVector 's Documentation in the Math section of this API._ You can change the component's color by adjusting one of those variables: quadAlpha : float quadColor : cave.Vector","title":"Variables"},{"location":"PythonAPI/Components/interface/#methods","text":"To see if the user is hovering your UI element, you can use thid method: isHovered() -> bool","title":"Methods"},{"location":"PythonAPI/Components/physics/","text":"Physics Related Components In this Page you'll find all the Physics related Components that Cave provides to your. Character Physics Starting with a very important one: the cave.CharacterComponent . If you're creating a regular character for your game, you'll probably use this one. cave.CharacterComponent Variables Variable Description fallSpeed The max fall speed of the character. gravity The gravity that will be applied to the character. It is different from the physics world's gravity because you may want to control this separately for your characters. jumpSpeed As the name suggests, the jump speed. The higher this number is, the higher the character will jump. maxSlope The max slope angle that the character can climb. Here is the Python API for Reference: fallSpeed : float gravity : float jumpSpeed : float maxSlope : float Methods If you want the character to jump, just call this: jump() In order to detect collisions, you ca use one of those methods below. Check the Scene's cave.CollisionInfo Documentation for more information regarding it. getCollisions() -> list of cave.CollisionInfo getCollisionsWith(tag: str) -> list of cave.CollisionInfo collidedWith(tag: str) -> bool The Character needs to walk, right? In order to do it, you ccan use those methods below. setWalkDirection(x: float, y: float, z: float, local=True) setWalkDirection(dir: cave.Vector3, local=True) getWalkDirection(ignoreDeltaTime=False) -> cave.Vector3 Last but not least, here is some useful methods for you to get certain data from the Character Physics: getMoveSpeed(ignoreDeltaTime=False) -> float isMoving() -> bool isFalling() -> bool onGround() -> bool Rigid Body Physics Rigid bodies are useful in pretty much every situation where you need to add a Physics shape to an object. It could be Dynamic, like a Box, or Static, like your scenary props. cave.RigidBodyComponent Variables Variable Description alwaysActive If True , the Physics Engine will never let this body sleep, meaning that it will always calculate its physics condition. Having the physics shape to sleep is an optimization that you might want to have, but in some cases, like an object that really needs to be taken into account in your game like the ball of a soccer game or a flying bullet, the alwaysActive option could be a good option to have enabled. linearVelocity The Entity's linear Velocity. angularVelocity The Entity's angular Velocity. angularFactor The Entity's angular Factor. Here is the Python API for Reference: alwaysActive : bool linearVelocity : cave.Vector3 angularVelocity : cave.Vector3 angularFactor : cave.Vector3 Methods In order to detect collisions, you ca use one of those methods below. Check the Scene's cave.CollisionInfo Documentation for more information regarding it. getCollisions() -> list of cave.CollisionInfo getCollisionsWith(tag: str) -> list of cave.CollisionInfo collidedWith(tag: str) -> bool As you might know, Physics are all about forces! That's why you can apply various forces to your Rigid Body by calling one of those method below. applyTorque( x : float, y : float, z : float) applyForce( x : float, y : float, z : float, location : cave.Vector3) applyImpulse(x : float, y : float, z : float, location : cave.Vector3) If the Rigid Body is Dynamic , it means that it will fall with gravity and reach to other bodies colliding with it. isDynamic() -> bool If you set the Rigid Body's mass to ZERO, it will make the body Static (a.k.a. \"not dynamic\"). setMass(value : float) Vehicle Physics If you want to make a car or any wheeled vehicle using Cave, you can use the prodived Vehicle and Wheel physics components. Note: In order to make the VehicleComponent work, the Entity must also have a RigidBody attached to it. cave.VehicleComponent Variables The vehicle component have two important variables, both defined by their own class types. You can see their specifications and settings later in this page. Here is the Python API for Reference: engineForce : cave.VehicleEngineConfig steering : cave.VehicleSteeringConfig Methods To control the VehicleComponent yourself, you'll be doing it all by calling one of the provided methods. Meaning that you'll find useful functions here to accelerate, reverse, brake, turn and so on . You may notice that some methods have an optional scale parameter. This parameter will be used as a multiplier to the provided engine forces (variable engineForce ), useful to add local boosts to your vehicles (like nitrous or power ups). Check the API reference below: accelerate(scale=1.0) reverse(scale=1.0) # You need to call this if you're not accelerating or reversing! idle() If you want to brake, you can use the brake method. But they have an important note: If do to brake, you need to make sure to release it later (by calling brakeRelease ), otherwise the wheels will keep locked. brake(scale=1.0) brakeRelease() Most of the times, you don't want to use the applyForce method directly, sinde the acc/rev/idle methods will internally handle it. But if you want, you can! Here you go: applyForce(force) Last but not least, the following methods will allow you to turn the vehicle (steering). The steer amount is defined by the Vehicle's steering variable. Just like the acc/rev, you also need to call turnStraight when you don't want othe car to turn. turnLeft() turnRight() turnStraight() cave.VehicleEngineConfig This class is intended to allow you to controll the Vehicle's Engine settings. Variables The following variables lets you control the engine forces. Here is the Python API for Reference: acceleration : float reverse : float brake : float cave.VehicleSteeringConfig This class is a data storage to adjust the Vehicle's Wheel settings for the ones who have steering (can turn with the steering wheel). Variables Variable Description clamp Set the clamp to the max angle that you'll allow this wheel to turn. increment A higher increment mean that the wheel will turn faster. Here is the Python API for Reference: clamp : float increment : float Wheel Physics The vehicle alone is not a vehicle without their wheels! That's why you'll also find Wheel related components. Note: The Wheels must be direct children of an Entity witl a VehicleComponent , otherwise they will not work. Tip: You can add the Wheel Component to an empty Entity and then create a child Mesh Entity to represent its visual shape. That way you can have more control over how it looks and its rotation. cave.WheelComponent Variables You'll be able to adjust the wheel tuning (and suspension) as well as its controls by using one of those two class storage variables. You can find their documentation in this page. tuning : cave.WheelTuningConfig control : cave.WheelControlsConfig The variables below ranges from [0 to 5] , mapping: [X, Y, Z, -X, -Y, -Z] # default is -Y (4) dirAxis : int # default is +X (0) axleAxis : int Here you can adjust the suspension rest length and also the wheel radius: suspensionRestLength : float radius : float You can specify if the wheel is a front or back wheel here. Keep in mind that this name (\"front wheel\") is only for the ease to understand, but their practical functionality is that only wheels marked as \"front wheel\" will have steering! So you can mark any wheel you want to steer as a front wheel. isFrontWheel : bool Methods getDirection() -> cave.Vector3 getAxle() -> cave.Vector3 cave.WheelTuningConfig This class container will help you to specify all the wheel's suspension settings. Variables suspensionStiffness : float suspensionCompression : float suspensionDamping : float suspensionTravelCmMax : float suspensionForceMax : float frictionSlip : float cave.WheelControlsConfig This class container will help you to specify wheel control settings. Variables Variable Description hasTraction If True , the wheel will rotate when the VehicleComponent applies some forces (such as accelerating or reversing). hasBrake If True , the wheel will brake when the VehicleComponent requests. Here is the Python API for Reference: hasTraction : bool hasBrake : bool Vehicle Controller Just like we have a PlayerComponent to control the CharacterComponent physics, we also have this VehicleControllerComponent to control the VehicleComponent . You're not obbligated to use it since you can write your own controller by using the Vehicle's methods. But having it here definitely helps! Methods cave.VehicleControllerComponent Variables Variable Description active The VehicleControllerComponent will only run if this is set to True (as it is by default). You can use this do temporarely disable the Vehicle Controller. Here is the Python API for Reference: active: bool","title":"Physics Components"},{"location":"PythonAPI/Components/physics/#physics-related-components","text":"In this Page you'll find all the Physics related Components that Cave provides to your.","title":"Physics Related Components"},{"location":"PythonAPI/Components/physics/#character-physics","text":"Starting with a very important one: the cave.CharacterComponent . If you're creating a regular character for your game, you'll probably use this one.","title":"Character Physics"},{"location":"PythonAPI/Components/physics/#cavecharactercomponent","text":"","title":"cave.CharacterComponent"},{"location":"PythonAPI/Components/physics/#variables","text":"Variable Description fallSpeed The max fall speed of the character. gravity The gravity that will be applied to the character. It is different from the physics world's gravity because you may want to control this separately for your characters. jumpSpeed As the name suggests, the jump speed. The higher this number is, the higher the character will jump. maxSlope The max slope angle that the character can climb. Here is the Python API for Reference: fallSpeed : float gravity : float jumpSpeed : float maxSlope : float","title":"Variables"},{"location":"PythonAPI/Components/physics/#methods","text":"If you want the character to jump, just call this: jump() In order to detect collisions, you ca use one of those methods below. Check the Scene's cave.CollisionInfo Documentation for more information regarding it. getCollisions() -> list of cave.CollisionInfo getCollisionsWith(tag: str) -> list of cave.CollisionInfo collidedWith(tag: str) -> bool The Character needs to walk, right? In order to do it, you ccan use those methods below. setWalkDirection(x: float, y: float, z: float, local=True) setWalkDirection(dir: cave.Vector3, local=True) getWalkDirection(ignoreDeltaTime=False) -> cave.Vector3 Last but not least, here is some useful methods for you to get certain data from the Character Physics: getMoveSpeed(ignoreDeltaTime=False) -> float isMoving() -> bool isFalling() -> bool onGround() -> bool","title":"Methods"},{"location":"PythonAPI/Components/physics/#rigid-body-physics","text":"Rigid bodies are useful in pretty much every situation where you need to add a Physics shape to an object. It could be Dynamic, like a Box, or Static, like your scenary props.","title":"Rigid Body Physics"},{"location":"PythonAPI/Components/physics/#caverigidbodycomponent","text":"","title":"cave.RigidBodyComponent"},{"location":"PythonAPI/Components/physics/#variables_1","text":"Variable Description alwaysActive If True , the Physics Engine will never let this body sleep, meaning that it will always calculate its physics condition. Having the physics shape to sleep is an optimization that you might want to have, but in some cases, like an object that really needs to be taken into account in your game like the ball of a soccer game or a flying bullet, the alwaysActive option could be a good option to have enabled. linearVelocity The Entity's linear Velocity. angularVelocity The Entity's angular Velocity. angularFactor The Entity's angular Factor. Here is the Python API for Reference: alwaysActive : bool linearVelocity : cave.Vector3 angularVelocity : cave.Vector3 angularFactor : cave.Vector3","title":"Variables"},{"location":"PythonAPI/Components/physics/#methods_1","text":"In order to detect collisions, you ca use one of those methods below. Check the Scene's cave.CollisionInfo Documentation for more information regarding it. getCollisions() -> list of cave.CollisionInfo getCollisionsWith(tag: str) -> list of cave.CollisionInfo collidedWith(tag: str) -> bool As you might know, Physics are all about forces! That's why you can apply various forces to your Rigid Body by calling one of those method below. applyTorque( x : float, y : float, z : float) applyForce( x : float, y : float, z : float, location : cave.Vector3) applyImpulse(x : float, y : float, z : float, location : cave.Vector3) If the Rigid Body is Dynamic , it means that it will fall with gravity and reach to other bodies colliding with it. isDynamic() -> bool If you set the Rigid Body's mass to ZERO, it will make the body Static (a.k.a. \"not dynamic\"). setMass(value : float)","title":"Methods"},{"location":"PythonAPI/Components/physics/#vehicle-physics","text":"If you want to make a car or any wheeled vehicle using Cave, you can use the prodived Vehicle and Wheel physics components. Note: In order to make the VehicleComponent work, the Entity must also have a RigidBody attached to it.","title":"Vehicle Physics"},{"location":"PythonAPI/Components/physics/#cavevehiclecomponent","text":"","title":"cave.VehicleComponent"},{"location":"PythonAPI/Components/physics/#variables_2","text":"The vehicle component have two important variables, both defined by their own class types. You can see their specifications and settings later in this page. Here is the Python API for Reference: engineForce : cave.VehicleEngineConfig steering : cave.VehicleSteeringConfig","title":"Variables"},{"location":"PythonAPI/Components/physics/#methods_2","text":"To control the VehicleComponent yourself, you'll be doing it all by calling one of the provided methods. Meaning that you'll find useful functions here to accelerate, reverse, brake, turn and so on . You may notice that some methods have an optional scale parameter. This parameter will be used as a multiplier to the provided engine forces (variable engineForce ), useful to add local boosts to your vehicles (like nitrous or power ups). Check the API reference below: accelerate(scale=1.0) reverse(scale=1.0) # You need to call this if you're not accelerating or reversing! idle() If you want to brake, you can use the brake method. But they have an important note: If do to brake, you need to make sure to release it later (by calling brakeRelease ), otherwise the wheels will keep locked. brake(scale=1.0) brakeRelease() Most of the times, you don't want to use the applyForce method directly, sinde the acc/rev/idle methods will internally handle it. But if you want, you can! Here you go: applyForce(force) Last but not least, the following methods will allow you to turn the vehicle (steering). The steer amount is defined by the Vehicle's steering variable. Just like the acc/rev, you also need to call turnStraight when you don't want othe car to turn. turnLeft() turnRight() turnStraight()","title":"Methods"},{"location":"PythonAPI/Components/physics/#cavevehicleengineconfig","text":"This class is intended to allow you to controll the Vehicle's Engine settings.","title":"cave.VehicleEngineConfig"},{"location":"PythonAPI/Components/physics/#variables_3","text":"The following variables lets you control the engine forces. Here is the Python API for Reference: acceleration : float reverse : float brake : float","title":"Variables"},{"location":"PythonAPI/Components/physics/#cavevehiclesteeringconfig","text":"This class is a data storage to adjust the Vehicle's Wheel settings for the ones who have steering (can turn with the steering wheel).","title":"cave.VehicleSteeringConfig"},{"location":"PythonAPI/Components/physics/#variables_4","text":"Variable Description clamp Set the clamp to the max angle that you'll allow this wheel to turn. increment A higher increment mean that the wheel will turn faster. Here is the Python API for Reference: clamp : float increment : float","title":"Variables"},{"location":"PythonAPI/Components/physics/#wheel-physics","text":"The vehicle alone is not a vehicle without their wheels! That's why you'll also find Wheel related components. Note: The Wheels must be direct children of an Entity witl a VehicleComponent , otherwise they will not work. Tip: You can add the Wheel Component to an empty Entity and then create a child Mesh Entity to represent its visual shape. That way you can have more control over how it looks and its rotation.","title":"Wheel Physics"},{"location":"PythonAPI/Components/physics/#cavewheelcomponent","text":"","title":"cave.WheelComponent"},{"location":"PythonAPI/Components/physics/#variables_5","text":"You'll be able to adjust the wheel tuning (and suspension) as well as its controls by using one of those two class storage variables. You can find their documentation in this page. tuning : cave.WheelTuningConfig control : cave.WheelControlsConfig The variables below ranges from [0 to 5] , mapping: [X, Y, Z, -X, -Y, -Z] # default is -Y (4) dirAxis : int # default is +X (0) axleAxis : int Here you can adjust the suspension rest length and also the wheel radius: suspensionRestLength : float radius : float You can specify if the wheel is a front or back wheel here. Keep in mind that this name (\"front wheel\") is only for the ease to understand, but their practical functionality is that only wheels marked as \"front wheel\" will have steering! So you can mark any wheel you want to steer as a front wheel. isFrontWheel : bool","title":"Variables"},{"location":"PythonAPI/Components/physics/#methods_3","text":"getDirection() -> cave.Vector3 getAxle() -> cave.Vector3","title":"Methods"},{"location":"PythonAPI/Components/physics/#cavewheeltuningconfig","text":"This class container will help you to specify all the wheel's suspension settings.","title":"cave.WheelTuningConfig"},{"location":"PythonAPI/Components/physics/#variables_6","text":"suspensionStiffness : float suspensionCompression : float suspensionDamping : float suspensionTravelCmMax : float suspensionForceMax : float frictionSlip : float","title":"Variables"},{"location":"PythonAPI/Components/physics/#cavewheelcontrolsconfig","text":"This class container will help you to specify wheel control settings.","title":"cave.WheelControlsConfig"},{"location":"PythonAPI/Components/physics/#variables_7","text":"Variable Description hasTraction If True , the wheel will rotate when the VehicleComponent applies some forces (such as accelerating or reversing). hasBrake If True , the wheel will brake when the VehicleComponent requests. Here is the Python API for Reference: hasTraction : bool hasBrake : bool","title":"Variables"},{"location":"PythonAPI/Components/physics/#vehicle-controller","text":"Just like we have a PlayerComponent to control the CharacterComponent physics, we also have this VehicleControllerComponent to control the VehicleComponent . You're not obbligated to use it since you can write your own controller by using the Vehicle's methods. But having it here definitely helps!","title":"Vehicle Controller"},{"location":"PythonAPI/Components/physics/#methods_4","text":"","title":"Methods"},{"location":"PythonAPI/Components/physics/#cavevehiclecontrollercomponent","text":"","title":"cave.VehicleControllerComponent"},{"location":"PythonAPI/Components/physics/#variables_8","text":"Variable Description active The VehicleControllerComponent will only run if this is set to True (as it is by default). You can use this do temporarely disable the Vehicle Controller. Here is the Python API for Reference: active: bool","title":"Variables"},{"location":"PythonAPI/Components/transform/","text":"Transform Component cave.TransformComponent Variables position : cave.Vector3 scale : cave.Vector3 Note that you can't get/set the rotation using regular variables as you can with the position and scale . That's due to the way the engine works internally. So use the getters and setters for euler angles or quaternions to rotate as you need to. You can see the details bellow. Sample code (as it would be in the update method of a Component): transform = self.entity.getTransform() # Modifying the current euler angles by adding 0.1 on the Y axis: euler = transform.getEuler() euler.y += 0.1 transform.setEuler(euler) # or you can use this to ROTATE the object: # (will produce the same result as the approach above) transform.rotate(0, 0.1, 0) Last but no least, you can also do this variant below to Set the euler. Note that this approach will not produce the same result as the two others presented above. This one wil SET the rotation to [0, 0, 0]: transform.setEuler(0, 0, 0) Methods As explained above, the rotation can be handled by using the getters and setters for the Euler angles or Quaternion . Here is the API for reference: # Euler Angles: getEuler() -> cave.Vector3 setEuler(euler : cave.Vector3) setEuler(x : float, y : float, z : float) # Quaternions: getQuaternion() -> cave.Quaternion setQuaternion(quaternion : cave.Quaternion) setQuaternion(x : float, y : float, z : float, w: float) - Rotating a Transform In order to Rotate a Transform, other than getting and setting the euler or quaternion by hand, Cave provides a lot of different Transform methods to make your life easier. Starting with the rotate and rotateEuler . The different between them is that the first one expects the values in radians and the second, in degrees : rotate(x : float, y : float, z : float) rotateEuler(x : float, y : float, z : float) If you want to rotate the Transform around a specific axis, you can also use the rotateOnAxis method, that expects an angle (in radians) and the axis to rotate the Transform in. rotateOnAxis(angle : float, axis : cave.Vector3) Alternatively, you can rotate it around the Pitch, Yaw and Roll axis. If you don't know what is this, I strongly recommend you to read this article first . rotateOnPitch(angle : float) rotateOnYaw(angle : float) rotateOnRoll(angle : float) Talking about Roll, Pitch and Yaw, Cave Engine makes it very easy for you to retrieve those values from a Transform as well: getPitch() -> float getYaw() -> float getRoll() -> float - Moving a Transform Just like rotating, you can either manually get and set the Transform's position, this time using the position variable, or you can count on the various Cave methods provided to make your life easier. Starting with the basic move method, it will add the provided x, y, z values to the transform's position. But what makes this special is the local parameter. If True (as it is by default), it will first transform those x, y, z values to align to the Transform's orientation. Meaning that, for example, Z will always face the Transform's Forward instead of the world's +Z axis. move(x : float, y : float, z : float, local = True) Alternatively, if you want to apply the movement locally, you can also call this method directly: applyLocalMovement(x : float, y : float, z : float) applyLocalMovement(movement: cave.Vector3) If you read the Entity's Parent Documentation , you may have noticed the following sentence: Entities with a parent will have their Transforms local to their parent's Transform . In other words, the position variable will always be local to the Transform's Entity's parent. If you want to get or set it globally (what we call \"world\"), you can do it so by using this two methods: getWorldPosition() -> cave.Vector3 setWorldPosition(pos: cave.Vector3) - Useful Methods Sometimes you want to do more than simply moving or rotating a Transform. For example, you may want to also lerp it with something else or even make it look at certain direction. Cave Engine's API got you covered in all those cases! But let's start small with some other useful methods first: If you need to know what is the forward, right (and consequently left) or up direction that a Transform is pointing at, you can use those methods to easily get them: getForwardVector() -> cave.Vector3 getRightVector() -> cave.Vector3 getUpVector() -> cave.Vector3 Now, starting to get interesting, Cave provides some built in methods to make a Transform look at certain direction. Imagine that you're making a tower defense game and you want the turret to aim at the nearest enemy. This is probably what you'll be using to achieve that. Same case to make the enemy look at the player. Cave provides two different methods: lookAt and lookAtSmooth . The difference between them is that the first one will immediatly set the Transform to the final orientation and the last one will let you choose a lerp factor, giving you more options to smooth this movement. lookAt(direction : cave.Vector3, up = cave.Vector3(0, 1, 0)) lookAtSmooth(direction : cave.Vector3, lerp = 0.5, up = cave.Vector3(0, 1, 0)) It's also good to know that the lookAtSmooth internally uses Quaternion's sLerp functionalities to get the best possible result. If you don't know what's that, I recommend you reading this Article . Talking about lerp... you can lerp the Transform's quaternions with another directly by using this method: slerpQuaternion(target : cave.Quaternion, value=0.5) And if that's not enough for you, it's possible to lerp the entire Transform with another by calling this: lerp(target : cave.TransformComponent, value=0.5) It also uses slerp internally. This method is very useful if you want to smoothly make a Entity go to a specific place in the world. Let's say that you're about to execute a live action cutscene animation and you want the player to be in a specific spot. Instead of drastically setting the player's position, rotation and scale to that spot, causing it to \"teleport\" right in front of who is playing your game, you can lerp the Transform to the final and desired one. Good! - Transforming a Vector Sometimes you want to work with Vector math but also take into account the Entity's Transform, meaning that you may want to do some operations to make the vector's transform or rotation local or global and so on. Cave Engine provides some specific methods to help you with that. If you know Vector, Quaternion and Matrices math, you'll probably understand out of the box what those methods are, but I'll try to explain them in details. The first set of helpful methods are to rotate or unrotate a Vector by the Transform's rotation. As an example, if you rotate the vector (0, 0, 1) , it will endup looking at the Transform's forward direction. (If you know the math behind it, those functions basicaly means quat * vec and inverse(quat) * vec , respectively). rotateVector(vec : cave.Vector3) -> cave.Vector3 unrotateVector(vec : cave.Vector3) -> cave.Vector3 The second set of helpful methods are to transform or untransform a Vector by the Transform. They work in the same way as the rotate ones, except that now it will take the Transform's scale and position into account. (If you know the math behind it, those functions basicaly means mat * vec and inverse(mat) * vec , respectively). transformVector(vec : cave.Vector3) -> cave.Vector3 untransformVector(vec : cave.Vector3) -> cave.Vector3 - Matrix Operations If you understand how Transform Matrices works, you can also use those two methods to get/set its matrix directly: getMatrix() -> cave.Matrix4 setMatrix(mat : cave.Matrix4) If you don't understand or even if you do, most of the times it's better to use the other functions instead of this because they are easier to work with. :)","title":"Transform Component"},{"location":"PythonAPI/Components/transform/#transform-component","text":"","title":"Transform Component"},{"location":"PythonAPI/Components/transform/#cavetransformcomponent","text":"","title":"cave.TransformComponent"},{"location":"PythonAPI/Components/transform/#variables","text":"position : cave.Vector3 scale : cave.Vector3 Note that you can't get/set the rotation using regular variables as you can with the position and scale . That's due to the way the engine works internally. So use the getters and setters for euler angles or quaternions to rotate as you need to. You can see the details bellow. Sample code (as it would be in the update method of a Component): transform = self.entity.getTransform() # Modifying the current euler angles by adding 0.1 on the Y axis: euler = transform.getEuler() euler.y += 0.1 transform.setEuler(euler) # or you can use this to ROTATE the object: # (will produce the same result as the approach above) transform.rotate(0, 0.1, 0) Last but no least, you can also do this variant below to Set the euler. Note that this approach will not produce the same result as the two others presented above. This one wil SET the rotation to [0, 0, 0]: transform.setEuler(0, 0, 0)","title":"Variables"},{"location":"PythonAPI/Components/transform/#methods","text":"As explained above, the rotation can be handled by using the getters and setters for the Euler angles or Quaternion . Here is the API for reference: # Euler Angles: getEuler() -> cave.Vector3 setEuler(euler : cave.Vector3) setEuler(x : float, y : float, z : float) # Quaternions: getQuaternion() -> cave.Quaternion setQuaternion(quaternion : cave.Quaternion) setQuaternion(x : float, y : float, z : float, w: float)","title":"Methods"},{"location":"PythonAPI/Components/transform/#-rotating-a-transform","text":"In order to Rotate a Transform, other than getting and setting the euler or quaternion by hand, Cave provides a lot of different Transform methods to make your life easier. Starting with the rotate and rotateEuler . The different between them is that the first one expects the values in radians and the second, in degrees : rotate(x : float, y : float, z : float) rotateEuler(x : float, y : float, z : float) If you want to rotate the Transform around a specific axis, you can also use the rotateOnAxis method, that expects an angle (in radians) and the axis to rotate the Transform in. rotateOnAxis(angle : float, axis : cave.Vector3) Alternatively, you can rotate it around the Pitch, Yaw and Roll axis. If you don't know what is this, I strongly recommend you to read this article first . rotateOnPitch(angle : float) rotateOnYaw(angle : float) rotateOnRoll(angle : float) Talking about Roll, Pitch and Yaw, Cave Engine makes it very easy for you to retrieve those values from a Transform as well: getPitch() -> float getYaw() -> float getRoll() -> float","title":"- Rotating a Transform"},{"location":"PythonAPI/Components/transform/#-moving-a-transform","text":"Just like rotating, you can either manually get and set the Transform's position, this time using the position variable, or you can count on the various Cave methods provided to make your life easier. Starting with the basic move method, it will add the provided x, y, z values to the transform's position. But what makes this special is the local parameter. If True (as it is by default), it will first transform those x, y, z values to align to the Transform's orientation. Meaning that, for example, Z will always face the Transform's Forward instead of the world's +Z axis. move(x : float, y : float, z : float, local = True) Alternatively, if you want to apply the movement locally, you can also call this method directly: applyLocalMovement(x : float, y : float, z : float) applyLocalMovement(movement: cave.Vector3) If you read the Entity's Parent Documentation , you may have noticed the following sentence: Entities with a parent will have their Transforms local to their parent's Transform . In other words, the position variable will always be local to the Transform's Entity's parent. If you want to get or set it globally (what we call \"world\"), you can do it so by using this two methods: getWorldPosition() -> cave.Vector3 setWorldPosition(pos: cave.Vector3)","title":"- Moving a Transform"},{"location":"PythonAPI/Components/transform/#-useful-methods","text":"Sometimes you want to do more than simply moving or rotating a Transform. For example, you may want to also lerp it with something else or even make it look at certain direction. Cave Engine's API got you covered in all those cases! But let's start small with some other useful methods first: If you need to know what is the forward, right (and consequently left) or up direction that a Transform is pointing at, you can use those methods to easily get them: getForwardVector() -> cave.Vector3 getRightVector() -> cave.Vector3 getUpVector() -> cave.Vector3 Now, starting to get interesting, Cave provides some built in methods to make a Transform look at certain direction. Imagine that you're making a tower defense game and you want the turret to aim at the nearest enemy. This is probably what you'll be using to achieve that. Same case to make the enemy look at the player. Cave provides two different methods: lookAt and lookAtSmooth . The difference between them is that the first one will immediatly set the Transform to the final orientation and the last one will let you choose a lerp factor, giving you more options to smooth this movement. lookAt(direction : cave.Vector3, up = cave.Vector3(0, 1, 0)) lookAtSmooth(direction : cave.Vector3, lerp = 0.5, up = cave.Vector3(0, 1, 0)) It's also good to know that the lookAtSmooth internally uses Quaternion's sLerp functionalities to get the best possible result. If you don't know what's that, I recommend you reading this Article . Talking about lerp... you can lerp the Transform's quaternions with another directly by using this method: slerpQuaternion(target : cave.Quaternion, value=0.5) And if that's not enough for you, it's possible to lerp the entire Transform with another by calling this: lerp(target : cave.TransformComponent, value=0.5) It also uses slerp internally. This method is very useful if you want to smoothly make a Entity go to a specific place in the world. Let's say that you're about to execute a live action cutscene animation and you want the player to be in a specific spot. Instead of drastically setting the player's position, rotation and scale to that spot, causing it to \"teleport\" right in front of who is playing your game, you can lerp the Transform to the final and desired one. Good!","title":"- Useful Methods"},{"location":"PythonAPI/Components/transform/#-transforming-a-vector","text":"Sometimes you want to work with Vector math but also take into account the Entity's Transform, meaning that you may want to do some operations to make the vector's transform or rotation local or global and so on. Cave Engine provides some specific methods to help you with that. If you know Vector, Quaternion and Matrices math, you'll probably understand out of the box what those methods are, but I'll try to explain them in details. The first set of helpful methods are to rotate or unrotate a Vector by the Transform's rotation. As an example, if you rotate the vector (0, 0, 1) , it will endup looking at the Transform's forward direction. (If you know the math behind it, those functions basicaly means quat * vec and inverse(quat) * vec , respectively). rotateVector(vec : cave.Vector3) -> cave.Vector3 unrotateVector(vec : cave.Vector3) -> cave.Vector3 The second set of helpful methods are to transform or untransform a Vector by the Transform. They work in the same way as the rotate ones, except that now it will take the Transform's scale and position into account. (If you know the math behind it, those functions basicaly means mat * vec and inverse(mat) * vec , respectively). transformVector(vec : cave.Vector3) -> cave.Vector3 untransformVector(vec : cave.Vector3) -> cave.Vector3","title":"- Transforming a Vector"},{"location":"PythonAPI/Components/transform/#-matrix-operations","text":"If you understand how Transform Matrices works, you can also use those two methods to get/set its matrix directly: getMatrix() -> cave.Matrix4 setMatrix(mat : cave.Matrix4) If you don't understand or even if you do, most of the times it's better to use the other functions instead of this because they are easier to work with. :)","title":"- Matrix Operations"},{"location":"PythonAPI/Core/component/","text":"Components If the cave.Scene is where all your game will happen and the cave.Entity is the main class you'll use to build all that, then the cave.Component is the \"final piece of the puzzle\" that you'll use to customize your Entities as you want and need to. You'll not use the cave.Component alone, but it's important that you understand precisely what it have to offer because this will allow you to understand the entire rest of the Engine and its builtin components. But most importantly: it will allow you to create your own Components! The main way that Cave Engine is intender to be programmed by you is by creating new Components, that inherits from this cave.Component class and implements its virtual methods. That means that all the methods you'll see here, except the reload one, are virtual and can be overwritten by you as you need. By the end of this page, you'll find an example of how to create your own Component. So let's get started! cave.Component Variables The component only have one variable: the entity . It stores the cave.Entity owner of the Component. You can't set it to something else (if you try to, it will just ignore what you've done). entity : cave.Entity Methods All the methods above, except the reload one, are meant to be overwritted by you. So feel free to do it so. Let's start with the basics: When the Entity starts in the scene, it will first call all its Component's start method, so that's the perfect place to initialize your variables and so on. If your component's initialization relies on other Component's initialization, then it's best to use the firstUpdate method as well. After the Entity calls all its component's start method, it will call the firstUpdate . Important: The Entity is the one who decided whenever to call the firstUpdate method of the components or not and it only calls it before the Entity's first update gets execution internally by the engine code. Meaning that all the Components already in the Entity when it gets created will have this function executed, but after that, even if you reload the Component or add it afterwards, it will not call the Component's firstUpdate anymore. Here is the Reference API: start(scene : cave.Scene) firstUpdate() Once the component started (after the previous two functions gets called), every frame the Entity will call one of those two methods below , depending if the Scene is paused or not (read the Scene's Documentation for more details). Meaning that this is the perfect place to put your main logic code. Most of the times, what you're looking for is the update method . pausedUpdate only gets called while the scene is paused, as the name suggests and you probably don't want to run Enemy logic on it, as an example. update() pausedUpdate() When the Entity is about to get deleted, it will call all the Component's end method. It also can be called in other situations, such as by the reload method, so keep that in mind. This is a good place to add \"shutdown\" code, if you have anything to do in it. end(scene : cave.Scene) Last but not least, we have the reload method. This one can't be overwritten. It will end(...) the component and then start(..) it again. It's useful because some components like the Mesh and the Light, for optimization purposes, pre cache the data and only changes it during the start. reload() Creating your own Components As promised, I'll show you a code example on how to create your own components. The good news is that it's very simple! In fact, if you create a new Python Script in the engine, it will already have this sample code already added for you, so don't worry a lot about it. Here is a simple code to create own own SuperCustomComponent : import cave class SuperCustomComponent(cave.Component): def start(self, scene): print(\"I'm alive!\") def update(self): # You can write your update stuff here! pass def end(self, scene): print(\"Goodbye!\") - Important Note: You may have noticed that I haven't overwritted the Component's constructor, also known as __init__ by Python. If, for some reason, you decide to have your own __init__ method, you MUST initialize the base cave.Component class and pass the args and kwargs to it, otherwise the Component will not be properly attached to the Entity and it will lead to Undefined Behaviours. Never forget this! Here is how you can do it: def __init__(self, *args, **kwargs): # Initializing the base class, cave.Component: super().__init__(*args, **kwargs) # Now you can put your code: print(\"Hello, world!\")","title":"Component"},{"location":"PythonAPI/Core/component/#components","text":"If the cave.Scene is where all your game will happen and the cave.Entity is the main class you'll use to build all that, then the cave.Component is the \"final piece of the puzzle\" that you'll use to customize your Entities as you want and need to. You'll not use the cave.Component alone, but it's important that you understand precisely what it have to offer because this will allow you to understand the entire rest of the Engine and its builtin components. But most importantly: it will allow you to create your own Components! The main way that Cave Engine is intender to be programmed by you is by creating new Components, that inherits from this cave.Component class and implements its virtual methods. That means that all the methods you'll see here, except the reload one, are virtual and can be overwritten by you as you need. By the end of this page, you'll find an example of how to create your own Component. So let's get started!","title":"Components"},{"location":"PythonAPI/Core/component/#cavecomponent","text":"","title":"cave.Component"},{"location":"PythonAPI/Core/component/#variables","text":"The component only have one variable: the entity . It stores the cave.Entity owner of the Component. You can't set it to something else (if you try to, it will just ignore what you've done). entity : cave.Entity","title":"Variables"},{"location":"PythonAPI/Core/component/#methods","text":"All the methods above, except the reload one, are meant to be overwritted by you. So feel free to do it so. Let's start with the basics: When the Entity starts in the scene, it will first call all its Component's start method, so that's the perfect place to initialize your variables and so on. If your component's initialization relies on other Component's initialization, then it's best to use the firstUpdate method as well. After the Entity calls all its component's start method, it will call the firstUpdate . Important: The Entity is the one who decided whenever to call the firstUpdate method of the components or not and it only calls it before the Entity's first update gets execution internally by the engine code. Meaning that all the Components already in the Entity when it gets created will have this function executed, but after that, even if you reload the Component or add it afterwards, it will not call the Component's firstUpdate anymore. Here is the Reference API: start(scene : cave.Scene) firstUpdate() Once the component started (after the previous two functions gets called), every frame the Entity will call one of those two methods below , depending if the Scene is paused or not (read the Scene's Documentation for more details). Meaning that this is the perfect place to put your main logic code. Most of the times, what you're looking for is the update method . pausedUpdate only gets called while the scene is paused, as the name suggests and you probably don't want to run Enemy logic on it, as an example. update() pausedUpdate() When the Entity is about to get deleted, it will call all the Component's end method. It also can be called in other situations, such as by the reload method, so keep that in mind. This is a good place to add \"shutdown\" code, if you have anything to do in it. end(scene : cave.Scene) Last but not least, we have the reload method. This one can't be overwritten. It will end(...) the component and then start(..) it again. It's useful because some components like the Mesh and the Light, for optimization purposes, pre cache the data and only changes it during the start. reload()","title":"Methods"},{"location":"PythonAPI/Core/component/#creating-your-own-components","text":"As promised, I'll show you a code example on how to create your own components. The good news is that it's very simple! In fact, if you create a new Python Script in the engine, it will already have this sample code already added for you, so don't worry a lot about it. Here is a simple code to create own own SuperCustomComponent : import cave class SuperCustomComponent(cave.Component): def start(self, scene): print(\"I'm alive!\") def update(self): # You can write your update stuff here! pass def end(self, scene): print(\"Goodbye!\")","title":"Creating your own Components"},{"location":"PythonAPI/Core/component/#-important-note","text":"You may have noticed that I haven't overwritted the Component's constructor, also known as __init__ by Python. If, for some reason, you decide to have your own __init__ method, you MUST initialize the base cave.Component class and pass the args and kwargs to it, otherwise the Component will not be properly attached to the Entity and it will lead to Undefined Behaviours. Never forget this! Here is how you can do it: def __init__(self, *args, **kwargs): # Initializing the base class, cave.Component: super().__init__(*args, **kwargs) # Now you can put your code: print(\"Hello, world!\")","title":"- Important Note:"},{"location":"PythonAPI/Core/entity/","text":"Entity After the cave.Scene , cave.Entity if the main thing in Cave. Because this class is the one that you'll be using to build your scenes, characters, enemies, interfaces and much more. That's why it's essential that you have a solid understanding of how it works. So let's jump to it! cave.Entity Variables Cave's Entity only have those two variables. But they all serve a specific purpose, as you can see below. Variable Description name The entity name. properties This is a python dictionary that you can use to store everything related to your entity. Here is the Python API for Reference: name : str properties : dict Methods To kill an entity, you can either do it immediately or schedule it to be done in the future, as you can see below. If you schedule a kill, you'll need to pass a time, in seconds, that the engine will start counting to delete the Entity. That's very useful if you want to drop an item that will dissapear after some time or create an UI element for a tutorial that will least on screen for 10 seconds, as an example. kill() scheduleKill(timeInSeconds: float) Keep in mind that killing an Entity is an action that only gets done by the end of the Engine's frame . So when you call the Entity's kill() method or even the scene.remove(entity) , it will be scheduled to be done at the end of the current frame. That's why the following function, isAlive , is very important: most of the times, it will return True , but when the Entity gets marked for deletion in the end of the frame, it will return False . A good use case of this method os when you are handling damage and deleting the objects that take damage, adding it to the player's score. As you saw in the Scene's Documentation (read the CollisionInfo notes), a collision hit may happen multiple times for the same entities. So if you're iterating over all the entities to perform this damage and kill action and don't check to see if each entity is still alive, you may count the same kill twice! Important: If you schedule a Kill using scheduleKill , the entity will still be alive until its last frame, when it will actually be deleted. There is the method API for reference: isAlive() -> bool If you need to see if the entity has a specific Tag or Property , use one of those methods: hasTag(tag: str) -> bool hasProperty(property: str) -> bool If you want to get the Entity's ID, you can call the getID method: getID() -> int It's a good idea to store the entity ID if you constantly wants to query the scene to retrieve the entity back, since it's faster to get the entity by its ID than it is by its name. And why not storing the Entity directly? Because if the entity gets deleted, you may cause a big problem if you still have it in your code. During a single frame, it's not a problem to store entities in a variable because as you already saw, the Engine will not immediately delete any entity while there is still code being running for the frame. If you want to get the Entity's scene, use this: getScene() -> cave.Scene - Working with Components As you already know, Cave Engine lets you customize your Entities by adding and manipulating components in it. When working with components using the Python API , you'll always refer to them by typing their names as strings. Adding the \"Component\" sufix is not mandatory, meaning that if you want to get the Entity's RigidBodyComponent for example, you can call it: \"RigidBodyComponent\" or just \"RigidBody\" . The Entity supports having multiple components of the same Type. In this case, getting it (with get ) will return the first hit. That's why you can also use getAll to return all of them (same type). Here is the full API: # Adds a new component: add(componentName: str) -> cave.Component # Returns a specific component: get(componentName: str) -> cave.Component # Returns all the components with this same type: getAll(componentName: str) -> list of cave.Component There is one component type that you'll likely to use a lot, which is the Transform Component . That's why Cave provides this method below for you to get them more easily. Keep in mind that an Entity may not have a transform (and it will return None). getTransform() -> cave.TransformComponent - Parenting System As explained in the Scene documentation, Cave Engine organizes the scene into a Tree structure , where entities can be child of other entities. With that in mind, it's important that you know how to use and manipulate the parenting system. To get the parent and children, you can use one of those methods below: getParent() -> cave.Entity # Get a Specific Child, by name getChild(name: str, recursive=True) -> cave.Entity # Gets all the children: getChildren() -> list of cave.Entity # Gets all the children recursively, meaning that all the # children of the Entity's children will be included (and so on): getChildrenRecursive() -> list of cave.Entity In order to make a new parent, you can use one of those methods below. They will return True of the parenting attempt was sucessful. setParent(parent: cave.Entity) -> bool setParentLocal(parent: cave.Entity) -> bool Parenting an entity with None will remove its parent. But in order to remove a parent, it's best to use one of those methods: removeParent() removeParentLocal() Regarding the parenting system, there is some common questions that we'll address here: What if I want to make an entity a child of another? You may have noticed that we don't have a setChild or makeChildOf method, only setParent . If you want the entity A to be a child of the entity B , then what you actually want is B to be the parent of A . So instead of thinking of it as B.makeChildOf(A) , think about A.setParent(B) . What is this \"local\" thing? You also may have noticed that some methods have a \"local\" variant. If you set or remove a Parent using the \"local\" variants, it will try to preserv the entity's Transform, meaning that you'll not see it changing position, rotation or scale during this operation. Most of the time, this is what you want. Will the Children move with their parent? Yes! When you create a parenting system, moving, rotating or scaling the parent will also affect their children. For reference, Entities with a parent will have their Transforms local to their parent's Transform . Unless the parent don't have a transform, of course. :) If I delete or disable the parent, will it affect the children? Yes! :) - Activating an Entity You might want to disable (deactivate) an entity for some occasions. All the entities are activated by default, meaning that they will be rendered, execute logic and be taken into account in the Physics World. But some times, you just need to disable them for some time or until something happens, then re enable. This is useful, for example, to create UI. Think about a pause menu. Instead of having to create an Entity Template for the menu and adding and removing it to the scene every time, you could just make the menu always there and just deactivate it when the game is running, activating it back if the player hits pause. NOTE: Setting an entity to active or not will also recursively change this to all its children. To see if the entity is Activated or Deactivated, you can use one of those methods: isActive() -> bool getActive() -> bool In order to change this, you can also use the method provided below. But there is something important to know here: When you disable an Entity, it will call its end method (that will call the Component ones) and the same thing applies for activating them back (but with the start method). And due to how the engine works internally, those methods requires the scene you're in in order to work. So to activate or deactivate an entity, you'll need to pass the scene as an argument. You can simply get it using cave.getCurrentScene() and it will work just fine. # Activates the entity: activate(scene: cave.Scene) # Deactivates the entity: deactivate(scene: cave.Scene) # You can use this one if you want to set it with a boolean variable: setActive(value: bool, scene: cave.Scene) - Duplicating an Entity You can create a copy of the entity and add it to the scene by doing this: scene = cave.getCurrentScene() # Creating a copy of the current entity... entityCopy = cave.Entity(self.entity) # Manually adding it to the scene: scene.add(entityCopy) You can also create a new one from scratch and add it to the scene like this: newEntity = cave.Entity() scene.add(newEntity) But we strongly recommend, for the ease of use, that you build a new one by using the Entity Template system. Check the Scene's documentation for more details on how to do it.","title":"Entity"},{"location":"PythonAPI/Core/entity/#entity","text":"After the cave.Scene , cave.Entity if the main thing in Cave. Because this class is the one that you'll be using to build your scenes, characters, enemies, interfaces and much more. That's why it's essential that you have a solid understanding of how it works. So let's jump to it!","title":"Entity"},{"location":"PythonAPI/Core/entity/#caveentity","text":"","title":"cave.Entity"},{"location":"PythonAPI/Core/entity/#variables","text":"Cave's Entity only have those two variables. But they all serve a specific purpose, as you can see below. Variable Description name The entity name. properties This is a python dictionary that you can use to store everything related to your entity. Here is the Python API for Reference: name : str properties : dict","title":"Variables"},{"location":"PythonAPI/Core/entity/#methods","text":"To kill an entity, you can either do it immediately or schedule it to be done in the future, as you can see below. If you schedule a kill, you'll need to pass a time, in seconds, that the engine will start counting to delete the Entity. That's very useful if you want to drop an item that will dissapear after some time or create an UI element for a tutorial that will least on screen for 10 seconds, as an example. kill() scheduleKill(timeInSeconds: float) Keep in mind that killing an Entity is an action that only gets done by the end of the Engine's frame . So when you call the Entity's kill() method or even the scene.remove(entity) , it will be scheduled to be done at the end of the current frame. That's why the following function, isAlive , is very important: most of the times, it will return True , but when the Entity gets marked for deletion in the end of the frame, it will return False . A good use case of this method os when you are handling damage and deleting the objects that take damage, adding it to the player's score. As you saw in the Scene's Documentation (read the CollisionInfo notes), a collision hit may happen multiple times for the same entities. So if you're iterating over all the entities to perform this damage and kill action and don't check to see if each entity is still alive, you may count the same kill twice! Important: If you schedule a Kill using scheduleKill , the entity will still be alive until its last frame, when it will actually be deleted. There is the method API for reference: isAlive() -> bool If you need to see if the entity has a specific Tag or Property , use one of those methods: hasTag(tag: str) -> bool hasProperty(property: str) -> bool If you want to get the Entity's ID, you can call the getID method: getID() -> int It's a good idea to store the entity ID if you constantly wants to query the scene to retrieve the entity back, since it's faster to get the entity by its ID than it is by its name. And why not storing the Entity directly? Because if the entity gets deleted, you may cause a big problem if you still have it in your code. During a single frame, it's not a problem to store entities in a variable because as you already saw, the Engine will not immediately delete any entity while there is still code being running for the frame. If you want to get the Entity's scene, use this: getScene() -> cave.Scene","title":"Methods"},{"location":"PythonAPI/Core/entity/#-working-with-components","text":"As you already know, Cave Engine lets you customize your Entities by adding and manipulating components in it. When working with components using the Python API , you'll always refer to them by typing their names as strings. Adding the \"Component\" sufix is not mandatory, meaning that if you want to get the Entity's RigidBodyComponent for example, you can call it: \"RigidBodyComponent\" or just \"RigidBody\" . The Entity supports having multiple components of the same Type. In this case, getting it (with get ) will return the first hit. That's why you can also use getAll to return all of them (same type). Here is the full API: # Adds a new component: add(componentName: str) -> cave.Component # Returns a specific component: get(componentName: str) -> cave.Component # Returns all the components with this same type: getAll(componentName: str) -> list of cave.Component There is one component type that you'll likely to use a lot, which is the Transform Component . That's why Cave provides this method below for you to get them more easily. Keep in mind that an Entity may not have a transform (and it will return None). getTransform() -> cave.TransformComponent","title":"- Working with Components"},{"location":"PythonAPI/Core/entity/#-parenting-system","text":"As explained in the Scene documentation, Cave Engine organizes the scene into a Tree structure , where entities can be child of other entities. With that in mind, it's important that you know how to use and manipulate the parenting system. To get the parent and children, you can use one of those methods below: getParent() -> cave.Entity # Get a Specific Child, by name getChild(name: str, recursive=True) -> cave.Entity # Gets all the children: getChildren() -> list of cave.Entity # Gets all the children recursively, meaning that all the # children of the Entity's children will be included (and so on): getChildrenRecursive() -> list of cave.Entity In order to make a new parent, you can use one of those methods below. They will return True of the parenting attempt was sucessful. setParent(parent: cave.Entity) -> bool setParentLocal(parent: cave.Entity) -> bool Parenting an entity with None will remove its parent. But in order to remove a parent, it's best to use one of those methods: removeParent() removeParentLocal() Regarding the parenting system, there is some common questions that we'll address here: What if I want to make an entity a child of another? You may have noticed that we don't have a setChild or makeChildOf method, only setParent . If you want the entity A to be a child of the entity B , then what you actually want is B to be the parent of A . So instead of thinking of it as B.makeChildOf(A) , think about A.setParent(B) . What is this \"local\" thing? You also may have noticed that some methods have a \"local\" variant. If you set or remove a Parent using the \"local\" variants, it will try to preserv the entity's Transform, meaning that you'll not see it changing position, rotation or scale during this operation. Most of the time, this is what you want. Will the Children move with their parent? Yes! When you create a parenting system, moving, rotating or scaling the parent will also affect their children. For reference, Entities with a parent will have their Transforms local to their parent's Transform . Unless the parent don't have a transform, of course. :) If I delete or disable the parent, will it affect the children? Yes! :)","title":"- Parenting System"},{"location":"PythonAPI/Core/entity/#-activating-an-entity","text":"You might want to disable (deactivate) an entity for some occasions. All the entities are activated by default, meaning that they will be rendered, execute logic and be taken into account in the Physics World. But some times, you just need to disable them for some time or until something happens, then re enable. This is useful, for example, to create UI. Think about a pause menu. Instead of having to create an Entity Template for the menu and adding and removing it to the scene every time, you could just make the menu always there and just deactivate it when the game is running, activating it back if the player hits pause. NOTE: Setting an entity to active or not will also recursively change this to all its children. To see if the entity is Activated or Deactivated, you can use one of those methods: isActive() -> bool getActive() -> bool In order to change this, you can also use the method provided below. But there is something important to know here: When you disable an Entity, it will call its end method (that will call the Component ones) and the same thing applies for activating them back (but with the start method). And due to how the engine works internally, those methods requires the scene you're in in order to work. So to activate or deactivate an entity, you'll need to pass the scene as an argument. You can simply get it using cave.getCurrentScene() and it will work just fine. # Activates the entity: activate(scene: cave.Scene) # Deactivates the entity: deactivate(scene: cave.Scene) # You can use this one if you want to set it with a boolean variable: setActive(value: bool, scene: cave.Scene)","title":"- Activating an Entity"},{"location":"PythonAPI/Core/entity/#-duplicating-an-entity","text":"You can create a copy of the entity and add it to the scene by doing this: scene = cave.getCurrentScene() # Creating a copy of the current entity... entityCopy = cave.Entity(self.entity) # Manually adding it to the scene: scene.add(entityCopy) You can also create a new one from scratch and add it to the scene like this: newEntity = cave.Entity() scene.add(newEntity) But we strongly recommend, for the ease of use, that you build a new one by using the Entity Template system. Check the Scene's documentation for more details on how to do it.","title":"- Duplicating an Entity"},{"location":"PythonAPI/Core/scene/","text":"Scene The cave.Scene is where all your game will happen. You can think of it as a Level where you can put all your entities in order to build your worlds, enemies and the game itself. There will always be a scene loaded (and you can get the current one by calling cave.getCurrentScene() ), one at the time and you can change or reload it any time you want during the gameplay. Check the Engine > Utilities > Scene section for more details on it. In order to completely understand and use all the APIs provided to manipulate the Scenes, you'll also see some other important classes (in this page) that will make a lot of sense to you after reading the cave.Scene documentation below. So let's get started: cave.Scene Variables Cave's Scene only have those three variables. But they all serve a specific purpose, as you can see below. Variable Description name The scene name. paused You can set this to True or False to pause/unpause the scene. If True, it will no longer call the component's update method and will call the pausedUpdate instead. properties This is a python dictionary that you can use to store everything related to your game's scene. Very useful for variables that needs to be accessed by various entities, such as enemy waves, time spent, remaining items to collect or scores. Here is the Python API for Reference: name : str paused : bool properties : dict Methods In order to create new Entities, you have two options: Build them from scratch in the code or instantiate them by providing a template. To create them from scratch, you can use one of those two scene methods: # Creates a brand new entity and returns it to you: newEntity() -> cave.Entity # If you already have an Entity and just need to add it to the scene, then use this # (it will return the entity as well to make it easy for you to use the method): add(entity: Entity) -> cave.Entity The scene.add(entity) method is used to add an entity you manually build by yourself in the code. Most of the times it's not exactly what you want. That's why there is a scene.addFromTemplate(name) alternative: Given an Entity Template name, the engine will construct a new entity for you followying that template. Both methods returns the added entity for convenience. If you want to create a new one by providing a template ( recommended ), use this method: # Note that you can provide optional arguments to set a custom transform to add it to. addFromTemplate( templateName : str, position = cave.Vector3(0, 0, 0), rotation = cave.Vector3(0, 0, 0), scale = cave.Vector3(1, 1, 1) ) -> cave.Entity If you need to remove an Entity from the scene, you can either kill it (calling entity.kill() ) or just remove them directly using this method: remove(entity : cave.Entity) This method will return the elapsed time, in second, since the Scene creation. This value does not include the time paused (and yes, it's the number user by the SceneTimer to count time). getElapsedSceneTime() -> float In Cave Engine, every Scene have its own Sun light and you can get it by calling this scene method: getSun() -> cave.Sun - Scene Collision Checks If you need to do some \"in place\" Collision dettection like a ray cast or check if there are objects at certain place, you can use one of those methods below. Keep in mind that all of them will rely on the physics engine to return the correct values, so make sure that the Entities that you're trying to detect have a proper Physics shape (like a Rigid Body or a Character Component). It's also good to know that the result is calculated immediately when you call those functions, so you don't need to worry about the output being delayed by a frame like some engines. It will be up to date with the current scene status. The first and most common method in this list is the rayCast and rayCastAll . The difference between them is that the first one will stop and return in the first ray hit and the second one will return a python list with all the hits. It's a good option if you want to make a gun that can shoot through walls, for example. rayCast(origin : cave.Vector3, target : cave.Vector3) -> cave.RayCastOut rayCastAll(origin : cave.Vector3, target : cave.Vector3) -> list of cave.RayCastOut Ray casts are good, but sometimes they are not enough for what you want. That's why Cave Engine lets you check for collision within certain bounds. For now, you can use a Box or a Sphere shape for this and the usage is very simple as you can see below. Check the cave.CollisionInfo for additional details. # Box Shape checks: checkContactBox(boxTransform: cave.Transform) -> list of cave.CollisionInfo checkContactBox( boxPosition : cave.Vector3, boxRotation : cave.Vector3, boxScale : cave.Vector3 ) -> list of cave.CollisionInfo # Sphere Shape checks: checkContactSphere(position: cave.Vector3, radius: float)-> list of cave.CollisionInfo - Scene Queries If you want to get a specific Entity in the scene, you can use one of those two methods: getEntity(id : int) -> cave.Entity getEntity(name : str) -> cave.Entity Note: Time complexity of getting an Entity by name (string) is O(n) and by ID is O(1) . In other words: get by name is way slower than by ID so it's recommended to store the entity ID and use it as much as you can. Also, when you have multiple entities with the same name in the scene, it will always return the first entity found (and this result may be non deterministic - in other words the result may vary). But that's not everything! If you need to get all the entities in the scene, you can do it so by calling: getEntities() -> list of cave.Entity And you can be a bit smarter than that and filter the Entities by something, such as by Tag or Property . Keep in mind that if you decide to filter by Tag , it will tend to be faster than it is by Property , since the Cave's tag system does not rely on python (meaning that the backends are completely written in C++) and the Properties does. getEntitiesWithTag(tag: str) -> list of cave.Entity getEntitiesWithProperty(property: str) -> list of cave.Entity At this point, you probably already noticed that Cave Engine organizes the scene into a Tree structure , where entities can be child of other entities. All the query methods mentioned above will consider this entire hierarchy, but sometimes you may only need what we call the Root Entities . Meaning the Entities with no parents. If that's your case, you can easily retrieve them with the methods above: # This will return all the root entities in the scene: getRootEntities() -> list of cave.Entity # The following ones will only query the root Entities: getRootEntitiesWithTag(tag: str) -> list of cave.Entity getRootEntitiesWithProperty(property: str) -> list of cave.Entity Good to know: If you put an entity inside a folder, it will no longer be a root entity (because it will be child of the folder entity). It's also good to know that querying Root entities can be faster than doing it with all entities, since the engine does not need to recursively iterate the root children. Scene Related Classes As discussed in the beginning of this page, there are some other helpful classes that are important for you to understand in order to properly manipulate the scenes in Cave. Here you'll find their documentation. cave.RayCastOut This class is used as a data storage to return ray cast hit information. Returned by the scene when you do a rayCast and it finds something. Variables Variable Description hit It's True if this is a valid RayCast Output. It's always good to check it first. As an example, of the scene.RayCast(...) method don't find anything, it will return an invalid RayCastOut and this will be false. position The exact position in world space where the ray hitted an entity. Good to use for bullet holes, as an example. normal The normal that the surface hitted by the ray is pointing to. Also good for bullet holes, as an example. entity The entity hit by the ray. Here is the Python API for Reference: hit : bool position : cave.Vector3 normal : cave.Vector3 entity : cave.Entity cave.CollisionInfo This class is used as a data storage to return collision hit information. This class is returned by the Scene when you call methods like scene.checkContactBox(...) or scene.checkContactSphere(...) , but it is also used anywhere else where collision information is necessary, for example when you check if a Rigid Body or Character Component collided with something. There are two important things you need to know about Collisions and the CollisionInfo : The first thing is that when a shape collides with another, it may have one or more hits , depending on how deep the collision was and a lot of other factors such as the shape, how the collision happened and so on. The second is that, because of this behavior, most of the times where you expect a CollisionInfo from Cave, it will always return a list of them (even if there is only one element in it), because it may have multiple ones, as explained above. Due to that, different from the cave.RayCastOut , you'll not find a hit variable to check if the collision was valid, because the engine will never return an invalid one. If there is no collision, the list will simply be empty. This is information will help you understand how to properly manipulate the Collisions in the engine. Most of the time that you need to handle them, you'll probably want to iterate over the output collisions until you find the one you want. Here is an example: scene = cave.getCurrentScene() playerPos = self.entity.getTransform().position for hit in scene.checkContactSphere(playerPos, 3.0): print(\"New Entity hit:\", hit.entity.name) In the code above, we use the scene's checkContactSphere method to see if there are any Entities within 3 meters from the player position (considering that it's the player that's executing this code, of course). Note that if you run this code, it may print the same entity twice, due to the reasons explained beefore. If you only want to take an entity hit into account once, you can cache them into a list, like this: alreadyHit = [] for hit in scene.checkContactSphere(playerPos, 3.0): if hit.entity in alreadyHit: # Skipping any entity that we already checked! continue # Now we'll add the entity to the list to make sure we don't check it twice: alreadyHit.append(hit.entity) # Finally, we do what we want with the entity: print(\"New Entity hit:\", hit.entity.name) The explanation above will help you to handle collisions in most of the situations where the engine outputs to you a list of cave.CollisionInfo instances. Variables Variable Description position The exact position in world space where the collision happened. normal The direction that the collision point is pointing to. entity The entity hit. Here is the Python API for Reference: position : cave.Vector3 normal : cave.Vector3 entity : cave.Entity cave.Sun As already explained in this page, every Scene in Cave have its own Sun light. You can get it by calling scene.getSun() and it will return an instance of this class. You can use it to adjust the look of it, as you can see below. Variables Variable Description hour The hour of the day used to determine the sun position. Goes from 0 to 24 and the minutes needs to be represented by the fractional part of the value, so 12:30h is 12.5 . angle The angle represents where in the horizon the sun will rise and set. It goes from 0\u00ba to 360\u00ba , in degrees. color The color of the sun. mask The shadow mask. It will only cast shadows to Mesh Components that its shadow mask intersect with this. If you're trying to make an entity don't cast shadows, this is what you're looking for. intensity The sun intensity. The more, the brighter it will be. Here is the Python API for Reference: hour : float angle : float color : cave.Vector3 mask : cave.BitMask intensity : float","title":"Scene"},{"location":"PythonAPI/Core/scene/#scene","text":"The cave.Scene is where all your game will happen. You can think of it as a Level where you can put all your entities in order to build your worlds, enemies and the game itself. There will always be a scene loaded (and you can get the current one by calling cave.getCurrentScene() ), one at the time and you can change or reload it any time you want during the gameplay. Check the Engine > Utilities > Scene section for more details on it. In order to completely understand and use all the APIs provided to manipulate the Scenes, you'll also see some other important classes (in this page) that will make a lot of sense to you after reading the cave.Scene documentation below. So let's get started:","title":"Scene"},{"location":"PythonAPI/Core/scene/#cavescene","text":"","title":"cave.Scene"},{"location":"PythonAPI/Core/scene/#variables","text":"Cave's Scene only have those three variables. But they all serve a specific purpose, as you can see below. Variable Description name The scene name. paused You can set this to True or False to pause/unpause the scene. If True, it will no longer call the component's update method and will call the pausedUpdate instead. properties This is a python dictionary that you can use to store everything related to your game's scene. Very useful for variables that needs to be accessed by various entities, such as enemy waves, time spent, remaining items to collect or scores. Here is the Python API for Reference: name : str paused : bool properties : dict","title":"Variables"},{"location":"PythonAPI/Core/scene/#methods","text":"In order to create new Entities, you have two options: Build them from scratch in the code or instantiate them by providing a template. To create them from scratch, you can use one of those two scene methods: # Creates a brand new entity and returns it to you: newEntity() -> cave.Entity # If you already have an Entity and just need to add it to the scene, then use this # (it will return the entity as well to make it easy for you to use the method): add(entity: Entity) -> cave.Entity The scene.add(entity) method is used to add an entity you manually build by yourself in the code. Most of the times it's not exactly what you want. That's why there is a scene.addFromTemplate(name) alternative: Given an Entity Template name, the engine will construct a new entity for you followying that template. Both methods returns the added entity for convenience. If you want to create a new one by providing a template ( recommended ), use this method: # Note that you can provide optional arguments to set a custom transform to add it to. addFromTemplate( templateName : str, position = cave.Vector3(0, 0, 0), rotation = cave.Vector3(0, 0, 0), scale = cave.Vector3(1, 1, 1) ) -> cave.Entity If you need to remove an Entity from the scene, you can either kill it (calling entity.kill() ) or just remove them directly using this method: remove(entity : cave.Entity) This method will return the elapsed time, in second, since the Scene creation. This value does not include the time paused (and yes, it's the number user by the SceneTimer to count time). getElapsedSceneTime() -> float In Cave Engine, every Scene have its own Sun light and you can get it by calling this scene method: getSun() -> cave.Sun","title":"Methods"},{"location":"PythonAPI/Core/scene/#-scene-collision-checks","text":"If you need to do some \"in place\" Collision dettection like a ray cast or check if there are objects at certain place, you can use one of those methods below. Keep in mind that all of them will rely on the physics engine to return the correct values, so make sure that the Entities that you're trying to detect have a proper Physics shape (like a Rigid Body or a Character Component). It's also good to know that the result is calculated immediately when you call those functions, so you don't need to worry about the output being delayed by a frame like some engines. It will be up to date with the current scene status. The first and most common method in this list is the rayCast and rayCastAll . The difference between them is that the first one will stop and return in the first ray hit and the second one will return a python list with all the hits. It's a good option if you want to make a gun that can shoot through walls, for example. rayCast(origin : cave.Vector3, target : cave.Vector3) -> cave.RayCastOut rayCastAll(origin : cave.Vector3, target : cave.Vector3) -> list of cave.RayCastOut Ray casts are good, but sometimes they are not enough for what you want. That's why Cave Engine lets you check for collision within certain bounds. For now, you can use a Box or a Sphere shape for this and the usage is very simple as you can see below. Check the cave.CollisionInfo for additional details. # Box Shape checks: checkContactBox(boxTransform: cave.Transform) -> list of cave.CollisionInfo checkContactBox( boxPosition : cave.Vector3, boxRotation : cave.Vector3, boxScale : cave.Vector3 ) -> list of cave.CollisionInfo # Sphere Shape checks: checkContactSphere(position: cave.Vector3, radius: float)-> list of cave.CollisionInfo","title":"- Scene Collision Checks"},{"location":"PythonAPI/Core/scene/#-scene-queries","text":"If you want to get a specific Entity in the scene, you can use one of those two methods: getEntity(id : int) -> cave.Entity getEntity(name : str) -> cave.Entity Note: Time complexity of getting an Entity by name (string) is O(n) and by ID is O(1) . In other words: get by name is way slower than by ID so it's recommended to store the entity ID and use it as much as you can. Also, when you have multiple entities with the same name in the scene, it will always return the first entity found (and this result may be non deterministic - in other words the result may vary). But that's not everything! If you need to get all the entities in the scene, you can do it so by calling: getEntities() -> list of cave.Entity And you can be a bit smarter than that and filter the Entities by something, such as by Tag or Property . Keep in mind that if you decide to filter by Tag , it will tend to be faster than it is by Property , since the Cave's tag system does not rely on python (meaning that the backends are completely written in C++) and the Properties does. getEntitiesWithTag(tag: str) -> list of cave.Entity getEntitiesWithProperty(property: str) -> list of cave.Entity At this point, you probably already noticed that Cave Engine organizes the scene into a Tree structure , where entities can be child of other entities. All the query methods mentioned above will consider this entire hierarchy, but sometimes you may only need what we call the Root Entities . Meaning the Entities with no parents. If that's your case, you can easily retrieve them with the methods above: # This will return all the root entities in the scene: getRootEntities() -> list of cave.Entity # The following ones will only query the root Entities: getRootEntitiesWithTag(tag: str) -> list of cave.Entity getRootEntitiesWithProperty(property: str) -> list of cave.Entity Good to know: If you put an entity inside a folder, it will no longer be a root entity (because it will be child of the folder entity). It's also good to know that querying Root entities can be faster than doing it with all entities, since the engine does not need to recursively iterate the root children.","title":"- Scene Queries"},{"location":"PythonAPI/Core/scene/#scene-related-classes","text":"As discussed in the beginning of this page, there are some other helpful classes that are important for you to understand in order to properly manipulate the scenes in Cave. Here you'll find their documentation.","title":"Scene Related Classes"},{"location":"PythonAPI/Core/scene/#caveraycastout","text":"This class is used as a data storage to return ray cast hit information. Returned by the scene when you do a rayCast and it finds something.","title":"cave.RayCastOut"},{"location":"PythonAPI/Core/scene/#variables_1","text":"Variable Description hit It's True if this is a valid RayCast Output. It's always good to check it first. As an example, of the scene.RayCast(...) method don't find anything, it will return an invalid RayCastOut and this will be false. position The exact position in world space where the ray hitted an entity. Good to use for bullet holes, as an example. normal The normal that the surface hitted by the ray is pointing to. Also good for bullet holes, as an example. entity The entity hit by the ray. Here is the Python API for Reference: hit : bool position : cave.Vector3 normal : cave.Vector3 entity : cave.Entity","title":"Variables"},{"location":"PythonAPI/Core/scene/#cavecollisioninfo","text":"This class is used as a data storage to return collision hit information. This class is returned by the Scene when you call methods like scene.checkContactBox(...) or scene.checkContactSphere(...) , but it is also used anywhere else where collision information is necessary, for example when you check if a Rigid Body or Character Component collided with something. There are two important things you need to know about Collisions and the CollisionInfo : The first thing is that when a shape collides with another, it may have one or more hits , depending on how deep the collision was and a lot of other factors such as the shape, how the collision happened and so on. The second is that, because of this behavior, most of the times where you expect a CollisionInfo from Cave, it will always return a list of them (even if there is only one element in it), because it may have multiple ones, as explained above. Due to that, different from the cave.RayCastOut , you'll not find a hit variable to check if the collision was valid, because the engine will never return an invalid one. If there is no collision, the list will simply be empty. This is information will help you understand how to properly manipulate the Collisions in the engine. Most of the time that you need to handle them, you'll probably want to iterate over the output collisions until you find the one you want. Here is an example: scene = cave.getCurrentScene() playerPos = self.entity.getTransform().position for hit in scene.checkContactSphere(playerPos, 3.0): print(\"New Entity hit:\", hit.entity.name) In the code above, we use the scene's checkContactSphere method to see if there are any Entities within 3 meters from the player position (considering that it's the player that's executing this code, of course). Note that if you run this code, it may print the same entity twice, due to the reasons explained beefore. If you only want to take an entity hit into account once, you can cache them into a list, like this: alreadyHit = [] for hit in scene.checkContactSphere(playerPos, 3.0): if hit.entity in alreadyHit: # Skipping any entity that we already checked! continue # Now we'll add the entity to the list to make sure we don't check it twice: alreadyHit.append(hit.entity) # Finally, we do what we want with the entity: print(\"New Entity hit:\", hit.entity.name) The explanation above will help you to handle collisions in most of the situations where the engine outputs to you a list of cave.CollisionInfo instances.","title":"cave.CollisionInfo"},{"location":"PythonAPI/Core/scene/#variables_2","text":"Variable Description position The exact position in world space where the collision happened. normal The direction that the collision point is pointing to. entity The entity hit. Here is the Python API for Reference: position : cave.Vector3 normal : cave.Vector3 entity : cave.Entity","title":"Variables"},{"location":"PythonAPI/Core/scene/#cavesun","text":"As already explained in this page, every Scene in Cave have its own Sun light. You can get it by calling scene.getSun() and it will return an instance of this class. You can use it to adjust the look of it, as you can see below.","title":"cave.Sun"},{"location":"PythonAPI/Core/scene/#variables_3","text":"Variable Description hour The hour of the day used to determine the sun position. Goes from 0 to 24 and the minutes needs to be represented by the fractional part of the value, so 12:30h is 12.5 . angle The angle represents where in the horizon the sun will rise and set. It goes from 0\u00ba to 360\u00ba , in degrees. color The color of the sun. mask The shadow mask. It will only cast shadows to Mesh Components that its shadow mask intersect with this. If you're trying to make an entity don't cast shadows, this is what you're looking for. intensity The sun intensity. The more, the brighter it will be. Here is the Python API for Reference: hour : float angle : float color : cave.Vector3 mask : cave.BitMask intensity : float","title":"Variables"},{"location":"PythonAPI/EditorAPI/tooling/","text":"Writting your own Tools In the Cave Engine you can write your own tools using python. They can be as simple as just executing a text to do something for you or more complex and well made tools, with a proper interface that contains buttons, sliders and whatever you want in a Tab format, that you can dock to the Editor's ui. To start writting your tools, create a new Python Script in the asset browser, open it in the text editor (double click) and delete the current startup code. Run your first Tool Let's start with a simple tool that just sets some Sun light settings: import cave # You can write the code you want to using the cave API: scene = cave.getCurrentScene() sun = scene.getSun() sun.hour = 6.15 sun.intensity = 5.0 sun.color = cave.Vector3(1.0, 0.8, 0.8) In order to run this code, simply go to \"Editor Tools..\" and then \"Run Script\": It will run and change the sun settings, as expected. Note that you can use print(...) here to debug your stuff as well. Have fun! Create a Tab and Interface for your Tool Now that you already know how to run simple scripts like that, it's time to understand how to do some a bit more advanced ones. So let's start talking about a tool with its own Tab docked in the editor, with a proper interface with buttons, sliders and so on. Here is a screenshot showing that in action. The code in the left generated the tab highlighted in red: Here is a simple code that produces a similar result and can be used as a starting point for your own tools: import cave import caveui as ui class Example(ui.DebugTab): def __init__(self): super().__init__() self.counter = 0 def draw(self): ui.text(\"Hello, world!\") ui.separator() self.counter = ui.prop(\"Counter\", self.counter) if ui.button(\"Increase counter (+1)\"): self.counter += 1 In order to run that and register the Tab to the ui, go to the \"Editor Tools...\" option and open the \"Register Tab...\" sub menu. It will automatically identify all the classes in the code that inherits from the base class caveui.DebugTab and show there. Simply click in the one you want to in order to register it.","title":"Writting your own Tools"},{"location":"PythonAPI/EditorAPI/tooling/#writting-your-own-tools","text":"In the Cave Engine you can write your own tools using python. They can be as simple as just executing a text to do something for you or more complex and well made tools, with a proper interface that contains buttons, sliders and whatever you want in a Tab format, that you can dock to the Editor's ui. To start writting your tools, create a new Python Script in the asset browser, open it in the text editor (double click) and delete the current startup code.","title":"Writting your own Tools"},{"location":"PythonAPI/EditorAPI/tooling/#run-your-first-tool","text":"Let's start with a simple tool that just sets some Sun light settings: import cave # You can write the code you want to using the cave API: scene = cave.getCurrentScene() sun = scene.getSun() sun.hour = 6.15 sun.intensity = 5.0 sun.color = cave.Vector3(1.0, 0.8, 0.8) In order to run this code, simply go to \"Editor Tools..\" and then \"Run Script\": It will run and change the sun settings, as expected. Note that you can use print(...) here to debug your stuff as well. Have fun!","title":"Run your first Tool"},{"location":"PythonAPI/EditorAPI/tooling/#create-a-tab-and-interface-for-your-tool","text":"Now that you already know how to run simple scripts like that, it's time to understand how to do some a bit more advanced ones. So let's start talking about a tool with its own Tab docked in the editor, with a proper interface with buttons, sliders and so on. Here is a screenshot showing that in action. The code in the left generated the tab highlighted in red: Here is a simple code that produces a similar result and can be used as a starting point for your own tools: import cave import caveui as ui class Example(ui.DebugTab): def __init__(self): super().__init__() self.counter = 0 def draw(self): ui.text(\"Hello, world!\") ui.separator() self.counter = ui.prop(\"Counter\", self.counter) if ui.button(\"Increase counter (+1)\"): self.counter += 1 In order to run that and register the Tab to the ui, go to the \"Editor Tools...\" option and open the \"Register Tab...\" sub menu. It will automatically identify all the classes in the code that inherits from the base class caveui.DebugTab and show there. Simply click in the one you want to in order to register it.","title":"Create a Tab and Interface for your Tool"},{"location":"PythonAPI/EditorAPI/uiModule/","text":"UI Submodule API Cave Engine provides, in the editor only, the cave.ui submodule for you to create your own custom tools. Be aware that it will not work if you attempt to use this in game! ui.DebugTab In order to use the UI Submodule API, you first need to create your own custom Tab by making a class that inherits and implements the ui.DebugTab . I've written a detailed documentation on how to do it at Editor Only API > Writting your own Tools , so consider reading it first. Variables The DebugTab only have one variable: the active . If True , the Tab will be rendered and displayed to the user. If not, it will be hidden and the engine user will have to enable it back by using the Tools menu in the top left corner of the Editor. active : bool Methods Just like the variables, the DebugTab only have one method: the draw() . It's a virtual method intended for you to overwrite in order to draw your own UI to the Editor's screen. draw() UI Functions After creating your own ui.DebugTab , everything you'll do regarding UI will be using one of those functions below. ui.prop(...) In order to display variables in the UI, you'll need to use the cave.ui.prop function. It receives the prop name and also its current value and returns the updated one. Example on how to use it: self.myProp = cave.ui.prop(\"My Prop\", self.myProp) And here is the API for reference: cave.ui.prop(name: str, value: int) -> int cave.ui.prop(name: str, value: float) -> float cave.ui.prop(name: str, value: bool) -> bool cave.ui.prop(name: str, value: cave.Vector2) -> cave.Vector2 cave.ui.prop(name: str, value: cave.Vector3) -> cave.Vector3 cave.ui.prop(name: str, value: str) -> str ui.propSlider(...) Just like the cave.ui.prop , you can use the cave.ui.propSlider if you want to display the property with a slider, ranging from [ valueMin to valueMax ]. Here is the API for reference: cave.ui.propSlider(name: str, value: int, valueMin: float, valueMax: float) -> int cave.ui.propSlider(name: str, value: float, valueMin: float, valueMax: float) -> float cave.ui.propSlider(name: str, value: cave.Vector2, valueMin: float, valueMax: float) -> cave.Vector2 cave.ui.propSlider(name: str, value: cave.Vector3, valueMin: float, valueMax: float) -> cave.Vector3 ui.button(...) If you want you can also add buttons to your UI. They are simple and straight forward and will return True if the user clicks in it. Example: if cave.ui.button(\"Click Me!\"): print(\"Thank you for clicking me!\") And here is the API for reference: cave.ui.button(name: str) -> bool Tree Nodes You can also create a Tree Node structure in your UI. If the node is open, the treeNodeStart will return True . In this case (and only in this case), you must call the treeNodeEnd . Tree Nodes can be nested. Here is an usage example: if cave.ui.treeNodeStart(\"Node Example\"): cave.ui.text(\"Hello, world!\") # Must be called: cave.ui.treeNodeEnd() And here is the API for reference: cave.ui.treeNodeStart(name: str) -> bool cave.ui.treeNodeEnd() Various UI Functions The cave.ui.header works just like the Tree Node , except that you don't need to end this one. cave.ui.header(name: str) -> bool The cave.ui.separator() will add a horizontal separator line in your UI. Good for organization. cave.ui.separator() If you need to display some raw texts in the UI, you can do it by calling this funciton: cave.ui.text(name: str)","title":"UI Submodule API"},{"location":"PythonAPI/EditorAPI/uiModule/#ui-submodule-api","text":"Cave Engine provides, in the editor only, the cave.ui submodule for you to create your own custom tools. Be aware that it will not work if you attempt to use this in game!","title":"UI Submodule API"},{"location":"PythonAPI/EditorAPI/uiModule/#uidebugtab","text":"In order to use the UI Submodule API, you first need to create your own custom Tab by making a class that inherits and implements the ui.DebugTab . I've written a detailed documentation on how to do it at Editor Only API > Writting your own Tools , so consider reading it first.","title":"ui.DebugTab"},{"location":"PythonAPI/EditorAPI/uiModule/#variables","text":"The DebugTab only have one variable: the active . If True , the Tab will be rendered and displayed to the user. If not, it will be hidden and the engine user will have to enable it back by using the Tools menu in the top left corner of the Editor. active : bool","title":"Variables"},{"location":"PythonAPI/EditorAPI/uiModule/#methods","text":"Just like the variables, the DebugTab only have one method: the draw() . It's a virtual method intended for you to overwrite in order to draw your own UI to the Editor's screen. draw()","title":"Methods"},{"location":"PythonAPI/EditorAPI/uiModule/#ui-functions","text":"After creating your own ui.DebugTab , everything you'll do regarding UI will be using one of those functions below.","title":"UI Functions"},{"location":"PythonAPI/EditorAPI/uiModule/#uiprop","text":"In order to display variables in the UI, you'll need to use the cave.ui.prop function. It receives the prop name and also its current value and returns the updated one. Example on how to use it: self.myProp = cave.ui.prop(\"My Prop\", self.myProp) And here is the API for reference: cave.ui.prop(name: str, value: int) -> int cave.ui.prop(name: str, value: float) -> float cave.ui.prop(name: str, value: bool) -> bool cave.ui.prop(name: str, value: cave.Vector2) -> cave.Vector2 cave.ui.prop(name: str, value: cave.Vector3) -> cave.Vector3 cave.ui.prop(name: str, value: str) -> str","title":"ui.prop(...)"},{"location":"PythonAPI/EditorAPI/uiModule/#uipropslider","text":"Just like the cave.ui.prop , you can use the cave.ui.propSlider if you want to display the property with a slider, ranging from [ valueMin to valueMax ]. Here is the API for reference: cave.ui.propSlider(name: str, value: int, valueMin: float, valueMax: float) -> int cave.ui.propSlider(name: str, value: float, valueMin: float, valueMax: float) -> float cave.ui.propSlider(name: str, value: cave.Vector2, valueMin: float, valueMax: float) -> cave.Vector2 cave.ui.propSlider(name: str, value: cave.Vector3, valueMin: float, valueMax: float) -> cave.Vector3","title":"ui.propSlider(...)"},{"location":"PythonAPI/EditorAPI/uiModule/#uibutton","text":"If you want you can also add buttons to your UI. They are simple and straight forward and will return True if the user clicks in it. Example: if cave.ui.button(\"Click Me!\"): print(\"Thank you for clicking me!\") And here is the API for reference: cave.ui.button(name: str) -> bool","title":"ui.button(...)"},{"location":"PythonAPI/EditorAPI/uiModule/#tree-nodes","text":"You can also create a Tree Node structure in your UI. If the node is open, the treeNodeStart will return True . In this case (and only in this case), you must call the treeNodeEnd . Tree Nodes can be nested. Here is an usage example: if cave.ui.treeNodeStart(\"Node Example\"): cave.ui.text(\"Hello, world!\") # Must be called: cave.ui.treeNodeEnd() And here is the API for reference: cave.ui.treeNodeStart(name: str) -> bool cave.ui.treeNodeEnd()","title":"Tree Nodes"},{"location":"PythonAPI/EditorAPI/uiModule/#various-ui-functions","text":"The cave.ui.header works just like the Tree Node , except that you don't need to end this one. cave.ui.header(name: str) -> bool The cave.ui.separator() will add a horizontal separator line in your UI. Good for organization. cave.ui.separator() If you need to display some raw texts in the UI, you can do it by calling this funciton: cave.ui.text(name: str)","title":"Various UI Functions"},{"location":"PythonAPI/Events/events/","text":"Handling Events In order to handle events in Cave (to see if the user pressed a keyboard or mouse key), you'll need to use the cave.Events class. Note that you cannot instantiace your own Events class , instead of this, you can get the engine's events class instance by calling this function: events = cave.getEvents() cave.Events Here is an example of the cave Events system in action: events = cave.getEvents() if events.pressed(cave.event.KEY_W): print(\"The user pressed the key W!\") # You can also use the event names (as strings): if events.pressed(\"S\"): print(\"The user pressed the key S!\") # Mouse events works the same way: if events.released(cave.event.MOUSE_LEFT): print(\"The user released the left mouse button!\") Note: Again, do not instantiate a new instance of this class, you should always use the one provided by the cave.getEvents() function. Methods pressed(event : str) -> bool pressed(event : cave.event) -> bool Returns True if the user just pressed the event key or False if not. active(event : str) -> bool active(event : cave.event) -> bool Always returns True while the user is pressing the event key or False if not. released(event : str) -> bool released(event : cave.event) -> bool Returns True if the user just released the event key or False if not. The following methods are related to mouse specific behaviours: setRelativeMouse(value: bool) When enabled, the mouse will be invisible and the mouse motion will be computed (and available at GetMouseMotion()), but not applied to the mouse cursor. If enabled, then if you want to know how much the user moved the mouse (useful to make a mouselook, for example), use the getMouseMotion function. Reference: getMouseMotion() -> Vector2","title":"Handling Events"},{"location":"PythonAPI/Events/events/#handling-events","text":"In order to handle events in Cave (to see if the user pressed a keyboard or mouse key), you'll need to use the cave.Events class. Note that you cannot instantiace your own Events class , instead of this, you can get the engine's events class instance by calling this function: events = cave.getEvents()","title":"Handling Events"},{"location":"PythonAPI/Events/events/#caveevents","text":"Here is an example of the cave Events system in action: events = cave.getEvents() if events.pressed(cave.event.KEY_W): print(\"The user pressed the key W!\") # You can also use the event names (as strings): if events.pressed(\"S\"): print(\"The user pressed the key S!\") # Mouse events works the same way: if events.released(cave.event.MOUSE_LEFT): print(\"The user released the left mouse button!\") Note: Again, do not instantiate a new instance of this class, you should always use the one provided by the cave.getEvents() function.","title":"cave.Events"},{"location":"PythonAPI/Events/events/#methods","text":"pressed(event : str) -> bool pressed(event : cave.event) -> bool Returns True if the user just pressed the event key or False if not. active(event : str) -> bool active(event : cave.event) -> bool Always returns True while the user is pressing the event key or False if not. released(event : str) -> bool released(event : cave.event) -> bool Returns True if the user just released the event key or False if not. The following methods are related to mouse specific behaviours: setRelativeMouse(value: bool) When enabled, the mouse will be invisible and the mouse motion will be computed (and available at GetMouseMotion()), but not applied to the mouse cursor. If enabled, then if you want to know how much the user moved the mouse (useful to make a mouselook, for example), use the getMouseMotion function. Reference: getMouseMotion() -> Vector2","title":"Methods"},{"location":"PythonAPI/Events/keycodes/","text":"Event Keycodes In order to see if the user pressed a key, you'll need to use the correct keycodes for it. In cave, you can do this by passing the event type (from cave.event ) or by the key name as a string. See cave.Events for more details. In this page you'll find every key name. Mouse Events Event Type Event Name as String Key cave.event.MOUSE_LEFT \"MOUSE_LEFT\" Mouse Left cave.event.MOUSE_MIDDLE \"MOUSE_MIDDLE\" Mouse Middle cave.event.MOUSE_RIGHT \"MOUSE_RIGHT\" Mouse Right Keyboard Events Event Type Event Name as String Key cave.event.KEY_0 \"0\" 0 cave.event.KEY_1 \"1\" 1 cave.event.KEY_2 \"2\" 2 cave.event.KEY_3 \"3\" 3 cave.event.KEY_4 \"4\" 4 cave.event.KEY_5 \"5\" 5 cave.event.KEY_6 \"6\" 6 cave.event.KEY_7 \"7\" 7 cave.event.KEY_8 \"8\" 8 cave.event.KEY_9 \"9\" 9 cave.event.KEY_A \"A\" A cave.event.KEY_AC_BACK \"AC_BACK\" Ac Back cave.event.KEY_AC_BOOKMARKS \"AC_BOOKMARKS\" Ac Bookmarks cave.event.KEY_AC_FORWARD \"AC_FORWARD\" Ac Forward cave.event.KEY_AC_HOME \"AC_HOME\" Ac Home cave.event.KEY_AC_REFRESH \"AC_REFRESH\" Ac Refresh cave.event.KEY_AC_SEARCH \"AC_SEARCH\" Ac Search cave.event.KEY_AC_STOP \"AC_STOP\" Ac Stop cave.event.KEY_AGAIN \"AGAIN\" Again cave.event.KEY_ALTERASE \"ALTERASE\" Alterase cave.event.KEY_AMPERSAND \"AMPERSAND\" Ampersand cave.event.KEY_APPLICATION \"APPLICATION\" Application cave.event.KEY_ASTERISK \"ASTERISK\" Asterisk cave.event.KEY_AT \"AT\" At cave.event.KEY_AUDIOMUTE \"AUDIOMUTE\" Audiomute cave.event.KEY_AUDIONEXT \"AUDIONEXT\" Audionext cave.event.KEY_AUDIOPLAY \"AUDIOPLAY\" Audioplay cave.event.KEY_AUDIOPREV \"AUDIOPREV\" Audioprev cave.event.KEY_AUDIOSTOP \"AUDIOSTOP\" Audiostop cave.event.KEY_B \"B\" B cave.event.KEY_BACKQUOTE \"BACKQUOTE\" Backquote cave.event.KEY_BACKSLASH \"BACKSLASH\" Backslash cave.event.KEY_BACKSPACE \"BACKSPACE\" Backspace cave.event.KEY_BRIGHTNESSDOWN \"BRIGHTNESSDOWN\" Brightnessdown cave.event.KEY_BRIGHTNESSUP \"BRIGHTNESSUP\" Brightnessup cave.event.KEY_C \"C\" C cave.event.KEY_CALCULATOR \"CALCULATOR\" Calculator cave.event.KEY_CANCEL \"CANCEL\" Cancel cave.event.KEY_CAPSLOCK \"CAPSLOCK\" Capslock cave.event.KEY_CARET \"CARET\" Caret cave.event.KEY_CLEAR \"CLEAR\" Clear cave.event.KEY_CLEARAGAIN \"CLEARAGAIN\" Clearagain cave.event.KEY_COLON \"COLON\" Colon cave.event.KEY_COMMA \"COMMA\" Comma cave.event.KEY_COMPUTER \"COMPUTER\" Computer cave.event.KEY_COPY \"COPY\" Copy cave.event.KEY_CRSEL \"CRSEL\" Crsel cave.event.KEY_CURRENCYSUBUNIT \"CURRENCYSUBUNIT\" Currencysubunit cave.event.KEY_CURRENCYUNIT \"CURRENCYUNIT\" Currencyunit cave.event.KEY_CUT \"CUT\" Cut cave.event.KEY_D \"D\" D cave.event.KEY_DECIMALSEPARATOR \"DECIMALSEPARATOR\" Decimalseparator cave.event.KEY_DELETE \"DELETE\" Delete cave.event.KEY_DISPLAYSWITCH \"DISPLAYSWITCH\" Displayswitch cave.event.KEY_DOLLAR \"DOLLAR\" Dollar cave.event.KEY_DOWN \"DOWN\" Down cave.event.KEY_E \"E\" E cave.event.KEY_EJECT \"EJECT\" Eject cave.event.KEY_END \"END\" End cave.event.KEY_EQUALS \"EQUALS\" Equals cave.event.KEY_ESCAPE \"ESCAPE\" Escape cave.event.KEY_EXCLAIM \"EXCLAIM\" Exclaim cave.event.KEY_EXECUTE_ \"EXECUTE_\" Execute cave.event.KEY_EXSEL \"EXSEL\" Exsel cave.event.KEY_F \"F\" F cave.event.KEY_F1 \"F1\" F1 cave.event.KEY_F10 \"F10\" F10 cave.event.KEY_F11 \"F11\" F11 cave.event.KEY_F12 \"F12\" F12 cave.event.KEY_F13 \"F13\" F13 cave.event.KEY_F14 \"F14\" F14 cave.event.KEY_F15 \"F15\" F15 cave.event.KEY_F16 \"F16\" F16 cave.event.KEY_F17 \"F17\" F17 cave.event.KEY_F18 \"F18\" F18 cave.event.KEY_F19 \"F19\" F19 cave.event.KEY_F2 \"F2\" F2 cave.event.KEY_F20 \"F20\" F20 cave.event.KEY_F21 \"F21\" F21 cave.event.KEY_F22 \"F22\" F22 cave.event.KEY_F23 \"F23\" F23 cave.event.KEY_F24 \"F24\" F24 cave.event.KEY_F3 \"F3\" F3 cave.event.KEY_F4 \"F4\" F4 cave.event.KEY_F5 \"F5\" F5 cave.event.KEY_F6 \"F6\" F6 cave.event.KEY_F7 \"F7\" F7 cave.event.KEY_F8 \"F8\" F8 cave.event.KEY_F9 \"F9\" F9 cave.event.KEY_FIND \"FIND\" Find cave.event.KEY_G \"G\" G cave.event.KEY_GREATER \"GREATER\" Greater cave.event.KEY_H \"H\" H cave.event.KEY_HASH \"HASH\" Hash cave.event.KEY_HELP \"HELP\" Help cave.event.KEY_HOME \"HOME\" Home cave.event.KEY_I \"I\" I cave.event.KEY_INSERT \"INSERT\" Insert cave.event.KEY_J \"J\" J cave.event.KEY_K \"K\" K cave.event.KEY_KBDILLUMDOWN \"KBDILLUMDOWN\" Kbdillumdown cave.event.KEY_KBDILLUMTOGGLE \"KBDILLUMTOGGLE\" Kbdillumtoggle cave.event.KEY_KBDILLUMUP \"KBDILLUMUP\" Kbdillumup cave.event.KEY_KP_0 \"KP_0\" Kp 0 cave.event.KEY_KP_00 \"KP_00\" Kp 00 cave.event.KEY_KP_000 \"KP_000\" Kp 000 cave.event.KEY_KP_1 \"KP_1\" Kp 1 cave.event.KEY_KP_2 \"KP_2\" Kp 2 cave.event.KEY_KP_3 \"KP_3\" Kp 3 cave.event.KEY_KP_4 \"KP_4\" Kp 4 cave.event.KEY_KP_5 \"KP_5\" Kp 5 cave.event.KEY_KP_6 \"KP_6\" Kp 6 cave.event.KEY_KP_7 \"KP_7\" Kp 7 cave.event.KEY_KP_8 \"KP_8\" Kp 8 cave.event.KEY_KP_9 \"KP_9\" Kp 9 cave.event.KEY_KP_A \"KP_A\" Kp A cave.event.KEY_KP_AMPERSAND \"KP_AMPERSAND\" Kp Ampersand cave.event.KEY_KP_AT \"KP_AT\" Kp At cave.event.KEY_KP_B \"KP_B\" Kp B cave.event.KEY_KP_BACKSPACE \"KP_BACKSPACE\" Kp Backspace cave.event.KEY_KP_BINARY \"KP_BINARY\" Kp Binary cave.event.KEY_KP_C \"KP_C\" Kp C cave.event.KEY_KP_CLEAR \"KP_CLEAR\" Kp Clear cave.event.KEY_KP_CLEARENTRY \"KP_CLEARENTRY\" Kp Clearentry cave.event.KEY_KP_COLON \"KP_COLON\" Kp Colon cave.event.KEY_KP_COMMA \"KP_COMMA\" Kp Comma cave.event.KEY_KP_D \"KP_D\" Kp D cave.event.KEY_KP_DBLAMPERSAND \"KP_DBLAMPERSAND\" Kp Dblampersand cave.event.KEY_KP_DBLVERTICALBAR \"KP_DBLVERTICALBAR\" Kp Dblverticalbar cave.event.KEY_KP_DECIMAL \"KP_DECIMAL\" Kp Decimal cave.event.KEY_KP_DIVIDE \"KP_DIVIDE\" Kp Divide cave.event.KEY_KP_E \"KP_E\" Kp E cave.event.KEY_KP_ENTER \"KP_ENTER\" Kp Enter cave.event.KEY_KP_EQUALS \"KP_EQUALS\" Kp Equals cave.event.KEY_KP_EQUALSAS400 \"KP_EQUALSAS400\" Kp Equalsas400 cave.event.KEY_KP_EXCLAM \"KP_EXCLAM\" Kp Exclam cave.event.KEY_KP_F \"KP_F\" Kp F cave.event.KEY_KP_GREATER \"KP_GREATER\" Kp Greater cave.event.KEY_KP_HASH \"KP_HASH\" Kp Hash cave.event.KEY_KP_HEXADECIMAL \"KP_HEXADECIMAL\" Kp Hexadecimal cave.event.KEY_KP_LEFTBRACE \"KP_LEFTBRACE\" Kp Leftbrace cave.event.KEY_KP_LEFTPAREN \"KP_LEFTPAREN\" Kp Leftparen cave.event.KEY_KP_LESS \"KP_LESS\" Kp Less cave.event.KEY_KP_MEMADD \"KP_MEMADD\" Kp Memadd cave.event.KEY_KP_MEMCLEAR \"KP_MEMCLEAR\" Kp Memclear cave.event.KEY_KP_MEMDIVIDE \"KP_MEMDIVIDE\" Kp Memdivide cave.event.KEY_KP_MEMMULTIPLY \"KP_MEMMULTIPLY\" Kp Memmultiply cave.event.KEY_KP_MEMRECALL \"KP_MEMRECALL\" Kp Memrecall cave.event.KEY_KP_MEMSTORE \"KP_MEMSTORE\" Kp Memstore cave.event.KEY_KP_MEMSUBTRACT \"KP_MEMSUBTRACT\" Kp Memsubtract cave.event.KEY_KP_MINUS \"KP_MINUS\" Kp Minus cave.event.KEY_KP_MULTIPLY \"KP_MULTIPLY\" Kp Multiply cave.event.KEY_KP_OCTAL \"KP_OCTAL\" Kp Octal cave.event.KEY_KP_PERCENT \"KP_PERCENT\" Kp Percent cave.event.KEY_KP_PERIOD \"KP_PERIOD\" Kp Period cave.event.KEY_KP_PLUS \"KP_PLUS\" Kp Plus cave.event.KEY_KP_PLUSMINUS \"KP_PLUSMINUS\" Kp Plusminus cave.event.KEY_KP_POWER \"KP_POWER\" Kp Power cave.event.KEY_KP_RIGHTBRACE \"KP_RIGHTBRACE\" Kp Rightbrace cave.event.KEY_KP_RIGHTPAREN \"KP_RIGHTPAREN\" Kp Rightparen cave.event.KEY_KP_SPACE \"KP_SPACE\" Kp Space cave.event.KEY_KP_TAB \"KP_TAB\" Kp Tab cave.event.KEY_KP_VERTICALBAR \"KP_VERTICALBAR\" Kp Verticalbar cave.event.KEY_KP_XOR \"KP_XOR\" Kp Xor cave.event.KEY_L \"L\" L cave.event.KEY_LALT \"LALT\" Lalt cave.event.KEY_LCTRL \"LCTRL\" Lctrl cave.event.KEY_LEFT \"LEFT\" Left cave.event.KEY_LEFTBRACKET \"LEFTBRACKET\" Leftbracket cave.event.KEY_LEFTPAREN \"LEFTPAREN\" Leftparen cave.event.KEY_LESS \"LESS\" Less cave.event.KEY_LGUI \"LGUI\" Lgui cave.event.KEY_LSHIFT \"LSHIFT\" Lshift cave.event.KEY_M \"M\" M cave.event.KEY_MAIL \"MAIL\" Mail cave.event.KEY_MEDIASELECT \"MEDIASELECT\" Mediaselect cave.event.KEY_MENU \"MENU\" Menu cave.event.KEY_MINUS \"MINUS\" Minus cave.event.KEY_MODE \"MODE\" Mode cave.event.KEY_MUTE \"MUTE\" Mute cave.event.KEY_N \"N\" N cave.event.KEY_NUMLOCKCLEAR \"NUMLOCKCLEAR\" Numlockclear cave.event.KEY_O \"O\" O cave.event.KEY_OPER \"OPER\" Oper cave.event.KEY_OUT \"OUT\" Out cave.event.KEY_P \"P\" P cave.event.KEY_PAGEDOWN \"PAGEDOWN\" Pagedown cave.event.KEY_PAGEUP \"PAGEUP\" Pageup cave.event.KEY_PASTE \"PASTE\" Paste cave.event.KEY_PAUSE \"PAUSE\" Pause cave.event.KEY_PERCENT \"PERCENT\" Percent cave.event.KEY_PERIOD \"PERIOD\" Period cave.event.KEY_PLUS \"PLUS\" Plus cave.event.KEY_POWER \"POWER\" Power cave.event.KEY_PRINTSCREEN \"PRINTSCREEN\" Printscreen cave.event.KEY_PRIOR \"PRIOR\" Prior cave.event.KEY_Q \"Q\" Q cave.event.KEY_QUESTION \"QUESTION\" Question cave.event.KEY_QUOTE \"QUOTE\" Quote cave.event.KEY_QUOTEDBL \"QUOTEDBL\" Quotedbl cave.event.KEY_R \"R\" R cave.event.KEY_RALT \"RALT\" Ralt cave.event.KEY_RCTRL \"RCTRL\" Rctrl cave.event.KEY_RETURN \"RETURN\" Return cave.event.KEY_RETURN2 \"RETURN2\" Return2 cave.event.KEY_RGUI \"RGUI\" Rgui cave.event.KEY_RIGHT \"RIGHT\" Right cave.event.KEY_RIGHTBRACKET \"RIGHTBRACKET\" Rightbracket cave.event.KEY_RIGHTPAREN \"RIGHTPAREN\" Rightparen cave.event.KEY_RSHIFT \"RSHIFT\" Rshift cave.event.KEY_S \"S\" S cave.event.KEY_SCROLLLOCK \"SCROLLLOCK\" Scrolllock cave.event.KEY_SELECT \"SELECT\" Select cave.event.KEY_SEMICOLON \"SEMICOLON\" Semicolon cave.event.KEY_SEPARATOR \"SEPARATOR\" Separator cave.event.KEY_SIZE \"SIZE\" Size cave.event.KEY_SLASH \"SLASH\" Slash cave.event.KEY_SLEEP \"SLEEP\" Sleep cave.event.KEY_SPACE \"SPACE\" Space cave.event.KEY_STOP \"STOP\" Stop cave.event.KEY_SYSREQ \"SYSREQ\" Sysreq cave.event.KEY_T \"T\" T cave.event.KEY_TAB \"TAB\" Tab cave.event.KEY_THOUSANDSSEPARATOR \"THOUSANDSSEPARATOR\" Thousandsseparator cave.event.KEY_U \"U\" U cave.event.KEY_UNDO \"UNDO\" Undo cave.event.KEY_UNKNOWN \"UNKNOWN\" Unknown cave.event.KEY_UP \"UP\" Up cave.event.KEY_V \"V\" V cave.event.KEY_VOLUMEDOWN \"VOLUMEDOWN\" Volumedown cave.event.KEY_VOLUMEUP \"VOLUMEUP\" Volumeup cave.event.KEY_W \"W\" W cave.event.KEY_WWW \"WWW\" Www cave.event.KEY_X \"X\" X cave.event.KEY_Y \"Y\" Y cave.event.KEY_Z \"Z\" Z","title":"Keycodes"},{"location":"PythonAPI/Events/keycodes/#event-keycodes","text":"In order to see if the user pressed a key, you'll need to use the correct keycodes for it. In cave, you can do this by passing the event type (from cave.event ) or by the key name as a string. See cave.Events for more details. In this page you'll find every key name.","title":"Event Keycodes"},{"location":"PythonAPI/Events/keycodes/#mouse-events","text":"Event Type Event Name as String Key cave.event.MOUSE_LEFT \"MOUSE_LEFT\" Mouse Left cave.event.MOUSE_MIDDLE \"MOUSE_MIDDLE\" Mouse Middle cave.event.MOUSE_RIGHT \"MOUSE_RIGHT\" Mouse Right","title":"Mouse Events"},{"location":"PythonAPI/Events/keycodes/#keyboard-events","text":"Event Type Event Name as String Key cave.event.KEY_0 \"0\" 0 cave.event.KEY_1 \"1\" 1 cave.event.KEY_2 \"2\" 2 cave.event.KEY_3 \"3\" 3 cave.event.KEY_4 \"4\" 4 cave.event.KEY_5 \"5\" 5 cave.event.KEY_6 \"6\" 6 cave.event.KEY_7 \"7\" 7 cave.event.KEY_8 \"8\" 8 cave.event.KEY_9 \"9\" 9 cave.event.KEY_A \"A\" A cave.event.KEY_AC_BACK \"AC_BACK\" Ac Back cave.event.KEY_AC_BOOKMARKS \"AC_BOOKMARKS\" Ac Bookmarks cave.event.KEY_AC_FORWARD \"AC_FORWARD\" Ac Forward cave.event.KEY_AC_HOME \"AC_HOME\" Ac Home cave.event.KEY_AC_REFRESH \"AC_REFRESH\" Ac Refresh cave.event.KEY_AC_SEARCH \"AC_SEARCH\" Ac Search cave.event.KEY_AC_STOP \"AC_STOP\" Ac Stop cave.event.KEY_AGAIN \"AGAIN\" Again cave.event.KEY_ALTERASE \"ALTERASE\" Alterase cave.event.KEY_AMPERSAND \"AMPERSAND\" Ampersand cave.event.KEY_APPLICATION \"APPLICATION\" Application cave.event.KEY_ASTERISK \"ASTERISK\" Asterisk cave.event.KEY_AT \"AT\" At cave.event.KEY_AUDIOMUTE \"AUDIOMUTE\" Audiomute cave.event.KEY_AUDIONEXT \"AUDIONEXT\" Audionext cave.event.KEY_AUDIOPLAY \"AUDIOPLAY\" Audioplay cave.event.KEY_AUDIOPREV \"AUDIOPREV\" Audioprev cave.event.KEY_AUDIOSTOP \"AUDIOSTOP\" Audiostop cave.event.KEY_B \"B\" B cave.event.KEY_BACKQUOTE \"BACKQUOTE\" Backquote cave.event.KEY_BACKSLASH \"BACKSLASH\" Backslash cave.event.KEY_BACKSPACE \"BACKSPACE\" Backspace cave.event.KEY_BRIGHTNESSDOWN \"BRIGHTNESSDOWN\" Brightnessdown cave.event.KEY_BRIGHTNESSUP \"BRIGHTNESSUP\" Brightnessup cave.event.KEY_C \"C\" C cave.event.KEY_CALCULATOR \"CALCULATOR\" Calculator cave.event.KEY_CANCEL \"CANCEL\" Cancel cave.event.KEY_CAPSLOCK \"CAPSLOCK\" Capslock cave.event.KEY_CARET \"CARET\" Caret cave.event.KEY_CLEAR \"CLEAR\" Clear cave.event.KEY_CLEARAGAIN \"CLEARAGAIN\" Clearagain cave.event.KEY_COLON \"COLON\" Colon cave.event.KEY_COMMA \"COMMA\" Comma cave.event.KEY_COMPUTER \"COMPUTER\" Computer cave.event.KEY_COPY \"COPY\" Copy cave.event.KEY_CRSEL \"CRSEL\" Crsel cave.event.KEY_CURRENCYSUBUNIT \"CURRENCYSUBUNIT\" Currencysubunit cave.event.KEY_CURRENCYUNIT \"CURRENCYUNIT\" Currencyunit cave.event.KEY_CUT \"CUT\" Cut cave.event.KEY_D \"D\" D cave.event.KEY_DECIMALSEPARATOR \"DECIMALSEPARATOR\" Decimalseparator cave.event.KEY_DELETE \"DELETE\" Delete cave.event.KEY_DISPLAYSWITCH \"DISPLAYSWITCH\" Displayswitch cave.event.KEY_DOLLAR \"DOLLAR\" Dollar cave.event.KEY_DOWN \"DOWN\" Down cave.event.KEY_E \"E\" E cave.event.KEY_EJECT \"EJECT\" Eject cave.event.KEY_END \"END\" End cave.event.KEY_EQUALS \"EQUALS\" Equals cave.event.KEY_ESCAPE \"ESCAPE\" Escape cave.event.KEY_EXCLAIM \"EXCLAIM\" Exclaim cave.event.KEY_EXECUTE_ \"EXECUTE_\" Execute cave.event.KEY_EXSEL \"EXSEL\" Exsel cave.event.KEY_F \"F\" F cave.event.KEY_F1 \"F1\" F1 cave.event.KEY_F10 \"F10\" F10 cave.event.KEY_F11 \"F11\" F11 cave.event.KEY_F12 \"F12\" F12 cave.event.KEY_F13 \"F13\" F13 cave.event.KEY_F14 \"F14\" F14 cave.event.KEY_F15 \"F15\" F15 cave.event.KEY_F16 \"F16\" F16 cave.event.KEY_F17 \"F17\" F17 cave.event.KEY_F18 \"F18\" F18 cave.event.KEY_F19 \"F19\" F19 cave.event.KEY_F2 \"F2\" F2 cave.event.KEY_F20 \"F20\" F20 cave.event.KEY_F21 \"F21\" F21 cave.event.KEY_F22 \"F22\" F22 cave.event.KEY_F23 \"F23\" F23 cave.event.KEY_F24 \"F24\" F24 cave.event.KEY_F3 \"F3\" F3 cave.event.KEY_F4 \"F4\" F4 cave.event.KEY_F5 \"F5\" F5 cave.event.KEY_F6 \"F6\" F6 cave.event.KEY_F7 \"F7\" F7 cave.event.KEY_F8 \"F8\" F8 cave.event.KEY_F9 \"F9\" F9 cave.event.KEY_FIND \"FIND\" Find cave.event.KEY_G \"G\" G cave.event.KEY_GREATER \"GREATER\" Greater cave.event.KEY_H \"H\" H cave.event.KEY_HASH \"HASH\" Hash cave.event.KEY_HELP \"HELP\" Help cave.event.KEY_HOME \"HOME\" Home cave.event.KEY_I \"I\" I cave.event.KEY_INSERT \"INSERT\" Insert cave.event.KEY_J \"J\" J cave.event.KEY_K \"K\" K cave.event.KEY_KBDILLUMDOWN \"KBDILLUMDOWN\" Kbdillumdown cave.event.KEY_KBDILLUMTOGGLE \"KBDILLUMTOGGLE\" Kbdillumtoggle cave.event.KEY_KBDILLUMUP \"KBDILLUMUP\" Kbdillumup cave.event.KEY_KP_0 \"KP_0\" Kp 0 cave.event.KEY_KP_00 \"KP_00\" Kp 00 cave.event.KEY_KP_000 \"KP_000\" Kp 000 cave.event.KEY_KP_1 \"KP_1\" Kp 1 cave.event.KEY_KP_2 \"KP_2\" Kp 2 cave.event.KEY_KP_3 \"KP_3\" Kp 3 cave.event.KEY_KP_4 \"KP_4\" Kp 4 cave.event.KEY_KP_5 \"KP_5\" Kp 5 cave.event.KEY_KP_6 \"KP_6\" Kp 6 cave.event.KEY_KP_7 \"KP_7\" Kp 7 cave.event.KEY_KP_8 \"KP_8\" Kp 8 cave.event.KEY_KP_9 \"KP_9\" Kp 9 cave.event.KEY_KP_A \"KP_A\" Kp A cave.event.KEY_KP_AMPERSAND \"KP_AMPERSAND\" Kp Ampersand cave.event.KEY_KP_AT \"KP_AT\" Kp At cave.event.KEY_KP_B \"KP_B\" Kp B cave.event.KEY_KP_BACKSPACE \"KP_BACKSPACE\" Kp Backspace cave.event.KEY_KP_BINARY \"KP_BINARY\" Kp Binary cave.event.KEY_KP_C \"KP_C\" Kp C cave.event.KEY_KP_CLEAR \"KP_CLEAR\" Kp Clear cave.event.KEY_KP_CLEARENTRY \"KP_CLEARENTRY\" Kp Clearentry cave.event.KEY_KP_COLON \"KP_COLON\" Kp Colon cave.event.KEY_KP_COMMA \"KP_COMMA\" Kp Comma cave.event.KEY_KP_D \"KP_D\" Kp D cave.event.KEY_KP_DBLAMPERSAND \"KP_DBLAMPERSAND\" Kp Dblampersand cave.event.KEY_KP_DBLVERTICALBAR \"KP_DBLVERTICALBAR\" Kp Dblverticalbar cave.event.KEY_KP_DECIMAL \"KP_DECIMAL\" Kp Decimal cave.event.KEY_KP_DIVIDE \"KP_DIVIDE\" Kp Divide cave.event.KEY_KP_E \"KP_E\" Kp E cave.event.KEY_KP_ENTER \"KP_ENTER\" Kp Enter cave.event.KEY_KP_EQUALS \"KP_EQUALS\" Kp Equals cave.event.KEY_KP_EQUALSAS400 \"KP_EQUALSAS400\" Kp Equalsas400 cave.event.KEY_KP_EXCLAM \"KP_EXCLAM\" Kp Exclam cave.event.KEY_KP_F \"KP_F\" Kp F cave.event.KEY_KP_GREATER \"KP_GREATER\" Kp Greater cave.event.KEY_KP_HASH \"KP_HASH\" Kp Hash cave.event.KEY_KP_HEXADECIMAL \"KP_HEXADECIMAL\" Kp Hexadecimal cave.event.KEY_KP_LEFTBRACE \"KP_LEFTBRACE\" Kp Leftbrace cave.event.KEY_KP_LEFTPAREN \"KP_LEFTPAREN\" Kp Leftparen cave.event.KEY_KP_LESS \"KP_LESS\" Kp Less cave.event.KEY_KP_MEMADD \"KP_MEMADD\" Kp Memadd cave.event.KEY_KP_MEMCLEAR \"KP_MEMCLEAR\" Kp Memclear cave.event.KEY_KP_MEMDIVIDE \"KP_MEMDIVIDE\" Kp Memdivide cave.event.KEY_KP_MEMMULTIPLY \"KP_MEMMULTIPLY\" Kp Memmultiply cave.event.KEY_KP_MEMRECALL \"KP_MEMRECALL\" Kp Memrecall cave.event.KEY_KP_MEMSTORE \"KP_MEMSTORE\" Kp Memstore cave.event.KEY_KP_MEMSUBTRACT \"KP_MEMSUBTRACT\" Kp Memsubtract cave.event.KEY_KP_MINUS \"KP_MINUS\" Kp Minus cave.event.KEY_KP_MULTIPLY \"KP_MULTIPLY\" Kp Multiply cave.event.KEY_KP_OCTAL \"KP_OCTAL\" Kp Octal cave.event.KEY_KP_PERCENT \"KP_PERCENT\" Kp Percent cave.event.KEY_KP_PERIOD \"KP_PERIOD\" Kp Period cave.event.KEY_KP_PLUS \"KP_PLUS\" Kp Plus cave.event.KEY_KP_PLUSMINUS \"KP_PLUSMINUS\" Kp Plusminus cave.event.KEY_KP_POWER \"KP_POWER\" Kp Power cave.event.KEY_KP_RIGHTBRACE \"KP_RIGHTBRACE\" Kp Rightbrace cave.event.KEY_KP_RIGHTPAREN \"KP_RIGHTPAREN\" Kp Rightparen cave.event.KEY_KP_SPACE \"KP_SPACE\" Kp Space cave.event.KEY_KP_TAB \"KP_TAB\" Kp Tab cave.event.KEY_KP_VERTICALBAR \"KP_VERTICALBAR\" Kp Verticalbar cave.event.KEY_KP_XOR \"KP_XOR\" Kp Xor cave.event.KEY_L \"L\" L cave.event.KEY_LALT \"LALT\" Lalt cave.event.KEY_LCTRL \"LCTRL\" Lctrl cave.event.KEY_LEFT \"LEFT\" Left cave.event.KEY_LEFTBRACKET \"LEFTBRACKET\" Leftbracket cave.event.KEY_LEFTPAREN \"LEFTPAREN\" Leftparen cave.event.KEY_LESS \"LESS\" Less cave.event.KEY_LGUI \"LGUI\" Lgui cave.event.KEY_LSHIFT \"LSHIFT\" Lshift cave.event.KEY_M \"M\" M cave.event.KEY_MAIL \"MAIL\" Mail cave.event.KEY_MEDIASELECT \"MEDIASELECT\" Mediaselect cave.event.KEY_MENU \"MENU\" Menu cave.event.KEY_MINUS \"MINUS\" Minus cave.event.KEY_MODE \"MODE\" Mode cave.event.KEY_MUTE \"MUTE\" Mute cave.event.KEY_N \"N\" N cave.event.KEY_NUMLOCKCLEAR \"NUMLOCKCLEAR\" Numlockclear cave.event.KEY_O \"O\" O cave.event.KEY_OPER \"OPER\" Oper cave.event.KEY_OUT \"OUT\" Out cave.event.KEY_P \"P\" P cave.event.KEY_PAGEDOWN \"PAGEDOWN\" Pagedown cave.event.KEY_PAGEUP \"PAGEUP\" Pageup cave.event.KEY_PASTE \"PASTE\" Paste cave.event.KEY_PAUSE \"PAUSE\" Pause cave.event.KEY_PERCENT \"PERCENT\" Percent cave.event.KEY_PERIOD \"PERIOD\" Period cave.event.KEY_PLUS \"PLUS\" Plus cave.event.KEY_POWER \"POWER\" Power cave.event.KEY_PRINTSCREEN \"PRINTSCREEN\" Printscreen cave.event.KEY_PRIOR \"PRIOR\" Prior cave.event.KEY_Q \"Q\" Q cave.event.KEY_QUESTION \"QUESTION\" Question cave.event.KEY_QUOTE \"QUOTE\" Quote cave.event.KEY_QUOTEDBL \"QUOTEDBL\" Quotedbl cave.event.KEY_R \"R\" R cave.event.KEY_RALT \"RALT\" Ralt cave.event.KEY_RCTRL \"RCTRL\" Rctrl cave.event.KEY_RETURN \"RETURN\" Return cave.event.KEY_RETURN2 \"RETURN2\" Return2 cave.event.KEY_RGUI \"RGUI\" Rgui cave.event.KEY_RIGHT \"RIGHT\" Right cave.event.KEY_RIGHTBRACKET \"RIGHTBRACKET\" Rightbracket cave.event.KEY_RIGHTPAREN \"RIGHTPAREN\" Rightparen cave.event.KEY_RSHIFT \"RSHIFT\" Rshift cave.event.KEY_S \"S\" S cave.event.KEY_SCROLLLOCK \"SCROLLLOCK\" Scrolllock cave.event.KEY_SELECT \"SELECT\" Select cave.event.KEY_SEMICOLON \"SEMICOLON\" Semicolon cave.event.KEY_SEPARATOR \"SEPARATOR\" Separator cave.event.KEY_SIZE \"SIZE\" Size cave.event.KEY_SLASH \"SLASH\" Slash cave.event.KEY_SLEEP \"SLEEP\" Sleep cave.event.KEY_SPACE \"SPACE\" Space cave.event.KEY_STOP \"STOP\" Stop cave.event.KEY_SYSREQ \"SYSREQ\" Sysreq cave.event.KEY_T \"T\" T cave.event.KEY_TAB \"TAB\" Tab cave.event.KEY_THOUSANDSSEPARATOR \"THOUSANDSSEPARATOR\" Thousandsseparator cave.event.KEY_U \"U\" U cave.event.KEY_UNDO \"UNDO\" Undo cave.event.KEY_UNKNOWN \"UNKNOWN\" Unknown cave.event.KEY_UP \"UP\" Up cave.event.KEY_V \"V\" V cave.event.KEY_VOLUMEDOWN \"VOLUMEDOWN\" Volumedown cave.event.KEY_VOLUMEUP \"VOLUMEUP\" Volumeup cave.event.KEY_W \"W\" W cave.event.KEY_WWW \"WWW\" Www cave.event.KEY_X \"X\" X cave.event.KEY_Y \"Y\" Y cave.event.KEY_Z \"Z\" Z","title":"Keyboard Events"},{"location":"Showcase/games/","text":"Games Powered by Cave In this section you'll find good examples of what is possible to do using Cave Engine . Paralland Made in 72 hours for the game jam Ludum Dare 51 , Paralland is also an Uniday Studio game. It was created using Cave Engine version 0.9.8. In PARALLAND, you control a little guy who is trapped in a spell that makes the world flips between the normal dimension and the \u201cparalland\u201d one. The problem is that this new dimension is evil, full of bad creatures and traps. You need to help the little guy to collect all the orbs stuck in Paralland in order to proceed to the portals and escape! It's a platformer game available for you to Play here . The Looper's Path This is the first Uniday Studio game made using Cave! And it was made in 72 hours for the game jam Ludum Dare 50 . It was created using Cave Engine version 0.9.8. In this game you control Looper, a robot that loses his energy (in a shape of energy orbs) as you walk. When it runs out of energy, it explodes! The good news is that looper does have clones to help you walk throught the levels and their clones will recover energy from your past lost orbs. It's a puzzle game available for you to Play on Itch io . Sweet Shelter The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here: Sweet Shelter on itch io Ralph! Ralph is also doing some amazing work using the engine: He was one of the first active Cave Engine user, way before it was even named cave. Thank you!","title":"Games Made with Cave"},{"location":"Showcase/games/#games-powered-by-cave","text":"In this section you'll find good examples of what is possible to do using Cave Engine .","title":"Games Powered by Cave"},{"location":"Showcase/games/#paralland","text":"Made in 72 hours for the game jam Ludum Dare 51 , Paralland is also an Uniday Studio game. It was created using Cave Engine version 0.9.8. In PARALLAND, you control a little guy who is trapped in a spell that makes the world flips between the normal dimension and the \u201cparalland\u201d one. The problem is that this new dimension is evil, full of bad creatures and traps. You need to help the little guy to collect all the orbs stuck in Paralland in order to proceed to the portals and escape! It's a platformer game available for you to Play here .","title":"Paralland"},{"location":"Showcase/games/#the-loopers-path","text":"This is the first Uniday Studio game made using Cave! And it was made in 72 hours for the game jam Ludum Dare 50 . It was created using Cave Engine version 0.9.8. In this game you control Looper, a robot that loses his energy (in a shape of energy orbs) as you walk. When it runs out of energy, it explodes! The good news is that looper does have clones to help you walk throught the levels and their clones will recover energy from your past lost orbs. It's a puzzle game available for you to Play on Itch io .","title":"The Looper's Path"},{"location":"Showcase/games/#sweet-shelter","text":"The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here: Sweet Shelter on itch io","title":"Sweet Shelter"},{"location":"Showcase/games/#ralph","text":"Ralph is also doing some amazing work using the engine: He was one of the first active Cave Engine user, way before it was even named cave. Thank you!","title":"Ralph!"}]}