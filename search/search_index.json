{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Cave Engine's Documentation (Use the top menu to navigate in the categories) Cave Engine is a Simple 3D desktop Game Engine scriptable in Python. In this website you'll find the documentation you need to get started with the scripting in the engine and also some useful information such as the future roadmap and license. Download the Engine You can check the details and download the engine using this link: Download the Cave Engine Our Discord Server If you want to talk about the engine, leave some suggestions, comments or get some help from the community, feel free to join us: Discord - English Discord - Portuguese/Brazil Note that at the moment we have a portuguese and an english discord so you can feel free to join the one you're more confortable with.","title":"Home"},{"location":"#welcome-to-cave-engines-documentation","text":"(Use the top menu to navigate in the categories) Cave Engine is a Simple 3D desktop Game Engine scriptable in Python. In this website you'll find the documentation you need to get started with the scripting in the engine and also some useful information such as the future roadmap and license.","title":"Welcome to Cave Engine's Documentation"},{"location":"#download-the-engine","text":"You can check the details and download the engine using this link: Download the Cave Engine","title":"Download the Engine"},{"location":"#our-discord-server","text":"If you want to talk about the engine, leave some suggestions, comments or get some help from the community, feel free to join us: Discord - English Discord - Portuguese/Brazil Note that at the moment we have a portuguese and an english discord so you can feel free to join the one you're more confortable with.","title":"Our Discord Server"},{"location":"Docs/eula/","text":"In a Nutshell: Cave Engine consists in two parts : The Cave Engine Editor and everything it requires to run. The end-product \" Game \" generated by the editor. The Cave Engine Editor is an intellectual property of Uniday Studio and you have a personal, non-transferable, non-exclusive licence to use the Cave Engine Editor software on your devices. You're not allowed to share, modify or redistribute it in any forms other than the ones provided by Uniday Studio. The Game generated by the Cave Engine Editor can be redistributed (even commercially) uner the collowing term: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. Including the phrase: \"Made using Cave Engine - from Uniday Studio\" in the project and license, in a visible and easily foundable place is enough. Remember that the name Uniday Studio is a registered trademark and you are not allowed to use it to endorse your projects in any forms. End-User License Agreement (EULA) of Cave Engine This End-User License Agreement (\"EULA\") is a legal agreement between you and Uniday Studio . This EULA agreement governs your acquisition and use of our Cave Engine software (\"Software\") directly from Uniday Studio or indirectly through a Uniday Studio authorized reseller or distributor (a \"Reseller\"). Our Privacy Policy was created by the Privacy Policy Generator. Please read this EULA agreement carefully before completing the installation process and using the Cave Engine software. It provides a license to use the Cave Engine software and contains warranty information and liability disclaimers. If you register for a free trial of the Cave Engine software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Cave Engine software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Uniday Studio herewith regardless of whether other software is referred to or described herein. The terms also apply to any Uniday Studio updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply. License Grant Uniday Studio hereby grants you a personal, non-transferable, non-exclusive licence to use the Cave Engine software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Cave Engine software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Cave Engine software. Uniday Studios also hereby grants you the rights to redistribute the end-product \"Game\" generated by the editor, including for commercial purposes, under the following terms: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. The exported Game can not include a copy of the Cave Engine Editor . Not use a license that forces this software to be open source or change its license (such as GPL). Your project (game) can be source open but the Cave Engine Editor software can't be forced to. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose, except with the generated Game . Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Uniday Studio considers is a breach of this EULA agreement Intellectual Property and Ownership Uniday Studio shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Uniday Studio. Uniday Studio reserves the right to grant licences to use the Software to third parties. Termination This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Uniday Studio. It will also terminate immediately if you fail to comply with any term of this EULA agreement. Upon such termination, the licenses granted by this EULA agreement will immediately terminate and you agree to stop all access and use of the Software. The provisions that by their nature continue and survive will survive any termination of this EULA agreement. Governing Law This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of Brazil.","title":"License (EULA)"},{"location":"Docs/eula/#in-a-nutshell","text":"Cave Engine consists in two parts : The Cave Engine Editor and everything it requires to run. The end-product \" Game \" generated by the editor. The Cave Engine Editor is an intellectual property of Uniday Studio and you have a personal, non-transferable, non-exclusive licence to use the Cave Engine Editor software on your devices. You're not allowed to share, modify or redistribute it in any forms other than the ones provided by Uniday Studio. The Game generated by the Cave Engine Editor can be redistributed (even commercially) uner the collowing term: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. Including the phrase: \"Made using Cave Engine - from Uniday Studio\" in the project and license, in a visible and easily foundable place is enough. Remember that the name Uniday Studio is a registered trademark and you are not allowed to use it to endorse your projects in any forms.","title":"In a Nutshell:"},{"location":"Docs/eula/#end-user-license-agreement-eula-of-cave-engine","text":"This End-User License Agreement (\"EULA\") is a legal agreement between you and Uniday Studio . This EULA agreement governs your acquisition and use of our Cave Engine software (\"Software\") directly from Uniday Studio or indirectly through a Uniday Studio authorized reseller or distributor (a \"Reseller\"). Our Privacy Policy was created by the Privacy Policy Generator. Please read this EULA agreement carefully before completing the installation process and using the Cave Engine software. It provides a license to use the Cave Engine software and contains warranty information and liability disclaimers. If you register for a free trial of the Cave Engine software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Cave Engine software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Uniday Studio herewith regardless of whether other software is referred to or described herein. The terms also apply to any Uniday Studio updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply.","title":"End-User License Agreement (EULA) of Cave Engine"},{"location":"Docs/eula/#license-grant","text":"Uniday Studio hereby grants you a personal, non-transferable, non-exclusive licence to use the Cave Engine software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Cave Engine software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Cave Engine software. Uniday Studios also hereby grants you the rights to redistribute the end-product \"Game\" generated by the editor, including for commercial purposes, under the following terms: Attribution - You must give appropriate credit to Uniday Studio and Cave Engine for the provided software. The exported Game can not include a copy of the Cave Engine Editor . Not use a license that forces this software to be open source or change its license (such as GPL). Your project (game) can be source open but the Cave Engine Editor software can't be forced to. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose, except with the generated Game . Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Uniday Studio considers is a breach of this EULA agreement","title":"License Grant"},{"location":"Docs/eula/#intellectual-property-and-ownership","text":"Uniday Studio shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Uniday Studio. Uniday Studio reserves the right to grant licences to use the Software to third parties.","title":"Intellectual Property and Ownership"},{"location":"Docs/eula/#termination","text":"This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Uniday Studio. It will also terminate immediately if you fail to comply with any term of this EULA agreement. Upon such termination, the licenses granted by this EULA agreement will immediately terminate and you agree to stop all access and use of the Software. The provisions that by their nature continue and survive will survive any termination of this EULA agreement.","title":"Termination"},{"location":"Docs/eula/#governing-law","text":"This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of Brazil.","title":"Governing Law"},{"location":"Docs/faq/","text":"Frequently Asked Questions (FAQ) What is the Point of Cave Engine? In a nutshell: Cave Engine is focusing 100% on the usability and your experience using it. Keep it as simple as possible so even someone with zero experience with game development will be able to use it, but at the same time, keep it powerful enough to support your biggest dreams . And how we are managing to do that? We are a company called Uniday Studio that develops and teaches game dev since many years ago. We had te opportunity to reach more than two million people across the world on YouTube, teaching game dev, and we have hundreds and hundreds of students in our courses. After so many years, students and answering literally dozens of thousands of questions about the topic, we realized that a lot of people don't make their games because they found too hard to get started or use the software. We reched a conclusion that, just like a joke, if a game engine needs an explanation on how to use it, then this engine may not be that good. And that's our main principle now. Of course, some things inside a game engine may need a few tips to figure out how to use, but hours and hours of tutorials only to get started? That's not an option for us. Cave Engine is focused in provide the smallest path between you and your dream games. Is Cave Engine free? Yes. Can I sell or Redistribute my Game made using Cave Engine? Yes! Under attribution to the Cave Engine - by Uniday Studio. That's it! Can I sell or Redistribute the Cave Engine Editor? No! The Cave Engine Editor is an intellectual property of Uniday Studio and you don't have permission to sell or redistribute it. If you want/need to share the engine with someone, please use the links provided by Uniday Studio. There are plans to support 2D games? No, there is no plans to add 2D game specific features. Cave Engine is 100% focused on 3D game development. But also note that nothing avoids you to use an ortographic camera and create a 2D game using it. How can I create my Logics using Cave Engine? You can do it using Python Scripts . And be aware: There are plans to include a Visual Programming alternative. Was the entire engine written in Python? Absolutely no! All the Engine and Editor was written in C/C++ and GLSL. We just provide Python Scripting as a front end for you to easily create the logic of your games. To which Platforms can I export my game? For now, you can export your games for Windows. There are plans to support Linux and Mac in the future, but it's low priority for now. Will be possible to export the game to other platforms such as Android in the future? It's too early to answer that question precisely. For now, the focus is to make the easiest and best engine for desktop development. Once we reach that goal, we think to start porting first to WebGL (to run in a Browser) and maybe Android. But it's not even in the roadmap yet.","title":"Frequently Asked Questions (FAQ)"},{"location":"Docs/faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"Docs/faq/#what-is-the-point-of-cave-engine","text":"In a nutshell: Cave Engine is focusing 100% on the usability and your experience using it. Keep it as simple as possible so even someone with zero experience with game development will be able to use it, but at the same time, keep it powerful enough to support your biggest dreams . And how we are managing to do that? We are a company called Uniday Studio that develops and teaches game dev since many years ago. We had te opportunity to reach more than two million people across the world on YouTube, teaching game dev, and we have hundreds and hundreds of students in our courses. After so many years, students and answering literally dozens of thousands of questions about the topic, we realized that a lot of people don't make their games because they found too hard to get started or use the software. We reched a conclusion that, just like a joke, if a game engine needs an explanation on how to use it, then this engine may not be that good. And that's our main principle now. Of course, some things inside a game engine may need a few tips to figure out how to use, but hours and hours of tutorials only to get started? That's not an option for us. Cave Engine is focused in provide the smallest path between you and your dream games.","title":"What is the Point of Cave Engine?"},{"location":"Docs/faq/#is-cave-engine-free","text":"Yes.","title":"Is Cave Engine free?"},{"location":"Docs/faq/#can-i-sell-or-redistribute-my-game-made-using-cave-engine","text":"Yes! Under attribution to the Cave Engine - by Uniday Studio. That's it!","title":"Can I sell or Redistribute my Game made using Cave Engine?"},{"location":"Docs/faq/#can-i-sell-or-redistribute-the-cave-engine-editor","text":"No! The Cave Engine Editor is an intellectual property of Uniday Studio and you don't have permission to sell or redistribute it. If you want/need to share the engine with someone, please use the links provided by Uniday Studio.","title":"Can I sell or Redistribute the Cave Engine Editor?"},{"location":"Docs/faq/#there-are-plans-to-support-2d-games","text":"No, there is no plans to add 2D game specific features. Cave Engine is 100% focused on 3D game development. But also note that nothing avoids you to use an ortographic camera and create a 2D game using it.","title":"There are plans to support 2D games?"},{"location":"Docs/faq/#how-can-i-create-my-logics-using-cave-engine","text":"You can do it using Python Scripts . And be aware: There are plans to include a Visual Programming alternative.","title":"How can I create my Logics using Cave Engine?"},{"location":"Docs/faq/#was-the-entire-engine-written-in-python","text":"Absolutely no! All the Engine and Editor was written in C/C++ and GLSL. We just provide Python Scripting as a front end for you to easily create the logic of your games.","title":"Was the entire engine written in Python?"},{"location":"Docs/faq/#to-which-platforms-can-i-export-my-game","text":"For now, you can export your games for Windows. There are plans to support Linux and Mac in the future, but it's low priority for now.","title":"To which Platforms can I export my game?"},{"location":"Docs/faq/#will-be-possible-to-export-the-game-to-other-platforms-such-as-android-in-the-future","text":"It's too early to answer that question precisely. For now, the focus is to make the easiest and best engine for desktop development. Once we reach that goal, we think to start porting first to WebGL (to run in a Browser) and maybe Android. But it's not even in the roadmap yet.","title":"Will be possible to export the game to other platforms such as Android in the future?"},{"location":"Docs/releases/","text":"Development logs Please check the itch io page to see the release notes (under the Development log area): Cave Engine on itch io","title":"Release Notes"},{"location":"Docs/releases/#development-logs","text":"Please check the itch io page to see the release notes (under the Development log area): Cave Engine on itch io","title":"Development logs"},{"location":"Docs/roadmap/","text":"Roadmap Cave Engine Alpha (Current) During this iteration the focus is to make Cave Engine as simple, usable, stable, solid and feature complete as possible. In other word, we need to make sure that everyone will be able to jump in and start making their games with the least amount of problems or difficults as possible. Here the focus will be on providing documentation, tutorials, bug fixes, build a community around it and also change and improve the UI and UX as much as we feel like it's necessary to make it as user friendly as possible. Again, from the ground up this engine needs to be friendly, easy to use and of course powerful enough to support your biggest dreams. So if something is missing to make that dream come true, here is the right time to add it! Cave Engine 1.0 Here the engine should be already stable enough and with a bunch of cool games made with it. Now it's time to keep cultivating so it can grow more and more! The attention to the usability and bug fixing still keeps the same (and this will never change), but now we have some cool new features in mind as wel.. Alpha Blending Particle System Viewport Gizmos and Tools Visual Scripting Cave Engine 2.0 Visual Shader Editing Timelines, a Cutscene Editor Terrain and Vegetation","title":"Roadmap"},{"location":"Docs/roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"Docs/roadmap/#cave-engine-alpha-current","text":"During this iteration the focus is to make Cave Engine as simple, usable, stable, solid and feature complete as possible. In other word, we need to make sure that everyone will be able to jump in and start making their games with the least amount of problems or difficults as possible. Here the focus will be on providing documentation, tutorials, bug fixes, build a community around it and also change and improve the UI and UX as much as we feel like it's necessary to make it as user friendly as possible. Again, from the ground up this engine needs to be friendly, easy to use and of course powerful enough to support your biggest dreams. So if something is missing to make that dream come true, here is the right time to add it!","title":"Cave Engine Alpha (Current)"},{"location":"Docs/roadmap/#cave-engine-10","text":"Here the engine should be already stable enough and with a bunch of cool games made with it. Now it's time to keep cultivating so it can grow more and more! The attention to the usability and bug fixing still keeps the same (and this will never change), but now we have some cool new features in mind as wel.. Alpha Blending Particle System Viewport Gizmos and Tools Visual Scripting","title":"Cave Engine 1.0"},{"location":"Docs/roadmap/#cave-engine-20","text":"Visual Shader Editing Timelines, a Cutscene Editor Terrain and Vegetation","title":"Cave Engine 2.0"},{"location":"Examples/python/","text":"Python Examples Ray Cast # Just getting the entity, transform and scene entity = self.getEntity() transform = entity.getTransform() scene = entity.getScene() # Ray Cast needs two parameters: origin and target. # It's basically where the ray starts and where it ends. # For this example, let's make the ray start at the player # position and go to its forward direction by 10 meters origin = transform.getPosition() target = origin + transform.getForwardVector() * 10 # The actual ray cast. Will return an cave.RayCastOut instance # that contains 4 variables: hit (bool), position (Vector3), # normal (Vector3), entity (cave.Entity or None) rOut = scene.rayCast(origin, target) if rOut.hit: hitEntity = rOut.entity print(\"Raycast hit with = \", hitEntity.name) point = rOut.position print(\"At this point = \", point.x, point.y, point.z) normal = rOut.normal print(\"Facing this Direction = \", normal.x, normal.y, normal.z) Mouselook Add this script to a Camera. It's recommended that you parent the camera to an object to represent the player. import cave class Mouselook(cave.Component): def __init__(self): self.mLastPos = None self.sensibility = 0.005 def start(self, scene): pass def mouselook(self): mPos = cave.getMousePosition(False) center = cave.getWindowSize() * 0.5 center = cave.Vector2(int(center.x), int(center.y)) if self.mLastPos: disp = center - mPos disp *= self.sensibility transform = self.entity.getTransform() transform.rotateOnPitch(disp.y) parent = self.entity.getParent() if parent: parentTransform = parent.getTransform() parentTransform.rotateOnRoll(disp.x) else: transform.rotateOnRoll(disp.x) cave.setMousePosition(int(center.x), int(center.y)) self.mLastPos = cave.Vector2(mPos.x, mPos.y) def update(self): events = cave.getEvents() if events.pressed(\"ESCAPE\"): cave.quitGame() self.mouselook() def end(self, scene): pass","title":"Python Scripting"},{"location":"Examples/python/#python-examples","text":"","title":"Python Examples"},{"location":"Examples/python/#ray-cast","text":"# Just getting the entity, transform and scene entity = self.getEntity() transform = entity.getTransform() scene = entity.getScene() # Ray Cast needs two parameters: origin and target. # It's basically where the ray starts and where it ends. # For this example, let's make the ray start at the player # position and go to its forward direction by 10 meters origin = transform.getPosition() target = origin + transform.getForwardVector() * 10 # The actual ray cast. Will return an cave.RayCastOut instance # that contains 4 variables: hit (bool), position (Vector3), # normal (Vector3), entity (cave.Entity or None) rOut = scene.rayCast(origin, target) if rOut.hit: hitEntity = rOut.entity print(\"Raycast hit with = \", hitEntity.name) point = rOut.position print(\"At this point = \", point.x, point.y, point.z) normal = rOut.normal print(\"Facing this Direction = \", normal.x, normal.y, normal.z)","title":"Ray Cast"},{"location":"Examples/python/#mouselook","text":"Add this script to a Camera. It's recommended that you parent the camera to an object to represent the player. import cave class Mouselook(cave.Component): def __init__(self): self.mLastPos = None self.sensibility = 0.005 def start(self, scene): pass def mouselook(self): mPos = cave.getMousePosition(False) center = cave.getWindowSize() * 0.5 center = cave.Vector2(int(center.x), int(center.y)) if self.mLastPos: disp = center - mPos disp *= self.sensibility transform = self.entity.getTransform() transform.rotateOnPitch(disp.y) parent = self.entity.getParent() if parent: parentTransform = parent.getTransform() parentTransform.rotateOnRoll(disp.x) else: transform.rotateOnRoll(disp.x) cave.setMousePosition(int(center.x), int(center.y)) self.mLastPos = cave.Vector2(mPos.x, mPos.y) def update(self): events = cave.getEvents() if events.pressed(\"ESCAPE\"): cave.quitGame() self.mouselook() def end(self, scene): pass","title":"Mouselook"},{"location":"Examples/tooling/","text":"Writting your own Tools In the Cave Engine you can write your own tools using python. They can be as simple as just executing a text to do something for you or more complex and well made tools, with a proper interface that contains buttons, sliders and whatever you want in a Tab format, that you can dock to the Editor's ui. To start writting your tools, create a new Python Script in the asset browser, open it in the text editor (double click) and delete the current startup code. Run your first Tool Let's start with a simple tool that just sets some Sun light settings: import cave # You can write the code you want to using the cave API: scene = cave.getCurrentScene() sun = scene.getSun() sun.hour = 6.15 sun.intensity = 5.0 sun.color = cave.Vector3(1.0, 0.8, 0.8) In order to run this code, simply go to \"Editor Tools..\" and then \"Run Script\": It will run and change the sun settings, as expected. Note that you can use print(...) here to debug your stuff as well. Have fun! Create a Tab and Interface for your Tool Now that you already know how to run simple scripts like that, it's time to understand how to do some a bit more advanced ones. So let's start talking about a tool with its own Tab docked in the editor, with a proper interface with buttons, sliders and so on. Here is a screenshot showing that in action. The code in the left generated the tab highlighted in red: Here is a simple code that produces a similar result and can be used as a starting point for your own tools: import cave import caveui as ui class Example(ui.DebugTab): def __init__(self): super().__init__() self.counter = 0 def draw(self): ui.text(\"Hello, world!\") ui.separator() self.counter = ui.prop(\"Counter\", self.counter) if ui.button(\"Increase counter (+1)\"): self.counter += 1 In order to run that and register the Tab to the ui, go to the \"Editor Tools...\" option and open the \"Register Tab...\" sub menu. It will automatically identify all the classes in the code that inherits from the base class caveui.DebugTab and show there. Simply click in the one you want to in order to register it.","title":"Writting your own Tools"},{"location":"Examples/tooling/#writting-your-own-tools","text":"In the Cave Engine you can write your own tools using python. They can be as simple as just executing a text to do something for you or more complex and well made tools, with a proper interface that contains buttons, sliders and whatever you want in a Tab format, that you can dock to the Editor's ui. To start writting your tools, create a new Python Script in the asset browser, open it in the text editor (double click) and delete the current startup code.","title":"Writting your own Tools"},{"location":"Examples/tooling/#run-your-first-tool","text":"Let's start with a simple tool that just sets some Sun light settings: import cave # You can write the code you want to using the cave API: scene = cave.getCurrentScene() sun = scene.getSun() sun.hour = 6.15 sun.intensity = 5.0 sun.color = cave.Vector3(1.0, 0.8, 0.8) In order to run this code, simply go to \"Editor Tools..\" and then \"Run Script\": It will run and change the sun settings, as expected. Note that you can use print(...) here to debug your stuff as well. Have fun!","title":"Run your first Tool"},{"location":"Examples/tooling/#create-a-tab-and-interface-for-your-tool","text":"Now that you already know how to run simple scripts like that, it's time to understand how to do some a bit more advanced ones. So let's start talking about a tool with its own Tab docked in the editor, with a proper interface with buttons, sliders and so on. Here is a screenshot showing that in action. The code in the left generated the tab highlighted in red: Here is a simple code that produces a similar result and can be used as a starting point for your own tools: import cave import caveui as ui class Example(ui.DebugTab): def __init__(self): super().__init__() self.counter = 0 def draw(self): ui.text(\"Hello, world!\") ui.separator() self.counter = ui.prop(\"Counter\", self.counter) if ui.button(\"Increase counter (+1)\"): self.counter += 1 In order to run that and register the Tab to the ui, go to the \"Editor Tools...\" option and open the \"Register Tab...\" sub menu. It will automatically identify all the classes in the code that inherits from the base class caveui.DebugTab and show there. Simply click in the one you want to in order to register it.","title":"Create a Tab and Interface for your Tool"},{"location":"PythonAPI/cave_module/","text":"Cave Module General Functions General game engine related functions and global variables. cave.getEvents() -> cave.Events cave.getDeltaTime() -> float You can use the deltaTime to multiply your variables before moving or rotating an entity, so the action will be consistent independently of the current FPS the game is running on. cave.getMousePosition() -> cave.Vector2 cave.setMousePosition(int x, int y) cave.getWindowSize() -> cave.Vector2 cave.quitGame() -> None cave.getCurrentScene() -> cave.Scene cave.setScene(sceneName : str) -> None cave.restartCurrentScene() -> None cave.Events How to use this class: events = cave.getEvents() if events.pressed(\"W\"): print(\"The user pressed the key W!\") if events.released(\"MOUSE_LEFT\"): print(\"The user released the left mouse button!\") Note: Do not instantiate a new instance of this class, you should always use the one provided by the cave.getEvents() function. Methods pressed(event : str) -> bool Returns True if the user just pressed the event key or False if not. active(event : str) -> bool Always returns True while the user is pressing the event key or False if not. released(event : str) -> bool Returns True if the user just released the event key or False if not. cave.Entity Variables name : str Methods kill() hasTag(tag : str) -> bool add(component : cave.Component) get(component : str) -> cave.Component getAll(component : str) -> list(cave.Component) getScene() -> cave.Scene getParent() -> cave.Entity getChildren() -> list(cave.Entity) getTransform() -> cave.TransformComponent getID() -> int cave.RayCastOut Variables hit : bool position : cave.Vector3 normal : cave.Vector3 entity : cave.Entity cave.Scene Methods newEntity() -> cave.Entity add(entity : cave.Entity) -> cave.Entity addFromTemplate(templateName : str, overrideTransform=True) -> cave.Entity The scene.add(entity) method is used to add an entity you manually build by yourself in the code. Most of the times it's not exactly what you want. That's why there is a scene.addFromTemplate(name) alternative: Given an Entity Template name, the engine will construct a new entity for you followying that template. Both methods returns the added entity for convenience. remove(entity : cave.Entity) rayCast(origin : cave.Vector3, target : cave.Vector3) -> cave.RayCastOut getSun() -> cave.Sun getEntity(id : int) -> cave.Entity getEntity(name : str) -> cave.Entity Note: Time complexity of getting an Entity by name (string) is O(n) and by ID is O(1) . In other words: get by name is way slower than by ID so it's recommended to store the entity ID and use it as much as you can. Also, when you have multiple entities with the same name in the scene, it will always return the first entity found (and this result may be non deterministic - in other words the result may vary). cave.Sun Variables hour : float # 0.0 to 24.0 angle : float # 0.0 to 360.0 color : cave.Vector3 intensity : float cave.Timer Methods get() -> float set(value : float) reset() cave.Component Variables entity : cave.Entity Methods start(scene : cave.Scene) update() end(scene : cave.Scene) reload() The reload() method will end() the component and then start() it again. It's useful because some components like the Mesh and the Light, for optimization purposes, pre cache the data and only changes it during the start.","title":"Cave Module"},{"location":"PythonAPI/cave_module/#cave-module","text":"","title":"Cave Module"},{"location":"PythonAPI/cave_module/#general-functions","text":"General game engine related functions and global variables. cave.getEvents() -> cave.Events cave.getDeltaTime() -> float You can use the deltaTime to multiply your variables before moving or rotating an entity, so the action will be consistent independently of the current FPS the game is running on. cave.getMousePosition() -> cave.Vector2 cave.setMousePosition(int x, int y) cave.getWindowSize() -> cave.Vector2 cave.quitGame() -> None cave.getCurrentScene() -> cave.Scene cave.setScene(sceneName : str) -> None cave.restartCurrentScene() -> None","title":"General Functions"},{"location":"PythonAPI/cave_module/#caveevents","text":"How to use this class: events = cave.getEvents() if events.pressed(\"W\"): print(\"The user pressed the key W!\") if events.released(\"MOUSE_LEFT\"): print(\"The user released the left mouse button!\") Note: Do not instantiate a new instance of this class, you should always use the one provided by the cave.getEvents() function.","title":"cave.Events"},{"location":"PythonAPI/cave_module/#methods","text":"pressed(event : str) -> bool Returns True if the user just pressed the event key or False if not. active(event : str) -> bool Always returns True while the user is pressing the event key or False if not. released(event : str) -> bool Returns True if the user just released the event key or False if not.","title":"Methods"},{"location":"PythonAPI/cave_module/#caveentity","text":"","title":"cave.Entity"},{"location":"PythonAPI/cave_module/#variables","text":"name : str","title":"Variables"},{"location":"PythonAPI/cave_module/#methods_1","text":"kill() hasTag(tag : str) -> bool add(component : cave.Component) get(component : str) -> cave.Component getAll(component : str) -> list(cave.Component) getScene() -> cave.Scene getParent() -> cave.Entity getChildren() -> list(cave.Entity) getTransform() -> cave.TransformComponent getID() -> int","title":"Methods"},{"location":"PythonAPI/cave_module/#caveraycastout","text":"","title":"cave.RayCastOut"},{"location":"PythonAPI/cave_module/#variables_1","text":"hit : bool position : cave.Vector3 normal : cave.Vector3 entity : cave.Entity","title":"Variables"},{"location":"PythonAPI/cave_module/#cavescene","text":"","title":"cave.Scene"},{"location":"PythonAPI/cave_module/#methods_2","text":"newEntity() -> cave.Entity add(entity : cave.Entity) -> cave.Entity addFromTemplate(templateName : str, overrideTransform=True) -> cave.Entity The scene.add(entity) method is used to add an entity you manually build by yourself in the code. Most of the times it's not exactly what you want. That's why there is a scene.addFromTemplate(name) alternative: Given an Entity Template name, the engine will construct a new entity for you followying that template. Both methods returns the added entity for convenience. remove(entity : cave.Entity) rayCast(origin : cave.Vector3, target : cave.Vector3) -> cave.RayCastOut getSun() -> cave.Sun getEntity(id : int) -> cave.Entity getEntity(name : str) -> cave.Entity Note: Time complexity of getting an Entity by name (string) is O(n) and by ID is O(1) . In other words: get by name is way slower than by ID so it's recommended to store the entity ID and use it as much as you can. Also, when you have multiple entities with the same name in the scene, it will always return the first entity found (and this result may be non deterministic - in other words the result may vary).","title":"Methods"},{"location":"PythonAPI/cave_module/#cavesun","text":"","title":"cave.Sun"},{"location":"PythonAPI/cave_module/#variables_2","text":"hour : float # 0.0 to 24.0 angle : float # 0.0 to 360.0 color : cave.Vector3 intensity : float","title":"Variables"},{"location":"PythonAPI/cave_module/#cavetimer","text":"","title":"cave.Timer"},{"location":"PythonAPI/cave_module/#methods_3","text":"get() -> float set(value : float) reset()","title":"Methods"},{"location":"PythonAPI/cave_module/#cavecomponent","text":"","title":"cave.Component"},{"location":"PythonAPI/cave_module/#variables_3","text":"entity : cave.Entity","title":"Variables"},{"location":"PythonAPI/cave_module/#methods_4","text":"start(scene : cave.Scene) update() end(scene : cave.Scene) reload() The reload() method will end() the component and then start() it again. It's useful because some components like the Mesh and the Light, for optimization purposes, pre cache the data and only changes it during the start.","title":"Methods"},{"location":"PythonAPI/components/","text":"Components cave.TransformComponent Variables position : cave.Vector3 scale : cave.Vector3 Note that you can't get/set the rotation using regular variables as you can with the position and scale . That's due to the way the engine works internally. So use the getters and setters for euler angles or quaternions to rotate as you need to. You can see the details bellow. Sample code (as it would be in the update method of a Component): [...] def update(self): transform = self.entity.getTransform() # Modifying the current euler angles by adding 0.1 on the Y axis: euler = transform.getEuler() euler.y += 0.1 transform.setEuler(euler) # or you can use this to ROTATE the object: # (will produce the same result as the approach above) transform.rotate(0, 0.1, 0) [...] # Last but no least, you can also do this to SET the euler: # (note that this approach will not produce the same result # as the two others presented above. This one wil SET the # rotation to [0, 0, 0]) transform.setEuler(0, 0, 0) Methods getEuler() -> cave.Vector3 setEuler(euler : cave.Vector3) setEuler(x : float, y : float, z : float) getQuaternion() -> cave.Quaternion setQuaternion(quaternion : cave.Quaternion) setQuaternion(x : float, y : float, z : float, w: float) getMatrix() -> cave.Matrix4 setMatrix(mat : cave.Matrix4) rotate(x : float, y : float, z : float) move(x : float, y : float, z : float, local = True) rotateOnAxis(angle : float, axis : cave.Vector3) rotateOnPitch(angle : float) rotateOnYaw(angle : float) rotateOnRoll(angle : float) applyLocalMovement(x : float, y : float, z : float) getPitch() -> float getYaw() -> float getRoll() -> float getForwardVector() -> cave.Vector3 getRightVector() -> cave.Vector3 getUpVector() -> cave.Vector3 lookAt(direction : cave.Vector3, up = cave.Vector3(0, 1, 0)) rotateVector(vec : cave.Vector3) -> cave.Vector3 transformVector(vec : cave.Vector3) -> cave.Vector3 cave.MeshComponent Methods setAnimation(animation : string) cave.LightComponent You can adjust various light parameters. Here is a sample code that makes the light color pulse using some timers and the python native math.sin() function: import cave import math import random class PulsingLight(cave.Component): def start(self, scene): self.speed = 2.0 # Creating some timers with a random value to sample from self.colorX = cave.Timer(random.random()) self.colorY = cave.Timer(random.random()) self.colorZ = cave.Timer(random.random()) def compute(self, value): # Maps the timer into a sin curve ranged [0 - 1] return (math.sin(value * self.speed) + 1) / 2 def update(self): light = self.entity.get(\"Light Component\") light.color.x = self.compute(self.colorX.get()) light.color.y = self.compute(self.colorY.get()) light.color.z = self.compute(self.colorZ.get()) print(light.color.x, light.color.y, light.color.z) # Don't forget to reload the light, otherwise it will not be updated: light.reload() def end(self, scene): pass Variables NOTE: Lights are pre cached so the changes you made in the following parameters will not be effective (applied to the light) until you call the reload() method. color : cave.Vector3 radius : float intensity : float cave.UIElementComponent Variables text : str position : cave.UIVector scale : cave.UIVector text : str Methods isHovered() -> bool cave.RigidBodyComponent Variables alwaysActive : bool linearVelocity : cave.Vector3 angularVelocity : cave.Vector3 angularFactor : cave.Vector3 Methods getCollisions() -> list(cave.Entity) collidedWith(tag : string) -> bool applyTorque(x : float, y : float, z : float) applyForce(x : float, y : float, z : float, location : cave.Vector3) isDynamic() -> bool setMass(value : float)","title":"Components"},{"location":"PythonAPI/components/#components","text":"","title":"Components"},{"location":"PythonAPI/components/#cavetransformcomponent","text":"","title":"cave.TransformComponent"},{"location":"PythonAPI/components/#variables","text":"position : cave.Vector3 scale : cave.Vector3 Note that you can't get/set the rotation using regular variables as you can with the position and scale . That's due to the way the engine works internally. So use the getters and setters for euler angles or quaternions to rotate as you need to. You can see the details bellow. Sample code (as it would be in the update method of a Component): [...] def update(self): transform = self.entity.getTransform() # Modifying the current euler angles by adding 0.1 on the Y axis: euler = transform.getEuler() euler.y += 0.1 transform.setEuler(euler) # or you can use this to ROTATE the object: # (will produce the same result as the approach above) transform.rotate(0, 0.1, 0) [...] # Last but no least, you can also do this to SET the euler: # (note that this approach will not produce the same result # as the two others presented above. This one wil SET the # rotation to [0, 0, 0]) transform.setEuler(0, 0, 0)","title":"Variables"},{"location":"PythonAPI/components/#methods","text":"getEuler() -> cave.Vector3 setEuler(euler : cave.Vector3) setEuler(x : float, y : float, z : float) getQuaternion() -> cave.Quaternion setQuaternion(quaternion : cave.Quaternion) setQuaternion(x : float, y : float, z : float, w: float) getMatrix() -> cave.Matrix4 setMatrix(mat : cave.Matrix4) rotate(x : float, y : float, z : float) move(x : float, y : float, z : float, local = True) rotateOnAxis(angle : float, axis : cave.Vector3) rotateOnPitch(angle : float) rotateOnYaw(angle : float) rotateOnRoll(angle : float) applyLocalMovement(x : float, y : float, z : float) getPitch() -> float getYaw() -> float getRoll() -> float getForwardVector() -> cave.Vector3 getRightVector() -> cave.Vector3 getUpVector() -> cave.Vector3 lookAt(direction : cave.Vector3, up = cave.Vector3(0, 1, 0)) rotateVector(vec : cave.Vector3) -> cave.Vector3 transformVector(vec : cave.Vector3) -> cave.Vector3","title":"Methods"},{"location":"PythonAPI/components/#cavemeshcomponent","text":"","title":"cave.MeshComponent"},{"location":"PythonAPI/components/#methods_1","text":"setAnimation(animation : string)","title":"Methods"},{"location":"PythonAPI/components/#cavelightcomponent","text":"You can adjust various light parameters. Here is a sample code that makes the light color pulse using some timers and the python native math.sin() function: import cave import math import random class PulsingLight(cave.Component): def start(self, scene): self.speed = 2.0 # Creating some timers with a random value to sample from self.colorX = cave.Timer(random.random()) self.colorY = cave.Timer(random.random()) self.colorZ = cave.Timer(random.random()) def compute(self, value): # Maps the timer into a sin curve ranged [0 - 1] return (math.sin(value * self.speed) + 1) / 2 def update(self): light = self.entity.get(\"Light Component\") light.color.x = self.compute(self.colorX.get()) light.color.y = self.compute(self.colorY.get()) light.color.z = self.compute(self.colorZ.get()) print(light.color.x, light.color.y, light.color.z) # Don't forget to reload the light, otherwise it will not be updated: light.reload() def end(self, scene): pass","title":"cave.LightComponent"},{"location":"PythonAPI/components/#variables_1","text":"NOTE: Lights are pre cached so the changes you made in the following parameters will not be effective (applied to the light) until you call the reload() method. color : cave.Vector3 radius : float intensity : float","title":"Variables"},{"location":"PythonAPI/components/#caveuielementcomponent","text":"","title":"cave.UIElementComponent"},{"location":"PythonAPI/components/#variables_2","text":"text : str position : cave.UIVector scale : cave.UIVector text : str","title":"Variables"},{"location":"PythonAPI/components/#methods_2","text":"isHovered() -> bool","title":"Methods"},{"location":"PythonAPI/components/#caverigidbodycomponent","text":"","title":"cave.RigidBodyComponent"},{"location":"PythonAPI/components/#variables_3","text":"alwaysActive : bool linearVelocity : cave.Vector3 angularVelocity : cave.Vector3 angularFactor : cave.Vector3","title":"Variables"},{"location":"PythonAPI/components/#methods_3","text":"getCollisions() -> list(cave.Entity) collidedWith(tag : string) -> bool applyTorque(x : float, y : float, z : float) applyForce(x : float, y : float, z : float, location : cave.Vector3) isDynamic() -> bool setMass(value : float)","title":"Methods"},{"location":"PythonAPI/eventNames/","text":"Event Names See cave.Events for more details. Event Name Key \"0\" 0 \"1\" 1 \"2\" 2 \"3\" 3 \"4\" 4 \"5\" 5 \"6\" 6 \"7\" 7 \"8\" 8 \"9\" 9 \"A\" A \"AC_BACK\" Ac Back \"AC_BOOKMARKS\" Ac Bookmarks \"AC_FORWARD\" Ac Forward \"AC_HOME\" Ac Home \"AC_REFRESH\" Ac Refresh \"AC_SEARCH\" Ac Search \"AC_STOP\" Ac Stop \"AGAIN\" Again \"ALTERASE\" Alterase \"AMPERSAND\" Ampersand \"APPLICATION\" Application \"ASTERISK\" Asterisk \"AT\" At \"AUDIOMUTE\" Audiomute \"AUDIONEXT\" Audionext \"AUDIOPLAY\" Audioplay \"AUDIOPREV\" Audioprev \"AUDIOSTOP\" Audiostop \"B\" B \"BACKQUOTE\" Backquote \"BACKSLASH\" Backslash \"BACKSPACE\" Backspace \"BRIGHTNESSDOWN\" Brightnessdown \"BRIGHTNESSUP\" Brightnessup \"C\" C \"CALCULATOR\" Calculator \"CANCEL\" Cancel \"CAPSLOCK\" Capslock \"CARET\" Caret \"CLEAR\" Clear \"CLEARAGAIN\" Clearagain \"COLON\" Colon \"COMMA\" Comma \"COMPUTER\" Computer \"COPY\" Copy \"CRSEL\" Crsel \"CURRENCYSUBUNIT\" Currencysubunit \"CURRENCYUNIT\" Currencyunit \"CUT\" Cut \"D\" D \"DECIMALSEPARATOR\" Decimalseparator \"DELETE\" Delete \"DISPLAYSWITCH\" Displayswitch \"DOLLAR\" Dollar \"DOWN\" Down \"E\" E \"EJECT\" Eject \"END\" End \"EQUALS\" Equals \"ESCAPE\" Escape \"EXCLAIM\" Exclaim \"EXECUTE_\" Execute \"EXSEL\" Exsel \"F\" F \"F1\" F1 \"F10\" F10 \"F11\" F11 \"F12\" F12 \"F13\" F13 \"F14\" F14 \"F15\" F15 \"F16\" F16 \"F17\" F17 \"F18\" F18 \"F19\" F19 \"F2\" F2 \"F20\" F20 \"F21\" F21 \"F22\" F22 \"F23\" F23 \"F24\" F24 \"F3\" F3 \"F4\" F4 \"F5\" F5 \"F6\" F6 \"F7\" F7 \"F8\" F8 \"F9\" F9 \"FIND\" Find \"G\" G \"GREATER\" Greater \"H\" H \"HASH\" Hash \"HELP\" Help \"HOME\" Home \"I\" I \"INSERT\" Insert \"J\" J \"K\" K \"KBDILLUMDOWN\" Kbdillumdown \"KBDILLUMTOGGLE\" Kbdillumtoggle \"KBDILLUMUP\" Kbdillumup \"KP_0\" Kp 0 \"KP_00\" Kp 00 \"KP_000\" Kp 000 \"KP_1\" Kp 1 \"KP_2\" Kp 2 \"KP_3\" Kp 3 \"KP_4\" Kp 4 \"KP_5\" Kp 5 \"KP_6\" Kp 6 \"KP_7\" Kp 7 \"KP_8\" Kp 8 \"KP_9\" Kp 9 \"KP_A\" Kp A \"KP_AMPERSAND\" Kp Ampersand \"KP_AT\" Kp At \"KP_B\" Kp B \"KP_BACKSPACE\" Kp Backspace \"KP_BINARY\" Kp Binary \"KP_C\" Kp C \"KP_CLEAR\" Kp Clear \"KP_CLEARENTRY\" Kp Clearentry \"KP_COLON\" Kp Colon \"KP_COMMA\" Kp Comma \"KP_D\" Kp D \"KP_DBLAMPERSAND\" Kp Dblampersand \"KP_DBLVERTICALBAR\" Kp Dblverticalbar \"KP_DECIMAL\" Kp Decimal \"KP_DIVIDE\" Kp Divide \"KP_E\" Kp E \"KP_ENTER\" Kp Enter \"KP_EQUALS\" Kp Equals \"KP_EQUALSAS400\" Kp Equalsas400 \"KP_EXCLAM\" Kp Exclam \"KP_F\" Kp F \"KP_GREATER\" Kp Greater \"KP_HASH\" Kp Hash \"KP_HEXADECIMAL\" Kp Hexadecimal \"KP_LEFTBRACE\" Kp Leftbrace \"KP_LEFTPAREN\" Kp Leftparen \"KP_LESS\" Kp Less \"KP_MEMADD\" Kp Memadd \"KP_MEMCLEAR\" Kp Memclear \"KP_MEMDIVIDE\" Kp Memdivide \"KP_MEMMULTIPLY\" Kp Memmultiply \"KP_MEMRECALL\" Kp Memrecall \"KP_MEMSTORE\" Kp Memstore \"KP_MEMSUBTRACT\" Kp Memsubtract \"KP_MINUS\" Kp Minus \"KP_MULTIPLY\" Kp Multiply \"KP_OCTAL\" Kp Octal \"KP_PERCENT\" Kp Percent \"KP_PERIOD\" Kp Period \"KP_PLUS\" Kp Plus \"KP_PLUSMINUS\" Kp Plusminus \"KP_POWER\" Kp Power \"KP_RIGHTBRACE\" Kp Rightbrace \"KP_RIGHTPAREN\" Kp Rightparen \"KP_SPACE\" Kp Space \"KP_TAB\" Kp Tab \"KP_VERTICALBAR\" Kp Verticalbar \"KP_XOR\" Kp Xor \"L\" L \"LALT\" Lalt \"LCTRL\" Lctrl \"LEFT\" Left \"LEFTBRACKET\" Leftbracket \"LEFTPAREN\" Leftparen \"LESS\" Less \"LGUI\" Lgui \"LSHIFT\" Lshift \"M\" M \"MAIL\" Mail \"MEDIASELECT\" Mediaselect \"MENU\" Menu \"MINUS\" Minus \"MODE\" Mode \"MOUSE_LEFT\" Mouse Left \"MOUSE_MIDDLE\" Mouse Middle \"MOUSE_RIGHT\" Mouse Right \"MUTE\" Mute \"N\" N \"NUMLOCKCLEAR\" Numlockclear \"O\" O \"OPER\" Oper \"OUT\" Out \"P\" P \"PAGEDOWN\" Pagedown \"PAGEUP\" Pageup \"PASTE\" Paste \"PAUSE\" Pause \"PERCENT\" Percent \"PERIOD\" Period \"PLUS\" Plus \"POWER\" Power \"PRINTSCREEN\" Printscreen \"PRIOR\" Prior \"Q\" Q \"QUESTION\" Question \"QUOTE\" Quote \"QUOTEDBL\" Quotedbl \"R\" R \"RALT\" Ralt \"RCTRL\" Rctrl \"RETURN\" Return \"RETURN2\" Return2 \"RGUI\" Rgui \"RIGHT\" Right \"RIGHTBRACKET\" Rightbracket \"RIGHTPAREN\" Rightparen \"RSHIFT\" Rshift \"S\" S \"SCROLLLOCK\" Scrolllock \"SELECT\" Select \"SEMICOLON\" Semicolon \"SEPARATOR\" Separator \"SIZE\" Size \"SLASH\" Slash \"SLEEP\" Sleep \"SPACE\" Space \"STOP\" Stop \"SYSREQ\" Sysreq \"T\" T \"TAB\" Tab \"THOUSANDSSEPARATOR\" Thousandsseparator \"U\" U \"UNDO\" Undo \"UNKNOWN\" Unknown \"UP\" Up \"V\" V \"VOLUMEDOWN\" Volumedown \"VOLUMEUP\" Volumeup \"W\" W \"WWW\" Www \"X\" X \"Y\" Y \"Z\" Z","title":"Event Names"},{"location":"PythonAPI/eventNames/#event-names","text":"See cave.Events for more details. Event Name Key \"0\" 0 \"1\" 1 \"2\" 2 \"3\" 3 \"4\" 4 \"5\" 5 \"6\" 6 \"7\" 7 \"8\" 8 \"9\" 9 \"A\" A \"AC_BACK\" Ac Back \"AC_BOOKMARKS\" Ac Bookmarks \"AC_FORWARD\" Ac Forward \"AC_HOME\" Ac Home \"AC_REFRESH\" Ac Refresh \"AC_SEARCH\" Ac Search \"AC_STOP\" Ac Stop \"AGAIN\" Again \"ALTERASE\" Alterase \"AMPERSAND\" Ampersand \"APPLICATION\" Application \"ASTERISK\" Asterisk \"AT\" At \"AUDIOMUTE\" Audiomute \"AUDIONEXT\" Audionext \"AUDIOPLAY\" Audioplay \"AUDIOPREV\" Audioprev \"AUDIOSTOP\" Audiostop \"B\" B \"BACKQUOTE\" Backquote \"BACKSLASH\" Backslash \"BACKSPACE\" Backspace \"BRIGHTNESSDOWN\" Brightnessdown \"BRIGHTNESSUP\" Brightnessup \"C\" C \"CALCULATOR\" Calculator \"CANCEL\" Cancel \"CAPSLOCK\" Capslock \"CARET\" Caret \"CLEAR\" Clear \"CLEARAGAIN\" Clearagain \"COLON\" Colon \"COMMA\" Comma \"COMPUTER\" Computer \"COPY\" Copy \"CRSEL\" Crsel \"CURRENCYSUBUNIT\" Currencysubunit \"CURRENCYUNIT\" Currencyunit \"CUT\" Cut \"D\" D \"DECIMALSEPARATOR\" Decimalseparator \"DELETE\" Delete \"DISPLAYSWITCH\" Displayswitch \"DOLLAR\" Dollar \"DOWN\" Down \"E\" E \"EJECT\" Eject \"END\" End \"EQUALS\" Equals \"ESCAPE\" Escape \"EXCLAIM\" Exclaim \"EXECUTE_\" Execute \"EXSEL\" Exsel \"F\" F \"F1\" F1 \"F10\" F10 \"F11\" F11 \"F12\" F12 \"F13\" F13 \"F14\" F14 \"F15\" F15 \"F16\" F16 \"F17\" F17 \"F18\" F18 \"F19\" F19 \"F2\" F2 \"F20\" F20 \"F21\" F21 \"F22\" F22 \"F23\" F23 \"F24\" F24 \"F3\" F3 \"F4\" F4 \"F5\" F5 \"F6\" F6 \"F7\" F7 \"F8\" F8 \"F9\" F9 \"FIND\" Find \"G\" G \"GREATER\" Greater \"H\" H \"HASH\" Hash \"HELP\" Help \"HOME\" Home \"I\" I \"INSERT\" Insert \"J\" J \"K\" K \"KBDILLUMDOWN\" Kbdillumdown \"KBDILLUMTOGGLE\" Kbdillumtoggle \"KBDILLUMUP\" Kbdillumup \"KP_0\" Kp 0 \"KP_00\" Kp 00 \"KP_000\" Kp 000 \"KP_1\" Kp 1 \"KP_2\" Kp 2 \"KP_3\" Kp 3 \"KP_4\" Kp 4 \"KP_5\" Kp 5 \"KP_6\" Kp 6 \"KP_7\" Kp 7 \"KP_8\" Kp 8 \"KP_9\" Kp 9 \"KP_A\" Kp A \"KP_AMPERSAND\" Kp Ampersand \"KP_AT\" Kp At \"KP_B\" Kp B \"KP_BACKSPACE\" Kp Backspace \"KP_BINARY\" Kp Binary \"KP_C\" Kp C \"KP_CLEAR\" Kp Clear \"KP_CLEARENTRY\" Kp Clearentry \"KP_COLON\" Kp Colon \"KP_COMMA\" Kp Comma \"KP_D\" Kp D \"KP_DBLAMPERSAND\" Kp Dblampersand \"KP_DBLVERTICALBAR\" Kp Dblverticalbar \"KP_DECIMAL\" Kp Decimal \"KP_DIVIDE\" Kp Divide \"KP_E\" Kp E \"KP_ENTER\" Kp Enter \"KP_EQUALS\" Kp Equals \"KP_EQUALSAS400\" Kp Equalsas400 \"KP_EXCLAM\" Kp Exclam \"KP_F\" Kp F \"KP_GREATER\" Kp Greater \"KP_HASH\" Kp Hash \"KP_HEXADECIMAL\" Kp Hexadecimal \"KP_LEFTBRACE\" Kp Leftbrace \"KP_LEFTPAREN\" Kp Leftparen \"KP_LESS\" Kp Less \"KP_MEMADD\" Kp Memadd \"KP_MEMCLEAR\" Kp Memclear \"KP_MEMDIVIDE\" Kp Memdivide \"KP_MEMMULTIPLY\" Kp Memmultiply \"KP_MEMRECALL\" Kp Memrecall \"KP_MEMSTORE\" Kp Memstore \"KP_MEMSUBTRACT\" Kp Memsubtract \"KP_MINUS\" Kp Minus \"KP_MULTIPLY\" Kp Multiply \"KP_OCTAL\" Kp Octal \"KP_PERCENT\" Kp Percent \"KP_PERIOD\" Kp Period \"KP_PLUS\" Kp Plus \"KP_PLUSMINUS\" Kp Plusminus \"KP_POWER\" Kp Power \"KP_RIGHTBRACE\" Kp Rightbrace \"KP_RIGHTPAREN\" Kp Rightparen \"KP_SPACE\" Kp Space \"KP_TAB\" Kp Tab \"KP_VERTICALBAR\" Kp Verticalbar \"KP_XOR\" Kp Xor \"L\" L \"LALT\" Lalt \"LCTRL\" Lctrl \"LEFT\" Left \"LEFTBRACKET\" Leftbracket \"LEFTPAREN\" Leftparen \"LESS\" Less \"LGUI\" Lgui \"LSHIFT\" Lshift \"M\" M \"MAIL\" Mail \"MEDIASELECT\" Mediaselect \"MENU\" Menu \"MINUS\" Minus \"MODE\" Mode \"MOUSE_LEFT\" Mouse Left \"MOUSE_MIDDLE\" Mouse Middle \"MOUSE_RIGHT\" Mouse Right \"MUTE\" Mute \"N\" N \"NUMLOCKCLEAR\" Numlockclear \"O\" O \"OPER\" Oper \"OUT\" Out \"P\" P \"PAGEDOWN\" Pagedown \"PAGEUP\" Pageup \"PASTE\" Paste \"PAUSE\" Pause \"PERCENT\" Percent \"PERIOD\" Period \"PLUS\" Plus \"POWER\" Power \"PRINTSCREEN\" Printscreen \"PRIOR\" Prior \"Q\" Q \"QUESTION\" Question \"QUOTE\" Quote \"QUOTEDBL\" Quotedbl \"R\" R \"RALT\" Ralt \"RCTRL\" Rctrl \"RETURN\" Return \"RETURN2\" Return2 \"RGUI\" Rgui \"RIGHT\" Right \"RIGHTBRACKET\" Rightbracket \"RIGHTPAREN\" Rightparen \"RSHIFT\" Rshift \"S\" S \"SCROLLLOCK\" Scrolllock \"SELECT\" Select \"SEMICOLON\" Semicolon \"SEPARATOR\" Separator \"SIZE\" Size \"SLASH\" Slash \"SLEEP\" Sleep \"SPACE\" Space \"STOP\" Stop \"SYSREQ\" Sysreq \"T\" T \"TAB\" Tab \"THOUSANDSSEPARATOR\" Thousandsseparator \"U\" U \"UNDO\" Undo \"UNKNOWN\" Unknown \"UP\" Up \"V\" V \"VOLUMEDOWN\" Volumedown \"VOLUMEUP\" Volumeup \"W\" W \"WWW\" Www \"X\" X \"Y\" Y \"Z\" Z","title":"Event Names"},{"location":"PythonAPI/math/","text":"Math cave Functions normalized(vec : cave.Vector3) -> cave.Vector3 length(vec : cave.Vector3) -> float Vector Classes Cave Engine provides wrappers to low level C++ vector classes and operations. Initialization Example Here is an initialization example to get started: # Default constructor: vec = cave.Vector() # Intialize the vector with (0, 0): myVec1 = cave.Vector2(0) # Regular (x, y) constructor for the 2D Vector: myVec2 = cave.Vector2(0, 1) # Copy the vector: myVec3 = cave.Vector3(myVec2) Supported Vector Operations You can do all sorts of operations using vectors: Operation Usage == if vecA == vecB: ... + vec = vecA + vecB += vec += vecB - vec = vecA - vecB -= vec -= vecB * vec = vecB * 50.0 * vec = 50.0 * vecB *= vec *= 100.0 Including operations between a cave.Vector3 and an cave.Quaternion : Operation Usage * vec = vec * quaterion * vec = quaterion * vecB *= vec *= quaterion cave.Vector2 Variables x : float y : float Note: You can also access the x, y parameters by using s, t or u, v . cave.Vector3 Variables x : float y : float z : float Note: You can also access the x, y, z parameters by using r, g, b as an acronym for the color channels Red , Green and Blue . cave.Vector4 Variables x : float y : float z : float w : float Note: You can also access the x, y, z, w parameters by using r, g, b, a as an acronym for the color channels Red , Green , Blue and Alpha . cave.Quaternion Quaternions, just like the vectors, are low level implementations that supports all sorts of operations ( ==, +, +=, -, -=, *, *= ). Variables x : float y : float z : float w : float cave.UIVector The cave.UIVector is a different vector, used specifically for the in Game User Interface (Game UI). It needs to be a different type of vector because it also takes into account the anchoring and if the element is relative (or not) to it's parent. If the vector is relative, the X, Y values will be represented with a [0-1] ranged float number (percentage). If not, it will be represented by two ints for the pixels. Variables anchoringX : int anchoringY : int The supported anchoring values are: -1, 0, 1 . Methods isRelativeX() -> bool isRelativeY() -> bool getX(parentScale = 1.0) -> float getY(parentScale = 1.0) -> float setPixelX(value : int) setPixelY(value : int) setPixel(x : int, y : int) setRelativeX(value : float) setRelativeY(value : float) setRelative(x : float, y : float)","title":"Math"},{"location":"PythonAPI/math/#math","text":"","title":"Math"},{"location":"PythonAPI/math/#cave","text":"","title":"cave"},{"location":"PythonAPI/math/#functions","text":"normalized(vec : cave.Vector3) -> cave.Vector3 length(vec : cave.Vector3) -> float","title":"Functions"},{"location":"PythonAPI/math/#vector-classes","text":"Cave Engine provides wrappers to low level C++ vector classes and operations.","title":"Vector Classes"},{"location":"PythonAPI/math/#initialization-example","text":"Here is an initialization example to get started: # Default constructor: vec = cave.Vector() # Intialize the vector with (0, 0): myVec1 = cave.Vector2(0) # Regular (x, y) constructor for the 2D Vector: myVec2 = cave.Vector2(0, 1) # Copy the vector: myVec3 = cave.Vector3(myVec2)","title":"Initialization Example"},{"location":"PythonAPI/math/#supported-vector-operations","text":"You can do all sorts of operations using vectors: Operation Usage == if vecA == vecB: ... + vec = vecA + vecB += vec += vecB - vec = vecA - vecB -= vec -= vecB * vec = vecB * 50.0 * vec = 50.0 * vecB *= vec *= 100.0 Including operations between a cave.Vector3 and an cave.Quaternion : Operation Usage * vec = vec * quaterion * vec = quaterion * vecB *= vec *= quaterion","title":"Supported Vector Operations"},{"location":"PythonAPI/math/#cavevector2","text":"","title":"cave.Vector2"},{"location":"PythonAPI/math/#variables","text":"x : float y : float Note: You can also access the x, y parameters by using s, t or u, v .","title":"Variables"},{"location":"PythonAPI/math/#cavevector3","text":"","title":"cave.Vector3"},{"location":"PythonAPI/math/#variables_1","text":"x : float y : float z : float Note: You can also access the x, y, z parameters by using r, g, b as an acronym for the color channels Red , Green and Blue .","title":"Variables"},{"location":"PythonAPI/math/#cavevector4","text":"","title":"cave.Vector4"},{"location":"PythonAPI/math/#variables_2","text":"x : float y : float z : float w : float Note: You can also access the x, y, z, w parameters by using r, g, b, a as an acronym for the color channels Red , Green , Blue and Alpha .","title":"Variables"},{"location":"PythonAPI/math/#cavequaternion","text":"Quaternions, just like the vectors, are low level implementations that supports all sorts of operations ( ==, +, +=, -, -=, *, *= ).","title":"cave.Quaternion"},{"location":"PythonAPI/math/#variables_3","text":"x : float y : float z : float w : float","title":"Variables"},{"location":"PythonAPI/math/#caveuivector","text":"The cave.UIVector is a different vector, used specifically for the in Game User Interface (Game UI). It needs to be a different type of vector because it also takes into account the anchoring and if the element is relative (or not) to it's parent. If the vector is relative, the X, Y values will be represented with a [0-1] ranged float number (percentage). If not, it will be represented by two ints for the pixels.","title":"cave.UIVector"},{"location":"PythonAPI/math/#variables_4","text":"anchoringX : int anchoringY : int The supported anchoring values are: -1, 0, 1 .","title":"Variables"},{"location":"PythonAPI/math/#methods","text":"isRelativeX() -> bool isRelativeY() -> bool getX(parentScale = 1.0) -> float getY(parentScale = 1.0) -> float setPixelX(value : int) setPixelY(value : int) setPixel(x : int, y : int) setRelativeX(value : float) setRelativeY(value : float) setRelative(x : float, y : float)","title":"Methods"},{"location":"Showcase/games/","text":"Games Powered by Cave In this section you'll find good examples of what is possible to do using Cave Engine . Sweet Shelter The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here: Sweet Shelter on itch io","title":"Games Made with Cave"},{"location":"Showcase/games/#games-powered-by-cave","text":"In this section you'll find good examples of what is possible to do using Cave Engine .","title":"Games Powered by Cave"},{"location":"Showcase/games/#sweet-shelter","text":"The World's first Cave Game! Yes, this is the first game ever made and exported with Cave Engine (version 0.9.6 - alpha). It was made in about 72 hours by @renatoaruffo for a Game Jam (#UnidayJam2021). The game is inspired by Little Nightmares and Hansel and Gretel. The player is lost in a forest, on a heavy rainy night, full of delicious treat, trying to find her brother. You can download and play the game here: Sweet Shelter on itch io","title":"Sweet Shelter"}]}